/* automatically generated by rust-bindgen 0.65.1 */

pub const __LINUX__: u32 = 1;
pub const _INTTYPES_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 37;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2usize] = b"l\0";
pub const PRId8: &[u8; 2usize] = b"d\0";
pub const PRId16: &[u8; 2usize] = b"d\0";
pub const PRId32: &[u8; 2usize] = b"d\0";
pub const PRId64: &[u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &[u8; 2usize] = b"d\0";
pub const PRIdFAST16: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &[u8; 3usize] = b"ld\0";
pub const PRIi8: &[u8; 2usize] = b"i\0";
pub const PRIi16: &[u8; 2usize] = b"i\0";
pub const PRIi32: &[u8; 2usize] = b"i\0";
pub const PRIi64: &[u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &[u8; 3usize] = b"li\0";
pub const PRIiFAST8: &[u8; 2usize] = b"i\0";
pub const PRIiFAST16: &[u8; 3usize] = b"li\0";
pub const PRIiFAST32: &[u8; 3usize] = b"li\0";
pub const PRIiFAST64: &[u8; 3usize] = b"li\0";
pub const PRIo8: &[u8; 2usize] = b"o\0";
pub const PRIo16: &[u8; 2usize] = b"o\0";
pub const PRIo32: &[u8; 2usize] = b"o\0";
pub const PRIo64: &[u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &[u8; 2usize] = b"o\0";
pub const PRIoFAST16: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &[u8; 3usize] = b"lo\0";
pub const PRIu8: &[u8; 2usize] = b"u\0";
pub const PRIu16: &[u8; 2usize] = b"u\0";
pub const PRIu32: &[u8; 2usize] = b"u\0";
pub const PRIu64: &[u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &[u8; 2usize] = b"u\0";
pub const PRIuFAST16: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &[u8; 3usize] = b"lu\0";
pub const PRIx8: &[u8; 2usize] = b"x\0";
pub const PRIx16: &[u8; 2usize] = b"x\0";
pub const PRIx32: &[u8; 2usize] = b"x\0";
pub const PRIx64: &[u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &[u8; 2usize] = b"x\0";
pub const PRIxFAST16: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &[u8; 3usize] = b"lx\0";
pub const PRIX8: &[u8; 2usize] = b"X\0";
pub const PRIX16: &[u8; 2usize] = b"X\0";
pub const PRIX32: &[u8; 2usize] = b"X\0";
pub const PRIX64: &[u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &[u8; 2usize] = b"X\0";
pub const PRIXFAST16: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &[u8; 3usize] = b"lX\0";
pub const PRIdMAX: &[u8; 3usize] = b"ld\0";
pub const PRIiMAX: &[u8; 3usize] = b"li\0";
pub const PRIoMAX: &[u8; 3usize] = b"lo\0";
pub const PRIuMAX: &[u8; 3usize] = b"lu\0";
pub const PRIxMAX: &[u8; 3usize] = b"lx\0";
pub const PRIXMAX: &[u8; 3usize] = b"lX\0";
pub const PRIdPTR: &[u8; 3usize] = b"ld\0";
pub const PRIiPTR: &[u8; 3usize] = b"li\0";
pub const PRIoPTR: &[u8; 3usize] = b"lo\0";
pub const PRIuPTR: &[u8; 3usize] = b"lu\0";
pub const PRIxPTR: &[u8; 3usize] = b"lx\0";
pub const PRIXPTR: &[u8; 3usize] = b"lX\0";
pub const SCNd8: &[u8; 4usize] = b"hhd\0";
pub const SCNd16: &[u8; 3usize] = b"hd\0";
pub const SCNd32: &[u8; 2usize] = b"d\0";
pub const SCNd64: &[u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &[u8; 3usize] = b"ld\0";
pub const SCNi8: &[u8; 4usize] = b"hhi\0";
pub const SCNi16: &[u8; 3usize] = b"hi\0";
pub const SCNi32: &[u8; 2usize] = b"i\0";
pub const SCNi64: &[u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &[u8; 3usize] = b"li\0";
pub const SCNiFAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3usize] = b"li\0";
pub const SCNiFAST32: &[u8; 3usize] = b"li\0";
pub const SCNiFAST64: &[u8; 3usize] = b"li\0";
pub const SCNu8: &[u8; 4usize] = b"hhu\0";
pub const SCNu16: &[u8; 3usize] = b"hu\0";
pub const SCNu32: &[u8; 2usize] = b"u\0";
pub const SCNu64: &[u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &[u8; 3usize] = b"lu\0";
pub const SCNo8: &[u8; 4usize] = b"hho\0";
pub const SCNo16: &[u8; 3usize] = b"ho\0";
pub const SCNo32: &[u8; 2usize] = b"o\0";
pub const SCNo64: &[u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &[u8; 3usize] = b"lo\0";
pub const SCNx8: &[u8; 4usize] = b"hhx\0";
pub const SCNx16: &[u8; 3usize] = b"hx\0";
pub const SCNx32: &[u8; 2usize] = b"x\0";
pub const SCNx64: &[u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &[u8; 3usize] = b"lx\0";
pub const SCNdMAX: &[u8; 3usize] = b"ld\0";
pub const SCNiMAX: &[u8; 3usize] = b"li\0";
pub const SCNoMAX: &[u8; 3usize] = b"lo\0";
pub const SCNuMAX: &[u8; 3usize] = b"lu\0";
pub const SCNxMAX: &[u8; 3usize] = b"lx\0";
pub const SCNdPTR: &[u8; 3usize] = b"ld\0";
pub const SCNiPTR: &[u8; 3usize] = b"li\0";
pub const SCNoPTR: &[u8; 3usize] = b"lo\0";
pub const SCNuPTR: &[u8; 3usize] = b"lu\0";
pub const SCNxPTR: &[u8; 3usize] = b"lx\0";
pub const __GNUC_VA_LIST: u32 = 1;
pub const _WCHAR_H: u32 = 1;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __wint_t_defined: u32 = 1;
pub const _WINT_T: u32 = 1;
pub const __mbstate_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const WEOF: u32 = 4294967295;
pub const SDL_SIZE_MAX: i32 = -1;
pub const SDL_PRIs64: &[u8; 3usize] = b"ld\0";
pub const SDL_PRIu64: &[u8; 3usize] = b"lu\0";
pub const SDL_PRIx64: &[u8; 3usize] = b"lx\0";
pub const SDL_PRIX64: &[u8; 3usize] = b"lX\0";
pub const SDL_PRIs32: &[u8; 2usize] = b"d\0";
pub const SDL_PRIu32: &[u8; 2usize] = b"u\0";
pub const SDL_PRIx32: &[u8; 2usize] = b"x\0";
pub const SDL_PRIX32: &[u8; 2usize] = b"X\0";
pub const SDL_PI_D: f64 = 3.141592653589793;
pub const SDL_PI_F: f64 = 3.141592653589793;
pub const SDL_ASSERT_LEVEL: u32 = 2;
pub const SDL_NULL_WHILE_LOOP_CONDITION: u32 = 0;
pub const SDL_LIL_ENDIAN: u32 = 1234;
pub const SDL_BIG_ENDIAN: u32 = 4321;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const SDL_BYTEORDER: u32 = 1234;
pub const SDL_FLOATWORDORDER: u32 = 1234;
pub const SDL_MUTEX_TIMEDOUT: u32 = 1;
pub const SDL_MUTEX_MAXWAIT: i32 = -1;
pub const SDL_RWLOCK_TIMEDOUT: u32 = 1;
pub const SDL_RWOPS_UNKNOWN: u32 = 0;
pub const SDL_RWOPS_WINFILE: u32 = 1;
pub const SDL_RWOPS_STDFILE: u32 = 2;
pub const SDL_RWOPS_JNIFILE: u32 = 3;
pub const SDL_RWOPS_MEMORY: u32 = 4;
pub const SDL_RWOPS_MEMORY_RO: u32 = 5;
pub const SDL_RW_SEEK_SET: u32 = 0;
pub const SDL_RW_SEEK_CUR: u32 = 1;
pub const SDL_RW_SEEK_END: u32 = 2;
pub const SDL_AUDIO_MASK_BITSIZE: u32 = 255;
pub const SDL_AUDIO_MASK_DATATYPE: u32 = 256;
pub const SDL_AUDIO_MASK_ENDIAN: u32 = 4096;
pub const SDL_AUDIO_MASK_SIGNED: u32 = 32768;
pub const SDL_AUDIO_U8: u32 = 8;
pub const SDL_AUDIO_S8: u32 = 32776;
pub const SDL_AUDIO_S16LSB: u32 = 32784;
pub const SDL_AUDIO_S16MSB: u32 = 36880;
pub const SDL_AUDIO_S16: u32 = 32784;
pub const SDL_AUDIO_S32LSB: u32 = 32800;
pub const SDL_AUDIO_S32MSB: u32 = 36896;
pub const SDL_AUDIO_S32: u32 = 32800;
pub const SDL_AUDIO_F32LSB: u32 = 33056;
pub const SDL_AUDIO_F32MSB: u32 = 37152;
pub const SDL_AUDIO_F32: u32 = 33056;
pub const SDL_AUDIO_S16SYS: u32 = 32784;
pub const SDL_AUDIO_S32SYS: u32 = 32800;
pub const SDL_AUDIO_F32SYS: u32 = 33056;
pub const SDL_AUDIO_ALLOW_FREQUENCY_CHANGE: u32 = 1;
pub const SDL_AUDIO_ALLOW_FORMAT_CHANGE: u32 = 2;
pub const SDL_AUDIO_ALLOW_CHANNELS_CHANGE: u32 = 4;
pub const SDL_AUDIO_ALLOW_SAMPLES_CHANGE: u32 = 8;
pub const SDL_AUDIO_ALLOW_ANY_CHANGE: u32 = 15;
pub const SDL_MIX_MAXVOLUME: u32 = 128;
pub const SDL_CACHELINE_SIZE: u32 = 128;
pub const SDL_STANDARD_GRAVITY: f64 = 9.80665;
pub const SDL_JOYSTICK_AXIS_MAX: u32 = 32767;
pub const SDL_JOYSTICK_AXIS_MIN: i32 = -32768;
pub const SDL_IPHONE_MAX_GFORCE: f64 = 5.0;
pub const SDL_VIRTUAL_JOYSTICK_DESC_VERSION: u32 = 1;
pub const SDL_HAT_CENTERED: u32 = 0;
pub const SDL_HAT_UP: u32 = 1;
pub const SDL_HAT_RIGHT: u32 = 2;
pub const SDL_HAT_DOWN: u32 = 4;
pub const SDL_HAT_LEFT: u32 = 8;
pub const SDL_HAT_RIGHTUP: u32 = 3;
pub const SDL_HAT_RIGHTDOWN: u32 = 6;
pub const SDL_HAT_LEFTUP: u32 = 9;
pub const SDL_HAT_LEFTDOWN: u32 = 12;
pub const SDLK_SCANCODE_MASK: u32 = 1073741824;
pub const SDL_ALPHA_OPAQUE: u32 = 255;
pub const SDL_ALPHA_TRANSPARENT: u32 = 0;
pub const SDL_SWSURFACE: u32 = 0;
pub const SDL_PREALLOC: u32 = 1;
pub const SDL_RLEACCEL: u32 = 2;
pub const SDL_DONTFREE: u32 = 4;
pub const SDL_SIMD_ALIGNED: u32 = 8;
pub const SDL_WINDOWPOS_UNDEFINED_MASK: u32 = 536805376;
pub const SDL_WINDOWPOS_CENTERED_MASK: u32 = 805240832;
pub const SDL_BUTTON_LEFT: u32 = 1;
pub const SDL_BUTTON_MIDDLE: u32 = 2;
pub const SDL_BUTTON_RIGHT: u32 = 3;
pub const SDL_BUTTON_X1: u32 = 4;
pub const SDL_BUTTON_X2: u32 = 5;
pub const SDL_PEN_INFO_UNKNOWN: i32 = -1;
pub const SDL_PEN_FLAG_INK_BIT_INDEX: u32 = 14;
pub const SDL_PEN_FLAG_ERASER_BIT_INDEX: u32 = 15;
pub const SDL_PEN_FLAG_AXIS_BIT_OFFSET: u32 = 16;
pub const SDL_RELEASED: u32 = 0;
pub const SDL_PRESSED: u32 = 1;
pub const SDL_TEXTEDITINGEVENT_TEXT_SIZE: u32 = 32;
pub const SDL_TEXTINPUTEVENT_TEXT_SIZE: u32 = 32;
pub const SDL_HAPTIC_CONSTANT: u32 = 1;
pub const SDL_HAPTIC_SINE: u32 = 2;
pub const SDL_HAPTIC_LEFTRIGHT: u32 = 4;
pub const SDL_HAPTIC_TRIANGLE: u32 = 8;
pub const SDL_HAPTIC_SAWTOOTHUP: u32 = 16;
pub const SDL_HAPTIC_SAWTOOTHDOWN: u32 = 32;
pub const SDL_HAPTIC_RAMP: u32 = 64;
pub const SDL_HAPTIC_SPRING: u32 = 128;
pub const SDL_HAPTIC_DAMPER: u32 = 256;
pub const SDL_HAPTIC_INERTIA: u32 = 512;
pub const SDL_HAPTIC_FRICTION: u32 = 1024;
pub const SDL_HAPTIC_CUSTOM: u32 = 2048;
pub const SDL_HAPTIC_GAIN: u32 = 4096;
pub const SDL_HAPTIC_AUTOCENTER: u32 = 8192;
pub const SDL_HAPTIC_STATUS: u32 = 16384;
pub const SDL_HAPTIC_PAUSE: u32 = 32768;
pub const SDL_HAPTIC_POLAR: u32 = 0;
pub const SDL_HAPTIC_CARTESIAN: u32 = 1;
pub const SDL_HAPTIC_SPHERICAL: u32 = 2;
pub const SDL_HAPTIC_STEERING_AXIS: u32 = 3;
pub const SDL_HAPTIC_INFINITY: u32 = 4294967295;
pub const SDL_HINT_ACCELEROMETER_AS_JOYSTICK: &[u8; 30usize] = b"SDL_ACCELEROMETER_AS_JOYSTICK\0";
pub const SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED: &[u8; 32usize] =
    b"SDL_ALLOW_ALT_TAB_WHILE_GRABBED\0";
pub const SDL_HINT_ALLOW_TOPMOST: &[u8; 18usize] = b"SDL_ALLOW_TOPMOST\0";
pub const SDL_HINT_ANDROID_BLOCK_ON_PAUSE: &[u8; 27usize] = b"SDL_ANDROID_BLOCK_ON_PAUSE\0";
pub const SDL_HINT_ANDROID_BLOCK_ON_PAUSE_PAUSEAUDIO: &[u8; 38usize] =
    b"SDL_ANDROID_BLOCK_ON_PAUSE_PAUSEAUDIO\0";
pub const SDL_HINT_ANDROID_TRAP_BACK_BUTTON: &[u8; 29usize] = b"SDL_ANDROID_TRAP_BACK_BUTTON\0";
pub const SDL_HINT_ANDROID_ALLOW_RECREATE_ACTIVITY: &[u8; 36usize] =
    b"SDL_ANDROID_ALLOW_RECREATE_ACTIVITY\0";
pub const SDL_HINT_APP_ID: &[u8; 11usize] = b"SDL_APP_ID\0";
pub const SDL_HINT_APP_NAME: &[u8; 13usize] = b"SDL_APP_NAME\0";
pub const SDL_HINT_APPLE_TV_CONTROLLER_UI_EVENTS: &[u8; 34usize] =
    b"SDL_APPLE_TV_CONTROLLER_UI_EVENTS\0";
pub const SDL_HINT_APPLE_TV_REMOTE_ALLOW_ROTATION: &[u8; 35usize] =
    b"SDL_APPLE_TV_REMOTE_ALLOW_ROTATION\0";
pub const SDL_HINT_AUDIO_CATEGORY: &[u8; 19usize] = b"SDL_AUDIO_CATEGORY\0";
pub const SDL_HINT_AUDIO_DEVICE_APP_NAME: &[u8; 26usize] = b"SDL_AUDIO_DEVICE_APP_NAME\0";
pub const SDL_HINT_AUDIO_DEVICE_STREAM_NAME: &[u8; 29usize] = b"SDL_AUDIO_DEVICE_STREAM_NAME\0";
pub const SDL_HINT_AUDIO_DEVICE_STREAM_ROLE: &[u8; 29usize] = b"SDL_AUDIO_DEVICE_STREAM_ROLE\0";
pub const SDL_HINT_AUTO_UPDATE_JOYSTICKS: &[u8; 26usize] = b"SDL_AUTO_UPDATE_JOYSTICKS\0";
pub const SDL_HINT_AUTO_UPDATE_SENSORS: &[u8; 24usize] = b"SDL_AUTO_UPDATE_SENSORS\0";
pub const SDL_HINT_BMP_SAVE_LEGACY_FORMAT: &[u8; 27usize] = b"SDL_BMP_SAVE_LEGACY_FORMAT\0";
pub const SDL_HINT_DISPLAY_USABLE_BOUNDS: &[u8; 26usize] = b"SDL_DISPLAY_USABLE_BOUNDS\0";
pub const SDL_HINT_EMSCRIPTEN_ASYNCIFY: &[u8; 24usize] = b"SDL_EMSCRIPTEN_ASYNCIFY\0";
pub const SDL_HINT_EMSCRIPTEN_CANVAS_SELECTOR: &[u8; 31usize] = b"SDL_EMSCRIPTEN_CANVAS_SELECTOR\0";
pub const SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT: &[u8; 32usize] =
    b"SDL_EMSCRIPTEN_KEYBOARD_ELEMENT\0";
pub const SDL_HINT_ENABLE_SCREEN_KEYBOARD: &[u8; 27usize] = b"SDL_ENABLE_SCREEN_KEYBOARD\0";
pub const SDL_HINT_EVENT_LOGGING: &[u8; 18usize] = b"SDL_EVENT_LOGGING\0";
pub const SDL_HINT_FORCE_RAISEWINDOW: &[u8; 27usize] = b"SDL_HINT_FORCE_RAISEWINDOW\0";
pub const SDL_HINT_WINDOW_ACTIVATE_WHEN_RAISED: &[u8; 32usize] =
    b"SDL_WINDOW_ACTIVATE_WHEN_RAISED\0";
pub const SDL_HINT_FRAMEBUFFER_ACCELERATION: &[u8; 29usize] = b"SDL_FRAMEBUFFER_ACCELERATION\0";
pub const SDL_HINT_GAMECONTROLLERCONFIG: &[u8; 25usize] = b"SDL_GAMECONTROLLERCONFIG\0";
pub const SDL_HINT_GAMECONTROLLERCONFIG_FILE: &[u8; 30usize] = b"SDL_GAMECONTROLLERCONFIG_FILE\0";
pub const SDL_HINT_GAMECONTROLLERTYPE: &[u8; 23usize] = b"SDL_GAMECONTROLLERTYPE\0";
pub const SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES: &[u8; 34usize] =
    b"SDL_GAMECONTROLLER_IGNORE_DEVICES\0";
pub const SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT: &[u8; 41usize] =
    b"SDL_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT\0";
pub const SDL_HINT_GAMECONTROLLER_USE_BUTTON_LABELS: &[u8; 37usize] =
    b"SDL_GAMECONTROLLER_USE_BUTTON_LABELS\0";
pub const SDL_HINT_GAMECONTROLLER_SENSOR_FUSION: &[u8; 33usize] =
    b"SDL_GAMECONTROLLER_SENSOR_FUSION\0";
pub const SDL_HINT_GRAB_KEYBOARD: &[u8; 18usize] = b"SDL_GRAB_KEYBOARD\0";
pub const SDL_HINT_HIDAPI_ENUMERATE_ONLY_CONTROLLERS: &[u8; 38usize] =
    b"SDL_HIDAPI_ENUMERATE_ONLY_CONTROLLERS\0";
pub const SDL_HINT_HIDAPI_IGNORE_DEVICES: &[u8; 26usize] = b"SDL_HIDAPI_IGNORE_DEVICES\0";
pub const SDL_HINT_IME_INTERNAL_EDITING: &[u8; 25usize] = b"SDL_IME_INTERNAL_EDITING\0";
pub const SDL_HINT_IME_SHOW_UI: &[u8; 16usize] = b"SDL_IME_SHOW_UI\0";
pub const SDL_HINT_IME_SUPPORT_EXTENDED_TEXT: &[u8; 30usize] = b"SDL_IME_SUPPORT_EXTENDED_TEXT\0";
pub const SDL_HINT_IOS_HIDE_HOME_INDICATOR: &[u8; 28usize] = b"SDL_IOS_HIDE_HOME_INDICATOR\0";
pub const SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS: &[u8; 37usize] =
    b"SDL_JOYSTICK_ALLOW_BACKGROUND_EVENTS\0";
pub const SDL_HINT_JOYSTICK_HIDAPI: &[u8; 20usize] = b"SDL_JOYSTICK_HIDAPI\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_GAMECUBE: &[u8; 29usize] = b"SDL_JOYSTICK_HIDAPI_GAMECUBE\0";
pub const SDL_HINT_JOYSTICK_GAMECUBE_RUMBLE_BRAKE: &[u8; 35usize] =
    b"SDL_JOYSTICK_GAMECUBE_RUMBLE_BRAKE\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_JOY_CONS: &[u8; 29usize] = b"SDL_JOYSTICK_HIDAPI_JOY_CONS\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_COMBINE_JOY_CONS: &[u8; 37usize] =
    b"SDL_JOYSTICK_HIDAPI_COMBINE_JOY_CONS\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_VERTICAL_JOY_CONS: &[u8; 38usize] =
    b"SDL_JOYSTICK_HIDAPI_VERTICAL_JOY_CONS\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_LUNA: &[u8; 25usize] = b"SDL_JOYSTICK_HIDAPI_LUNA\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_NINTENDO_CLASSIC: &[u8; 37usize] =
    b"SDL_JOYSTICK_HIDAPI_NINTENDO_CLASSIC\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_SHIELD: &[u8; 27usize] = b"SDL_JOYSTICK_HIDAPI_SHIELD\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS3: &[u8; 24usize] = b"SDL_JOYSTICK_HIDAPI_PS3\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS4: &[u8; 24usize] = b"SDL_JOYSTICK_HIDAPI_PS4\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS4_RUMBLE: &[u8; 31usize] = b"SDL_JOYSTICK_HIDAPI_PS4_RUMBLE\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS5: &[u8; 24usize] = b"SDL_JOYSTICK_HIDAPI_PS5\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS5_PLAYER_LED: &[u8; 35usize] =
    b"SDL_JOYSTICK_HIDAPI_PS5_PLAYER_LED\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS5_RUMBLE: &[u8; 31usize] = b"SDL_JOYSTICK_HIDAPI_PS5_RUMBLE\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_STADIA: &[u8; 27usize] = b"SDL_JOYSTICK_HIDAPI_STADIA\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_STEAM: &[u8; 26usize] = b"SDL_JOYSTICK_HIDAPI_STEAM\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_SWITCH: &[u8; 27usize] = b"SDL_JOYSTICK_HIDAPI_SWITCH\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_SWITCH_HOME_LED: &[u8; 36usize] =
    b"SDL_JOYSTICK_HIDAPI_SWITCH_HOME_LED\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_JOYCON_HOME_LED: &[u8; 36usize] =
    b"SDL_JOYSTICK_HIDAPI_JOYCON_HOME_LED\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_SWITCH_PLAYER_LED: &[u8; 38usize] =
    b"SDL_JOYSTICK_HIDAPI_SWITCH_PLAYER_LED\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_WII: &[u8; 24usize] = b"SDL_JOYSTICK_HIDAPI_WII\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_WII_PLAYER_LED: &[u8; 35usize] =
    b"SDL_JOYSTICK_HIDAPI_WII_PLAYER_LED\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_XBOX: &[u8; 25usize] = b"SDL_JOYSTICK_HIDAPI_XBOX\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_XBOX_360: &[u8; 29usize] = b"SDL_JOYSTICK_HIDAPI_XBOX_360\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_XBOX_360_PLAYER_LED: &[u8; 40usize] =
    b"SDL_JOYSTICK_HIDAPI_XBOX_360_PLAYER_LED\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_XBOX_360_WIRELESS: &[u8; 38usize] =
    b"SDL_JOYSTICK_HIDAPI_XBOX_360_WIRELESS\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_XBOX_ONE: &[u8; 29usize] = b"SDL_JOYSTICK_HIDAPI_XBOX_ONE\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_XBOX_ONE_HOME_LED: &[u8; 38usize] =
    b"SDL_JOYSTICK_HIDAPI_XBOX_ONE_HOME_LED\0";
pub const SDL_HINT_JOYSTICK_RAWINPUT: &[u8; 22usize] = b"SDL_JOYSTICK_RAWINPUT\0";
pub const SDL_HINT_JOYSTICK_RAWINPUT_CORRELATE_XINPUT: &[u8; 39usize] =
    b"SDL_JOYSTICK_RAWINPUT_CORRELATE_XINPUT\0";
pub const SDL_HINT_JOYSTICK_ROG_CHAKRAM: &[u8; 25usize] = b"SDL_JOYSTICK_ROG_CHAKRAM\0";
pub const SDL_HINT_JOYSTICK_THREAD: &[u8; 20usize] = b"SDL_JOYSTICK_THREAD\0";
pub const SDL_HINT_JOYSTICK_WGI: &[u8; 17usize] = b"SDL_JOYSTICK_WGI\0";
pub const SDL_HINT_KMSDRM_REQUIRE_DRM_MASTER: &[u8; 30usize] = b"SDL_KMSDRM_REQUIRE_DRM_MASTER\0";
pub const SDL_HINT_JOYSTICK_DEVICE: &[u8; 20usize] = b"SDL_JOYSTICK_DEVICE\0";
pub const SDL_HINT_LINUX_DIGITAL_HATS: &[u8; 23usize] = b"SDL_LINUX_DIGITAL_HATS\0";
pub const SDL_HINT_LINUX_HAT_DEADZONES: &[u8; 24usize] = b"SDL_LINUX_HAT_DEADZONES\0";
pub const SDL_HINT_LINUX_JOYSTICK_CLASSIC: &[u8; 27usize] = b"SDL_LINUX_JOYSTICK_CLASSIC\0";
pub const SDL_HINT_LINUX_JOYSTICK_DEADZONES: &[u8; 29usize] = b"SDL_LINUX_JOYSTICK_DEADZONES\0";
pub const SDL_HINT_MAC_BACKGROUND_APP: &[u8; 23usize] = b"SDL_MAC_BACKGROUND_APP\0";
pub const SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK: &[u8; 39usize] =
    b"SDL_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK\0";
pub const SDL_HINT_MAC_OPENGL_ASYNC_DISPATCH: &[u8; 30usize] = b"SDL_MAC_OPENGL_ASYNC_DISPATCH\0";
pub const SDL_HINT_MOUSE_DOUBLE_CLICK_RADIUS: &[u8; 30usize] = b"SDL_MOUSE_DOUBLE_CLICK_RADIUS\0";
pub const SDL_HINT_MOUSE_DOUBLE_CLICK_TIME: &[u8; 28usize] = b"SDL_MOUSE_DOUBLE_CLICK_TIME\0";
pub const SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH: &[u8; 29usize] = b"SDL_MOUSE_FOCUS_CLICKTHROUGH\0";
pub const SDL_HINT_MOUSE_NORMAL_SPEED_SCALE: &[u8; 29usize] = b"SDL_MOUSE_NORMAL_SPEED_SCALE\0";
pub const SDL_HINT_MOUSE_RELATIVE_MODE_CENTER: &[u8; 31usize] = b"SDL_MOUSE_RELATIVE_MODE_CENTER\0";
pub const SDL_HINT_MOUSE_RELATIVE_MODE_WARP: &[u8; 29usize] = b"SDL_MOUSE_RELATIVE_MODE_WARP\0";
pub const SDL_HINT_MOUSE_RELATIVE_SPEED_SCALE: &[u8; 31usize] = b"SDL_MOUSE_RELATIVE_SPEED_SCALE\0";
pub const SDL_HINT_MOUSE_RELATIVE_SYSTEM_SCALE: &[u8; 32usize] =
    b"SDL_MOUSE_RELATIVE_SYSTEM_SCALE\0";
pub const SDL_HINT_MOUSE_RELATIVE_WARP_MOTION: &[u8; 31usize] = b"SDL_MOUSE_RELATIVE_WARP_MOTION\0";
pub const SDL_HINT_MOUSE_TOUCH_EVENTS: &[u8; 23usize] = b"SDL_MOUSE_TOUCH_EVENTS\0";
pub const SDL_HINT_MOUSE_AUTO_CAPTURE: &[u8; 23usize] = b"SDL_MOUSE_AUTO_CAPTURE\0";
pub const SDL_HINT_PEN_NOT_MOUSE: &[u8; 23usize] = b"SDL_HINT_PEN_NOT_MOUSE\0";
pub const SDL_HINT_PEN_DELAY_MOUSE_BUTTON: &[u8; 32usize] = b"SDL_HINT_PEN_DELAY_MOUSE_BUTTON\0";
pub const SDL_HINT_NO_SIGNAL_HANDLERS: &[u8; 23usize] = b"SDL_NO_SIGNAL_HANDLERS\0";
pub const SDL_HINT_OPENGL_ES_DRIVER: &[u8; 21usize] = b"SDL_OPENGL_ES_DRIVER\0";
pub const SDL_HINT_ORIENTATIONS: &[u8; 21usize] = b"SDL_IOS_ORIENTATIONS\0";
pub const SDL_HINT_POLL_SENTINEL: &[u8; 18usize] = b"SDL_POLL_SENTINEL\0";
pub const SDL_HINT_PREFERRED_LOCALES: &[u8; 22usize] = b"SDL_PREFERRED_LOCALES\0";
pub const SDL_HINT_QTWAYLAND_CONTENT_ORIENTATION: &[u8; 34usize] =
    b"SDL_QTWAYLAND_CONTENT_ORIENTATION\0";
pub const SDL_HINT_QTWAYLAND_WINDOW_FLAGS: &[u8; 27usize] = b"SDL_QTWAYLAND_WINDOW_FLAGS\0";
pub const SDL_HINT_RENDER_BATCHING: &[u8; 20usize] = b"SDL_RENDER_BATCHING\0";
pub const SDL_HINT_RENDER_LINE_METHOD: &[u8; 23usize] = b"SDL_RENDER_LINE_METHOD\0";
pub const SDL_HINT_RENDER_DIRECT3D11_DEBUG: &[u8; 28usize] = b"SDL_RENDER_DIRECT3D11_DEBUG\0";
pub const SDL_HINT_RENDER_DIRECT3D_THREADSAFE: &[u8; 31usize] = b"SDL_RENDER_DIRECT3D_THREADSAFE\0";
pub const SDL_HINT_RENDER_DRIVER: &[u8; 18usize] = b"SDL_RENDER_DRIVER\0";
pub const SDL_HINT_RENDER_OPENGL_SHADERS: &[u8; 26usize] = b"SDL_RENDER_OPENGL_SHADERS\0";
pub const SDL_HINT_RENDER_SCALE_QUALITY: &[u8; 25usize] = b"SDL_RENDER_SCALE_QUALITY\0";
pub const SDL_HINT_RENDER_VSYNC: &[u8; 17usize] = b"SDL_RENDER_VSYNC\0";
pub const SDL_HINT_PS2_DYNAMIC_VSYNC: &[u8; 22usize] = b"SDL_PS2_DYNAMIC_VSYNC\0";
pub const SDL_HINT_RETURN_KEY_HIDES_IME: &[u8; 25usize] = b"SDL_RETURN_KEY_HIDES_IME\0";
pub const SDL_HINT_RPI_VIDEO_LAYER: &[u8; 20usize] = b"SDL_RPI_VIDEO_LAYER\0";
pub const SDL_HINT_SCREENSAVER_INHIBIT_ACTIVITY_NAME: &[u8; 38usize] =
    b"SDL_SCREENSAVER_INHIBIT_ACTIVITY_NAME\0";
pub const SDL_HINT_THREAD_FORCE_REALTIME_TIME_CRITICAL: &[u8; 40usize] =
    b"SDL_THREAD_FORCE_REALTIME_TIME_CRITICAL\0";
pub const SDL_HINT_THREAD_PRIORITY_POLICY: &[u8; 27usize] = b"SDL_THREAD_PRIORITY_POLICY\0";
pub const SDL_HINT_THREAD_STACK_SIZE: &[u8; 22usize] = b"SDL_THREAD_STACK_SIZE\0";
pub const SDL_HINT_TIMER_RESOLUTION: &[u8; 21usize] = b"SDL_TIMER_RESOLUTION\0";
pub const SDL_HINT_TOUCH_MOUSE_EVENTS: &[u8; 23usize] = b"SDL_TOUCH_MOUSE_EVENTS\0";
pub const SDL_HINT_VITA_TOUCH_MOUSE_DEVICE: &[u8; 33usize] = b"SDL_HINT_VITA_TOUCH_MOUSE_DEVICE\0";
pub const SDL_HINT_TV_REMOTE_AS_JOYSTICK: &[u8; 26usize] = b"SDL_TV_REMOTE_AS_JOYSTICK\0";
pub const SDL_HINT_VIDEO_ALLOW_SCREENSAVER: &[u8; 28usize] = b"SDL_VIDEO_ALLOW_SCREENSAVER\0";
pub const SDL_HINT_VIDEO_DOUBLE_BUFFER: &[u8; 24usize] = b"SDL_VIDEO_DOUBLE_BUFFER\0";
pub const SDL_HINT_VIDEO_EGL_ALLOW_GETDISPLAY_FALLBACK: &[u8; 34usize] =
    b"SDL_VIDEO_EGL_GETDISPLAY_FALLBACK\0";
pub const SDL_HINT_VIDEO_EXTERNAL_CONTEXT: &[u8; 27usize] = b"SDL_VIDEO_EXTERNAL_CONTEXT\0";
pub const SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES: &[u8; 32usize] =
    b"SDL_VIDEO_MAC_FULLSCREEN_SPACES\0";
pub const SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS: &[u8; 33usize] =
    b"SDL_VIDEO_MINIMIZE_ON_FOCUS_LOSS\0";
pub const SDL_HINT_VIDEO_WAYLAND_ALLOW_LIBDECOR: &[u8; 33usize] =
    b"SDL_VIDEO_WAYLAND_ALLOW_LIBDECOR\0";
pub const SDL_HINT_VIDEO_WAYLAND_PREFER_LIBDECOR: &[u8; 34usize] =
    b"SDL_VIDEO_WAYLAND_PREFER_LIBDECOR\0";
pub const SDL_HINT_VIDEO_WAYLAND_MODE_EMULATION: &[u8; 33usize] =
    b"SDL_VIDEO_WAYLAND_MODE_EMULATION\0";
pub const SDL_HINT_VIDEO_WAYLAND_MODE_SCALING: &[u8; 31usize] = b"SDL_VIDEO_WAYLAND_MODE_SCALING\0";
pub const SDL_HINT_VIDEO_WAYLAND_EMULATE_MOUSE_WARP: &[u8; 37usize] =
    b"SDL_VIDEO_WAYLAND_EMULATE_MOUSE_WARP\0";
pub const SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT: &[u8; 36usize] =
    b"SDL_VIDEO_WINDOW_SHARE_PIXEL_FORMAT\0";
pub const SDL_HINT_VIDEO_FOREIGN_WINDOW_OPENGL: &[u8; 32usize] =
    b"SDL_VIDEO_FOREIGN_WINDOW_OPENGL\0";
pub const SDL_HINT_VIDEO_FOREIGN_WINDOW_VULKAN: &[u8; 32usize] =
    b"SDL_VIDEO_FOREIGN_WINDOW_VULKAN\0";
pub const SDL_HINT_VIDEO_WIN_D3DCOMPILER: &[u8; 26usize] = b"SDL_VIDEO_WIN_D3DCOMPILER\0";
pub const SDL_HINT_VIDEO_FORCE_EGL: &[u8; 20usize] = b"SDL_VIDEO_FORCE_EGL\0";
pub const SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR: &[u8; 39usize] =
    b"SDL_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR\0";
pub const SDL_HINT_VIDEO_X11_NET_WM_PING: &[u8; 26usize] = b"SDL_VIDEO_X11_NET_WM_PING\0";
pub const SDL_HINT_VIDEO_X11_WINDOW_VISUALID: &[u8; 30usize] = b"SDL_VIDEO_X11_WINDOW_VISUALID\0";
pub const SDL_HINT_VIDEO_X11_SCALING_FACTOR: &[u8; 29usize] = b"SDL_VIDEO_X11_SCALING_FACTOR\0";
pub const SDL_HINT_VIDEO_X11_XRANDR: &[u8; 21usize] = b"SDL_VIDEO_X11_XRANDR\0";
pub const SDL_HINT_WAVE_FACT_CHUNK: &[u8; 20usize] = b"SDL_WAVE_FACT_CHUNK\0";
pub const SDL_HINT_WAVE_RIFF_CHUNK_SIZE: &[u8; 25usize] = b"SDL_WAVE_RIFF_CHUNK_SIZE\0";
pub const SDL_HINT_WAVE_TRUNCATION: &[u8; 20usize] = b"SDL_WAVE_TRUNCATION\0";
pub const SDL_HINT_WINDOWS_DISABLE_THREAD_NAMING: &[u8; 34usize] =
    b"SDL_WINDOWS_DISABLE_THREAD_NAMING\0";
pub const SDL_HINT_WINDOWS_ENABLE_MENU_MNEMONICS: &[u8; 34usize] =
    b"SDL_WINDOWS_ENABLE_MENU_MNEMONICS\0";
pub const SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP: &[u8; 31usize] = b"SDL_WINDOWS_ENABLE_MESSAGELOOP\0";
pub const SDL_HINT_WINDOWS_FORCE_MUTEX_CRITICAL_SECTIONS: &[u8; 42usize] =
    b"SDL_WINDOWS_FORCE_MUTEX_CRITICAL_SECTIONS\0";
pub const SDL_HINT_WINDOWS_FORCE_SEMAPHORE_KERNEL: &[u8; 35usize] =
    b"SDL_WINDOWS_FORCE_SEMAPHORE_KERNEL\0";
pub const SDL_HINT_WINDOWS_INTRESOURCE_ICON: &[u8; 29usize] = b"SDL_WINDOWS_INTRESOURCE_ICON\0";
pub const SDL_HINT_WINDOWS_INTRESOURCE_ICON_SMALL: &[u8; 35usize] =
    b"SDL_WINDOWS_INTRESOURCE_ICON_SMALL\0";
pub const SDL_HINT_WINDOWS_NO_CLOSE_ON_ALT_F4: &[u8; 31usize] = b"SDL_WINDOWS_NO_CLOSE_ON_ALT_F4\0";
pub const SDL_HINT_WINDOWS_USE_D3D9EX: &[u8; 23usize] = b"SDL_WINDOWS_USE_D3D9EX\0";
pub const SDL_HINT_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN: &[u8; 44usize] =
    b"SDL_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN\0";
pub const SDL_HINT_WINDOW_ACTIVATE_WHEN_SHOWN: &[u8; 31usize] = b"SDL_WINDOW_ACTIVATE_WHEN_SHOWN\0";
pub const SDL_HINT_WINRT_HANDLE_BACK_BUTTON: &[u8; 29usize] = b"SDL_WINRT_HANDLE_BACK_BUTTON\0";
pub const SDL_HINT_WINRT_PRIVACY_POLICY_LABEL: &[u8; 31usize] = b"SDL_WINRT_PRIVACY_POLICY_LABEL\0";
pub const SDL_HINT_WINRT_PRIVACY_POLICY_URL: &[u8; 29usize] = b"SDL_WINRT_PRIVACY_POLICY_URL\0";
pub const SDL_HINT_X11_FORCE_OVERRIDE_REDIRECT: &[u8; 32usize] =
    b"SDL_X11_FORCE_OVERRIDE_REDIRECT\0";
pub const SDL_HINT_XINPUT_ENABLED: &[u8; 19usize] = b"SDL_XINPUT_ENABLED\0";
pub const SDL_HINT_DIRECTINPUT_ENABLED: &[u8; 24usize] = b"SDL_DIRECTINPUT_ENABLED\0";
pub const SDL_HINT_XINPUT_USE_OLD_JOYSTICK_MAPPING: &[u8; 36usize] =
    b"SDL_XINPUT_USE_OLD_JOYSTICK_MAPPING\0";
pub const SDL_HINT_AUDIO_INCLUDE_MONITORS: &[u8; 27usize] = b"SDL_AUDIO_INCLUDE_MONITORS\0";
pub const SDL_HINT_X11_WINDOW_TYPE: &[u8; 20usize] = b"SDL_X11_WINDOW_TYPE\0";
pub const SDL_HINT_QUIT_ON_LAST_WINDOW_CLOSE: &[u8; 30usize] = b"SDL_QUIT_ON_LAST_WINDOW_CLOSE\0";
pub const SDL_HINT_VIDEO_DRIVER: &[u8; 17usize] = b"SDL_VIDEO_DRIVER\0";
pub const SDL_HINT_AUDIO_DRIVER: &[u8; 17usize] = b"SDL_AUDIO_DRIVER\0";
pub const SDL_HINT_KMSDRM_DEVICE_INDEX: &[u8; 24usize] = b"SDL_KMSDRM_DEVICE_INDEX\0";
pub const SDL_HINT_TRACKPAD_IS_TOUCH_ONLY: &[u8; 27usize] = b"SDL_TRACKPAD_IS_TOUCH_ONLY\0";
pub const SDL_HINT_GDK_TEXTINPUT_TITLE: &[u8; 24usize] = b"SDL_GDK_TEXTINPUT_TITLE\0";
pub const SDL_HINT_GDK_TEXTINPUT_DESCRIPTION: &[u8; 30usize] = b"SDL_GDK_TEXTINPUT_DESCRIPTION\0";
pub const SDL_HINT_GDK_TEXTINPUT_DEFAULT: &[u8; 26usize] = b"SDL_GDK_TEXTINPUT_DEFAULT\0";
pub const SDL_HINT_GDK_TEXTINPUT_SCOPE: &[u8; 24usize] = b"SDL_GDK_TEXTINPUT_SCOPE\0";
pub const SDL_HINT_GDK_TEXTINPUT_MAX_LENGTH: &[u8; 29usize] = b"SDL_GDK_TEXTINPUT_MAX_LENGTH\0";
pub const SDL_MAX_LOG_MESSAGE: u32 = 4096;
pub const SDL_NONSHAPEABLE_WINDOW: i32 = -1;
pub const SDL_INVALID_SHAPE_ARGUMENT: i32 = -2;
pub const SDL_WINDOW_LACKS_SHAPE: i32 = -3;
pub const SDL_MS_PER_SECOND: u32 = 1000;
pub const SDL_US_PER_SECOND: u32 = 1000000;
pub const SDL_NS_PER_SECOND: u32 = 1000000000;
pub const SDL_NS_PER_MS: u32 = 1000000;
pub const SDL_NS_PER_US: u32 = 1000;
pub const SDL_MAJOR_VERSION: u32 = 3;
pub const SDL_MINOR_VERSION: u32 = 0;
pub const SDL_PATCHLEVEL: u32 = 0;
pub const XlibSpecificationRelease: u32 = 6;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const X_PROTOCOL: u32 = 11;
pub const X_PROTOCOL_REVISION: u32 = 0;
pub const None: u32 = 0;
pub const ParentRelative: u32 = 1;
pub const CopyFromParent: u32 = 0;
pub const PointerWindow: u32 = 0;
pub const InputFocus: u32 = 1;
pub const PointerRoot: u32 = 1;
pub const AnyPropertyType: u32 = 0;
pub const AnyKey: u32 = 0;
pub const AnyButton: u32 = 0;
pub const AllTemporary: u32 = 0;
pub const CurrentTime: u32 = 0;
pub const NoSymbol: u32 = 0;
pub const NoEventMask: u32 = 0;
pub const KeyPressMask: u32 = 1;
pub const KeyReleaseMask: u32 = 2;
pub const ButtonPressMask: u32 = 4;
pub const ButtonReleaseMask: u32 = 8;
pub const EnterWindowMask: u32 = 16;
pub const LeaveWindowMask: u32 = 32;
pub const PointerMotionMask: u32 = 64;
pub const PointerMotionHintMask: u32 = 128;
pub const Button1MotionMask: u32 = 256;
pub const Button2MotionMask: u32 = 512;
pub const Button3MotionMask: u32 = 1024;
pub const Button4MotionMask: u32 = 2048;
pub const Button5MotionMask: u32 = 4096;
pub const ButtonMotionMask: u32 = 8192;
pub const KeymapStateMask: u32 = 16384;
pub const ExposureMask: u32 = 32768;
pub const VisibilityChangeMask: u32 = 65536;
pub const StructureNotifyMask: u32 = 131072;
pub const ResizeRedirectMask: u32 = 262144;
pub const SubstructureNotifyMask: u32 = 524288;
pub const SubstructureRedirectMask: u32 = 1048576;
pub const FocusChangeMask: u32 = 2097152;
pub const PropertyChangeMask: u32 = 4194304;
pub const ColormapChangeMask: u32 = 8388608;
pub const OwnerGrabButtonMask: u32 = 16777216;
pub const KeyPress: u32 = 2;
pub const KeyRelease: u32 = 3;
pub const ButtonPress: u32 = 4;
pub const ButtonRelease: u32 = 5;
pub const MotionNotify: u32 = 6;
pub const EnterNotify: u32 = 7;
pub const LeaveNotify: u32 = 8;
pub const FocusIn: u32 = 9;
pub const FocusOut: u32 = 10;
pub const KeymapNotify: u32 = 11;
pub const Expose: u32 = 12;
pub const GraphicsExpose: u32 = 13;
pub const NoExpose: u32 = 14;
pub const VisibilityNotify: u32 = 15;
pub const CreateNotify: u32 = 16;
pub const DestroyNotify: u32 = 17;
pub const UnmapNotify: u32 = 18;
pub const MapNotify: u32 = 19;
pub const MapRequest: u32 = 20;
pub const ReparentNotify: u32 = 21;
pub const ConfigureNotify: u32 = 22;
pub const ConfigureRequest: u32 = 23;
pub const GravityNotify: u32 = 24;
pub const ResizeRequest: u32 = 25;
pub const CirculateNotify: u32 = 26;
pub const CirculateRequest: u32 = 27;
pub const PropertyNotify: u32 = 28;
pub const SelectionClear: u32 = 29;
pub const SelectionRequest: u32 = 30;
pub const SelectionNotify: u32 = 31;
pub const ColormapNotify: u32 = 32;
pub const ClientMessage: u32 = 33;
pub const MappingNotify: u32 = 34;
pub const GenericEvent: u32 = 35;
pub const LASTEvent: u32 = 36;
pub const ShiftMask: u32 = 1;
pub const LockMask: u32 = 2;
pub const ControlMask: u32 = 4;
pub const Mod1Mask: u32 = 8;
pub const Mod2Mask: u32 = 16;
pub const Mod3Mask: u32 = 32;
pub const Mod4Mask: u32 = 64;
pub const Mod5Mask: u32 = 128;
pub const ShiftMapIndex: u32 = 0;
pub const LockMapIndex: u32 = 1;
pub const ControlMapIndex: u32 = 2;
pub const Mod1MapIndex: u32 = 3;
pub const Mod2MapIndex: u32 = 4;
pub const Mod3MapIndex: u32 = 5;
pub const Mod4MapIndex: u32 = 6;
pub const Mod5MapIndex: u32 = 7;
pub const Button1Mask: u32 = 256;
pub const Button2Mask: u32 = 512;
pub const Button3Mask: u32 = 1024;
pub const Button4Mask: u32 = 2048;
pub const Button5Mask: u32 = 4096;
pub const AnyModifier: u32 = 32768;
pub const Button1: u32 = 1;
pub const Button2: u32 = 2;
pub const Button3: u32 = 3;
pub const Button4: u32 = 4;
pub const Button5: u32 = 5;
pub const NotifyNormal: u32 = 0;
pub const NotifyGrab: u32 = 1;
pub const NotifyUngrab: u32 = 2;
pub const NotifyWhileGrabbed: u32 = 3;
pub const NotifyHint: u32 = 1;
pub const NotifyAncestor: u32 = 0;
pub const NotifyVirtual: u32 = 1;
pub const NotifyInferior: u32 = 2;
pub const NotifyNonlinear: u32 = 3;
pub const NotifyNonlinearVirtual: u32 = 4;
pub const NotifyPointer: u32 = 5;
pub const NotifyPointerRoot: u32 = 6;
pub const NotifyDetailNone: u32 = 7;
pub const VisibilityUnobscured: u32 = 0;
pub const VisibilityPartiallyObscured: u32 = 1;
pub const VisibilityFullyObscured: u32 = 2;
pub const PlaceOnTop: u32 = 0;
pub const PlaceOnBottom: u32 = 1;
pub const FamilyInternet: u32 = 0;
pub const FamilyDECnet: u32 = 1;
pub const FamilyChaos: u32 = 2;
pub const FamilyInternet6: u32 = 6;
pub const FamilyServerInterpreted: u32 = 5;
pub const PropertyNewValue: u32 = 0;
pub const PropertyDelete: u32 = 1;
pub const ColormapUninstalled: u32 = 0;
pub const ColormapInstalled: u32 = 1;
pub const GrabModeSync: u32 = 0;
pub const GrabModeAsync: u32 = 1;
pub const GrabSuccess: u32 = 0;
pub const AlreadyGrabbed: u32 = 1;
pub const GrabInvalidTime: u32 = 2;
pub const GrabNotViewable: u32 = 3;
pub const GrabFrozen: u32 = 4;
pub const AsyncPointer: u32 = 0;
pub const SyncPointer: u32 = 1;
pub const ReplayPointer: u32 = 2;
pub const AsyncKeyboard: u32 = 3;
pub const SyncKeyboard: u32 = 4;
pub const ReplayKeyboard: u32 = 5;
pub const AsyncBoth: u32 = 6;
pub const SyncBoth: u32 = 7;
pub const RevertToParent: u32 = 2;
pub const Success: u32 = 0;
pub const BadRequest: u32 = 1;
pub const BadValue: u32 = 2;
pub const BadWindow: u32 = 3;
pub const BadPixmap: u32 = 4;
pub const BadAtom: u32 = 5;
pub const BadCursor: u32 = 6;
pub const BadFont: u32 = 7;
pub const BadMatch: u32 = 8;
pub const BadDrawable: u32 = 9;
pub const BadAccess: u32 = 10;
pub const BadAlloc: u32 = 11;
pub const BadColor: u32 = 12;
pub const BadGC: u32 = 13;
pub const BadIDChoice: u32 = 14;
pub const BadName: u32 = 15;
pub const BadLength: u32 = 16;
pub const BadImplementation: u32 = 17;
pub const FirstExtensionError: u32 = 128;
pub const LastExtensionError: u32 = 255;
pub const InputOutput: u32 = 1;
pub const InputOnly: u32 = 2;
pub const CWBackPixmap: u32 = 1;
pub const CWBackPixel: u32 = 2;
pub const CWBorderPixmap: u32 = 4;
pub const CWBorderPixel: u32 = 8;
pub const CWBitGravity: u32 = 16;
pub const CWWinGravity: u32 = 32;
pub const CWBackingStore: u32 = 64;
pub const CWBackingPlanes: u32 = 128;
pub const CWBackingPixel: u32 = 256;
pub const CWOverrideRedirect: u32 = 512;
pub const CWSaveUnder: u32 = 1024;
pub const CWEventMask: u32 = 2048;
pub const CWDontPropagate: u32 = 4096;
pub const CWColormap: u32 = 8192;
pub const CWCursor: u32 = 16384;
pub const CWX: u32 = 1;
pub const CWY: u32 = 2;
pub const CWWidth: u32 = 4;
pub const CWHeight: u32 = 8;
pub const CWBorderWidth: u32 = 16;
pub const CWSibling: u32 = 32;
pub const CWStackMode: u32 = 64;
pub const ForgetGravity: u32 = 0;
pub const NorthWestGravity: u32 = 1;
pub const NorthGravity: u32 = 2;
pub const NorthEastGravity: u32 = 3;
pub const WestGravity: u32 = 4;
pub const CenterGravity: u32 = 5;
pub const EastGravity: u32 = 6;
pub const SouthWestGravity: u32 = 7;
pub const SouthGravity: u32 = 8;
pub const SouthEastGravity: u32 = 9;
pub const StaticGravity: u32 = 10;
pub const UnmapGravity: u32 = 0;
pub const NotUseful: u32 = 0;
pub const WhenMapped: u32 = 1;
pub const Always: u32 = 2;
pub const IsUnmapped: u32 = 0;
pub const IsUnviewable: u32 = 1;
pub const IsViewable: u32 = 2;
pub const SetModeInsert: u32 = 0;
pub const SetModeDelete: u32 = 1;
pub const DestroyAll: u32 = 0;
pub const RetainPermanent: u32 = 1;
pub const RetainTemporary: u32 = 2;
pub const Above: u32 = 0;
pub const Below: u32 = 1;
pub const TopIf: u32 = 2;
pub const BottomIf: u32 = 3;
pub const Opposite: u32 = 4;
pub const RaiseLowest: u32 = 0;
pub const LowerHighest: u32 = 1;
pub const PropModeReplace: u32 = 0;
pub const PropModePrepend: u32 = 1;
pub const PropModeAppend: u32 = 2;
pub const GXclear: u32 = 0;
pub const GXand: u32 = 1;
pub const GXandReverse: u32 = 2;
pub const GXcopy: u32 = 3;
pub const GXandInverted: u32 = 4;
pub const GXnoop: u32 = 5;
pub const GXxor: u32 = 6;
pub const GXor: u32 = 7;
pub const GXnor: u32 = 8;
pub const GXequiv: u32 = 9;
pub const GXinvert: u32 = 10;
pub const GXorReverse: u32 = 11;
pub const GXcopyInverted: u32 = 12;
pub const GXorInverted: u32 = 13;
pub const GXnand: u32 = 14;
pub const GXset: u32 = 15;
pub const LineSolid: u32 = 0;
pub const LineOnOffDash: u32 = 1;
pub const LineDoubleDash: u32 = 2;
pub const CapNotLast: u32 = 0;
pub const CapButt: u32 = 1;
pub const CapRound: u32 = 2;
pub const CapProjecting: u32 = 3;
pub const JoinMiter: u32 = 0;
pub const JoinRound: u32 = 1;
pub const JoinBevel: u32 = 2;
pub const FillSolid: u32 = 0;
pub const FillTiled: u32 = 1;
pub const FillStippled: u32 = 2;
pub const FillOpaqueStippled: u32 = 3;
pub const EvenOddRule: u32 = 0;
pub const WindingRule: u32 = 1;
pub const ClipByChildren: u32 = 0;
pub const IncludeInferiors: u32 = 1;
pub const Unsorted: u32 = 0;
pub const YSorted: u32 = 1;
pub const YXSorted: u32 = 2;
pub const YXBanded: u32 = 3;
pub const CoordModeOrigin: u32 = 0;
pub const CoordModePrevious: u32 = 1;
pub const Complex: u32 = 0;
pub const Nonconvex: u32 = 1;
pub const Convex: u32 = 2;
pub const ArcChord: u32 = 0;
pub const ArcPieSlice: u32 = 1;
pub const GCFunction: u32 = 1;
pub const GCPlaneMask: u32 = 2;
pub const GCForeground: u32 = 4;
pub const GCBackground: u32 = 8;
pub const GCLineWidth: u32 = 16;
pub const GCLineStyle: u32 = 32;
pub const GCCapStyle: u32 = 64;
pub const GCJoinStyle: u32 = 128;
pub const GCFillStyle: u32 = 256;
pub const GCFillRule: u32 = 512;
pub const GCTile: u32 = 1024;
pub const GCStipple: u32 = 2048;
pub const GCTileStipXOrigin: u32 = 4096;
pub const GCTileStipYOrigin: u32 = 8192;
pub const GCFont: u32 = 16384;
pub const GCSubwindowMode: u32 = 32768;
pub const GCGraphicsExposures: u32 = 65536;
pub const GCClipXOrigin: u32 = 131072;
pub const GCClipYOrigin: u32 = 262144;
pub const GCClipMask: u32 = 524288;
pub const GCDashOffset: u32 = 1048576;
pub const GCDashList: u32 = 2097152;
pub const GCArcMode: u32 = 4194304;
pub const GCLastBit: u32 = 22;
pub const FontLeftToRight: u32 = 0;
pub const FontRightToLeft: u32 = 1;
pub const FontChange: u32 = 255;
pub const XYBitmap: u32 = 0;
pub const XYPixmap: u32 = 1;
pub const ZPixmap: u32 = 2;
pub const AllocNone: u32 = 0;
pub const AllocAll: u32 = 1;
pub const DoRed: u32 = 1;
pub const DoGreen: u32 = 2;
pub const DoBlue: u32 = 4;
pub const CursorShape: u32 = 0;
pub const TileShape: u32 = 1;
pub const StippleShape: u32 = 2;
pub const AutoRepeatModeOff: u32 = 0;
pub const AutoRepeatModeOn: u32 = 1;
pub const AutoRepeatModeDefault: u32 = 2;
pub const LedModeOff: u32 = 0;
pub const LedModeOn: u32 = 1;
pub const KBKeyClickPercent: u32 = 1;
pub const KBBellPercent: u32 = 2;
pub const KBBellPitch: u32 = 4;
pub const KBBellDuration: u32 = 8;
pub const KBLed: u32 = 16;
pub const KBLedMode: u32 = 32;
pub const KBKey: u32 = 64;
pub const KBAutoRepeatMode: u32 = 128;
pub const MappingSuccess: u32 = 0;
pub const MappingBusy: u32 = 1;
pub const MappingFailed: u32 = 2;
pub const MappingModifier: u32 = 0;
pub const MappingKeyboard: u32 = 1;
pub const MappingPointer: u32 = 2;
pub const DontPreferBlanking: u32 = 0;
pub const PreferBlanking: u32 = 1;
pub const DefaultBlanking: u32 = 2;
pub const DisableScreenSaver: u32 = 0;
pub const DisableScreenInterval: u32 = 0;
pub const DontAllowExposures: u32 = 0;
pub const AllowExposures: u32 = 1;
pub const DefaultExposures: u32 = 2;
pub const ScreenSaverReset: u32 = 0;
pub const ScreenSaverActive: u32 = 1;
pub const HostInsert: u32 = 0;
pub const HostDelete: u32 = 1;
pub const EnableAccess: u32 = 1;
pub const DisableAccess: u32 = 0;
pub const StaticGray: u32 = 0;
pub const GrayScale: u32 = 1;
pub const StaticColor: u32 = 2;
pub const PseudoColor: u32 = 3;
pub const TrueColor: u32 = 4;
pub const DirectColor: u32 = 5;
pub const LSBFirst: u32 = 0;
pub const MSBFirst: u32 = 1;
pub const NeedFunctionPrototypes: u32 = 1;
pub const NeedVarargsPrototypes: u32 = 1;
pub const NeedNestedPrototypes: u32 = 1;
pub const FUNCPROTO: u32 = 15;
pub const NeedWidePrototypes: u32 = 0;
pub const X_HAVE_UTF8_STRING: u32 = 1;
pub const True: u32 = 1;
pub const False: u32 = 0;
pub const QueuedAlready: u32 = 0;
pub const QueuedAfterReading: u32 = 1;
pub const QueuedAfterFlush: u32 = 2;
pub const XNRequiredCharSet: &[u8; 16usize] = b"requiredCharSet\0";
pub const XNQueryOrientation: &[u8; 17usize] = b"queryOrientation\0";
pub const XNBaseFontName: &[u8; 13usize] = b"baseFontName\0";
pub const XNOMAutomatic: &[u8; 12usize] = b"omAutomatic\0";
pub const XNMissingCharSet: &[u8; 15usize] = b"missingCharSet\0";
pub const XNDefaultString: &[u8; 14usize] = b"defaultString\0";
pub const XNOrientation: &[u8; 12usize] = b"orientation\0";
pub const XNDirectionalDependentDrawing: &[u8; 28usize] = b"directionalDependentDrawing\0";
pub const XNContextualDrawing: &[u8; 18usize] = b"contextualDrawing\0";
pub const XNFontInfo: &[u8; 9usize] = b"fontInfo\0";
pub const XIMPreeditArea: u32 = 1;
pub const XIMPreeditCallbacks: u32 = 2;
pub const XIMPreeditPosition: u32 = 4;
pub const XIMPreeditNothing: u32 = 8;
pub const XIMPreeditNone: u32 = 16;
pub const XIMStatusArea: u32 = 256;
pub const XIMStatusCallbacks: u32 = 512;
pub const XIMStatusNothing: u32 = 1024;
pub const XIMStatusNone: u32 = 2048;
pub const XNVaNestedList: &[u8; 15usize] = b"XNVaNestedList\0";
pub const XNQueryInputStyle: &[u8; 16usize] = b"queryInputStyle\0";
pub const XNClientWindow: &[u8; 13usize] = b"clientWindow\0";
pub const XNInputStyle: &[u8; 11usize] = b"inputStyle\0";
pub const XNFocusWindow: &[u8; 12usize] = b"focusWindow\0";
pub const XNResourceName: &[u8; 13usize] = b"resourceName\0";
pub const XNResourceClass: &[u8; 14usize] = b"resourceClass\0";
pub const XNGeometryCallback: &[u8; 17usize] = b"geometryCallback\0";
pub const XNDestroyCallback: &[u8; 16usize] = b"destroyCallback\0";
pub const XNFilterEvents: &[u8; 13usize] = b"filterEvents\0";
pub const XNPreeditStartCallback: &[u8; 21usize] = b"preeditStartCallback\0";
pub const XNPreeditDoneCallback: &[u8; 20usize] = b"preeditDoneCallback\0";
pub const XNPreeditDrawCallback: &[u8; 20usize] = b"preeditDrawCallback\0";
pub const XNPreeditCaretCallback: &[u8; 21usize] = b"preeditCaretCallback\0";
pub const XNPreeditStateNotifyCallback: &[u8; 27usize] = b"preeditStateNotifyCallback\0";
pub const XNPreeditAttributes: &[u8; 18usize] = b"preeditAttributes\0";
pub const XNStatusStartCallback: &[u8; 20usize] = b"statusStartCallback\0";
pub const XNStatusDoneCallback: &[u8; 19usize] = b"statusDoneCallback\0";
pub const XNStatusDrawCallback: &[u8; 19usize] = b"statusDrawCallback\0";
pub const XNStatusAttributes: &[u8; 17usize] = b"statusAttributes\0";
pub const XNArea: &[u8; 5usize] = b"area\0";
pub const XNAreaNeeded: &[u8; 11usize] = b"areaNeeded\0";
pub const XNSpotLocation: &[u8; 13usize] = b"spotLocation\0";
pub const XNColormap: &[u8; 9usize] = b"colorMap\0";
pub const XNStdColormap: &[u8; 12usize] = b"stdColorMap\0";
pub const XNForeground: &[u8; 11usize] = b"foreground\0";
pub const XNBackground: &[u8; 11usize] = b"background\0";
pub const XNBackgroundPixmap: &[u8; 17usize] = b"backgroundPixmap\0";
pub const XNFontSet: &[u8; 8usize] = b"fontSet\0";
pub const XNLineSpace: &[u8; 10usize] = b"lineSpace\0";
pub const XNCursor: &[u8; 7usize] = b"cursor\0";
pub const XNQueryIMValuesList: &[u8; 18usize] = b"queryIMValuesList\0";
pub const XNQueryICValuesList: &[u8; 18usize] = b"queryICValuesList\0";
pub const XNVisiblePosition: &[u8; 16usize] = b"visiblePosition\0";
pub const XNR6PreeditCallback: &[u8; 18usize] = b"r6PreeditCallback\0";
pub const XNStringConversionCallback: &[u8; 25usize] = b"stringConversionCallback\0";
pub const XNStringConversion: &[u8; 17usize] = b"stringConversion\0";
pub const XNResetState: &[u8; 11usize] = b"resetState\0";
pub const XNHotKey: &[u8; 7usize] = b"hotKey\0";
pub const XNHotKeyState: &[u8; 12usize] = b"hotKeyState\0";
pub const XNPreeditState: &[u8; 13usize] = b"preeditState\0";
pub const XNSeparatorofNestedList: &[u8; 22usize] = b"separatorofNestedList\0";
pub const XBufferOverflow: i32 = -1;
pub const XLookupNone: u32 = 1;
pub const XLookupChars: u32 = 2;
pub const XLookupKeySym: u32 = 3;
pub const XLookupBoth: u32 = 4;
pub const XIMReverse: u32 = 1;
pub const XIMUnderline: u32 = 2;
pub const XIMHighlight: u32 = 4;
pub const XIMPrimary: u32 = 32;
pub const XIMSecondary: u32 = 64;
pub const XIMTertiary: u32 = 128;
pub const XIMVisibleToForward: u32 = 256;
pub const XIMVisibleToBackword: u32 = 512;
pub const XIMVisibleToCenter: u32 = 1024;
pub const XIMPreeditUnKnown: u32 = 0;
pub const XIMPreeditEnable: u32 = 1;
pub const XIMPreeditDisable: u32 = 2;
pub const XIMInitialState: u32 = 1;
pub const XIMPreserveState: u32 = 2;
pub const XIMStringConversionLeftEdge: u32 = 1;
pub const XIMStringConversionRightEdge: u32 = 2;
pub const XIMStringConversionTopEdge: u32 = 4;
pub const XIMStringConversionBottomEdge: u32 = 8;
pub const XIMStringConversionConcealed: u32 = 16;
pub const XIMStringConversionWrapped: u32 = 32;
pub const XIMStringConversionBuffer: u32 = 1;
pub const XIMStringConversionLine: u32 = 2;
pub const XIMStringConversionWord: u32 = 3;
pub const XIMStringConversionChar: u32 = 4;
pub const XIMStringConversionSubstitution: u32 = 1;
pub const XIMStringConversionRetrieval: u32 = 2;
pub const XIMHotKeyStateON: u32 = 1;
pub const XIMHotKeyStateOFF: u32 = 2;
pub const XATOM_H: u32 = 1;
pub const SDL_SYSWM_CURRENT_VERSION: u32 = 1;
pub const SDL_METALVIEW_TAG: u32 = 255;
pub type __u_char = libc::c_uchar;
pub type __u_short = libc::c_ushort;
pub type __u_int = libc::c_uint;
pub type __u_long = libc::c_ulong;
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = libc::c_long;
pub type __u_quad_t = libc::c_ulong;
pub type __intmax_t = libc::c_long;
pub type __uintmax_t = libc::c_ulong;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __ino64_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __pid_t = libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __fsid_t {
    pub __val: [libc::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::core::mem::MaybeUninit<__fsid_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = libc::c_long;
pub type __rlim_t = libc::c_ulong;
pub type __rlim64_t = libc::c_ulong;
pub type __id_t = libc::c_uint;
pub type __time_t = libc::c_long;
pub type __useconds_t = libc::c_uint;
pub type __suseconds_t = libc::c_long;
pub type __suseconds64_t = libc::c_long;
pub type __daddr_t = libc::c_int;
pub type __key_t = libc::c_int;
pub type __clockid_t = libc::c_int;
pub type __timer_t = *mut libc::c_void;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __blkcnt64_t = libc::c_long;
pub type __fsblkcnt_t = libc::c_ulong;
pub type __fsblkcnt64_t = libc::c_ulong;
pub type __fsfilcnt_t = libc::c_ulong;
pub type __fsfilcnt64_t = libc::c_ulong;
pub type __fsword_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type __syscall_ulong_t = libc::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut libc::c_char;
pub type __intptr_t = libc::c_long;
pub type __socklen_t = libc::c_uint;
pub type __sig_atomic_t = libc::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = libc::c_schar;
pub type int_fast16_t = libc::c_long;
pub type int_fast32_t = libc::c_long;
pub type int_fast64_t = libc::c_long;
pub type uint_fast8_t = libc::c_uchar;
pub type uint_fast16_t = libc::c_ulong;
pub type uint_fast32_t = libc::c_ulong;
pub type uint_fast64_t = libc::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gwchar_t = libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: libc::c_long,
    pub rem: libc::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<imaxdiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: libc::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: libc::c_int,
    ) -> uintmax_t;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type wchar_t = libc::c_int;
pub type wint_t = libc::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: libc::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: libc::c_uint,
    pub __wchb: [libc::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::core::mem::MaybeUninit<__mbstate_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type mbstate_t = __mbstate_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_FILE {
    _unused: [u8; 0],
}
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const libc::c_ushort,
    pub __ctype_tolower: *const libc::c_int,
    pub __ctype_toupper: *const libc::c_int,
    pub __names: [*const libc::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::core::mem::MaybeUninit<__locale_struct> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tm {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wcscpy(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncat(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(__s1: *const libc::c_int, __s2: *const libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn wcsncmp(
        __s1: *const libc::c_int,
        __s2: *const libc::c_int,
        __n: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn wcscasecmp(__s1: *const wchar_t, __s2: *const wchar_t) -> libc::c_int;
}
extern "C" {
    pub fn wcsncasecmp(__s1: *const wchar_t, __s2: *const wchar_t, __n: usize) -> libc::c_int;
}
extern "C" {
    pub fn wcscasecmp_l(__s1: *const wchar_t, __s2: *const wchar_t, __loc: locale_t)
        -> libc::c_int;
}
extern "C" {
    pub fn wcsncasecmp_l(
        __s1: *const wchar_t,
        __s2: *const wchar_t,
        __n: usize,
        __loc: locale_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn wcscoll(__s1: *const wchar_t, __s2: *const wchar_t) -> libc::c_int;
}
extern "C" {
    pub fn wcsxfrm(__s1: *mut wchar_t, __s2: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn wcscoll_l(__s1: *const wchar_t, __s2: *const wchar_t, __loc: locale_t) -> libc::c_int;
}
extern "C" {
    pub fn wcsxfrm_l(
        __s1: *mut wchar_t,
        __s2: *const wchar_t,
        __n: usize,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wcsdup(__s: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcschr(__wcs: *const libc::c_int, __wc: libc::c_int) -> *mut libc::c_int;
}
extern "C" {
    pub fn wcsrchr(__wcs: *const wchar_t, __wc: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(__wcs: *const wchar_t, __reject: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcsspn(__wcs: *const wchar_t, __accept: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcspbrk(__wcs: *const wchar_t, __accept: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(__haystack: *const wchar_t, __needle: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstok(
        __s: *mut wchar_t,
        __delim: *const wchar_t,
        __ptr: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslen(__s: *const libc::c_int) -> libc::c_ulong;
}
extern "C" {
    pub fn wcsnlen(__s: *const wchar_t, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn wmemchr(
        __s: *const libc::c_int,
        __c: libc::c_int,
        __n: libc::c_ulong,
    ) -> *mut libc::c_int;
}
extern "C" {
    pub fn wmemcmp(
        __s1: *const libc::c_int,
        __s2: *const libc::c_int,
        __n: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn wmemcpy(
        __s1: *mut libc::c_int,
        __s2: *const libc::c_int,
        __n: libc::c_ulong,
    ) -> *mut libc::c_int;
}
extern "C" {
    pub fn wmemmove(
        __s1: *mut libc::c_int,
        __s2: *const libc::c_int,
        __n: libc::c_ulong,
    ) -> *mut libc::c_int;
}
extern "C" {
    pub fn wmemset(__s: *mut wchar_t, __c: wchar_t, __n: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn btowc(__c: libc::c_int) -> wint_t;
}
extern "C" {
    pub fn wctob(__c: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn mbsinit(__ps: *const mbstate_t) -> libc::c_int;
}
extern "C" {
    pub fn mbrtowc(
        __pwc: *mut wchar_t,
        __s: *const libc::c_char,
        __n: usize,
        __p: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcrtomb(__s: *mut libc::c_char, __wc: wchar_t, __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn __mbrlen(__s: *const libc::c_char, __n: usize, __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbrlen(__s: *const libc::c_char, __n: usize, __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbsrtowcs(
        __dst: *mut wchar_t,
        __src: *mut *const libc::c_char,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcsrtombs(
        __dst: *mut libc::c_char,
        __src: *mut *const wchar_t,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mbsnrtowcs(
        __dst: *mut wchar_t,
        __src: *mut *const libc::c_char,
        __nmc: usize,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcsnrtombs(
        __dst: *mut libc::c_char,
        __src: *mut *const wchar_t,
        __nwc: usize,
        __len: usize,
        __ps: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcstod(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn wcstof(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn wcstold(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> u128;
}
extern "C" {
    pub fn wcstol(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: libc::c_int,
    ) -> libc::c_long;
}
extern "C" {
    pub fn wcstoul(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn wcstoll(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: libc::c_int,
    ) -> libc::c_longlong;
}
extern "C" {
    pub fn wcstoull(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: libc::c_int,
    ) -> libc::c_ulonglong;
}
extern "C" {
    pub fn wcpcpy(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcpncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn open_wmemstream(__bufloc: *mut *mut wchar_t, __sizeloc: *mut usize) -> *mut __FILE;
}
extern "C" {
    pub fn fwide(__fp: *mut __FILE, __mode: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn fwprintf(__stream: *mut __FILE, __format: *const wchar_t, ...) -> libc::c_int;
}
extern "C" {
    pub fn wprintf(__format: *const wchar_t, ...) -> libc::c_int;
}
extern "C" {
    pub fn swprintf(__s: *mut wchar_t, __n: usize, __format: *const wchar_t, ...) -> libc::c_int;
}
extern "C" {
    pub fn vfwprintf(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vwprintf(__format: *const wchar_t, __arg: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn vswprintf(
        __s: *mut wchar_t,
        __n: usize,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn fwscanf(__stream: *mut __FILE, __format: *const wchar_t, ...) -> libc::c_int;
}
extern "C" {
    pub fn wscanf(__format: *const wchar_t, ...) -> libc::c_int;
}
extern "C" {
    pub fn swscanf(__s: *const wchar_t, __format: *const wchar_t, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fwscanf"]
    pub fn fwscanf1(__stream: *mut __FILE, __format: *const wchar_t, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_wscanf"]
    pub fn wscanf1(__format: *const wchar_t, ...) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_swscanf"]
    pub fn swscanf1(__s: *const wchar_t, __format: *const wchar_t, ...) -> libc::c_int;
}
extern "C" {
    pub fn vfwscanf(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vwscanf(__format: *const wchar_t, __arg: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn vswscanf(
        __s: *const wchar_t,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfwscanf"]
    pub fn vfwscanf1(
        __s: *mut __FILE,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vwscanf"]
    pub fn vwscanf1(__format: *const wchar_t, __arg: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vswscanf"]
    pub fn vswscanf1(
        __s: *const wchar_t,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn fgetwc(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn getwc(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn putwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(__wc: wchar_t) -> wint_t;
}
extern "C" {
    pub fn fgetws(__ws: *mut wchar_t, __n: libc::c_int, __stream: *mut __FILE) -> *mut wchar_t;
}
extern "C" {
    pub fn fputws(__ws: *const wchar_t, __stream: *mut __FILE) -> libc::c_int;
}
extern "C" {
    pub fn ungetwc(__wc: wint_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn wcsftime(
        __s: *mut wchar_t,
        __maxsize: usize,
        __format: *const wchar_t,
        __tp: *const tm,
    ) -> usize;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_bool {
    SDL_FALSE = 0,
    SDL_TRUE = 1,
}
pub type Sint8 = i8;
pub type Uint8 = u8;
pub type Sint16 = i16;
pub type Uint16 = u16;
pub type Sint32 = i32;
pub type Uint32 = u32;
pub type Sint64 = i64;
pub type Uint64 = u64;
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_DUMMY_ENUM {
    DUMMY_ENUM_VALUE = 0,
}
extern "C" {
    pub fn SDL_malloc(size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn SDL_calloc(nmemb: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn SDL_realloc(mem: *mut libc::c_void, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn SDL_free(mem: *mut libc::c_void);
}
pub type SDL_malloc_func =
    ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut libc::c_void>;
pub type SDL_calloc_func =
    ::core::option::Option<unsafe extern "C" fn(nmemb: usize, size: usize) -> *mut libc::c_void>;
pub type SDL_realloc_func = ::core::option::Option<
    unsafe extern "C" fn(mem: *mut libc::c_void, size: usize) -> *mut libc::c_void,
>;
pub type SDL_free_func = ::core::option::Option<unsafe extern "C" fn(mem: *mut libc::c_void)>;
extern "C" {
    #[doc = " Get the original set of SDL memory functions\n\n \\param malloc_func filled with malloc function\n \\param calloc_func filled with calloc function\n \\param realloc_func filled with realloc function\n \\param free_func filled with free function\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetOriginalMemoryFunctions(
        malloc_func: *mut SDL_malloc_func,
        calloc_func: *mut SDL_calloc_func,
        realloc_func: *mut SDL_realloc_func,
        free_func: *mut SDL_free_func,
    );
}
extern "C" {
    #[doc = " Get the current set of SDL memory functions\n\n \\param malloc_func filled with malloc function\n \\param calloc_func filled with calloc function\n \\param realloc_func filled with realloc function\n \\param free_func filled with free function\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetMemoryFunctions(
        malloc_func: *mut SDL_malloc_func,
        calloc_func: *mut SDL_calloc_func,
        realloc_func: *mut SDL_realloc_func,
        free_func: *mut SDL_free_func,
    );
}
extern "C" {
    #[doc = " Replace SDL's memory allocation functions with a custom set\n\n \\param malloc_func custom malloc function\n \\param calloc_func custom calloc function\n \\param realloc_func custom realloc function\n \\param free_func custom free function\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_SetMemoryFunctions(
        malloc_func: SDL_malloc_func,
        calloc_func: SDL_calloc_func,
        realloc_func: SDL_realloc_func,
        free_func: SDL_free_func,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Allocate memory aligned to a specific value\n\n If `alignment` is less than the size of `void *`, then it will be increased\n to match that.\n\n The returned memory address will be a multiple of the alignment value, and\n the amount of memory allocated will be a multiple of the alignment value.\n\n The memory returned by this function must be freed with SDL_aligned_free()\n\n \\param alignment the alignment requested\n \\param size the size to allocate\n \\returns a pointer to the aligned memory\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_aligned_free"]
    pub fn SDL_aligned_alloc(alignment: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Free memory allocated by SDL_aligned_alloc()\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_aligned_alloc"]
    pub fn SDL_aligned_free(mem: *mut libc::c_void);
}
extern "C" {
    #[doc = " Get the number of outstanding (unfreed) allocations\n\n \\returns the number of allocations\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetNumAllocations() -> libc::c_int;
}
extern "C" {
    pub fn SDL_getenv(name: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_setenv(
        name: *const libc::c_char,
        value: *const libc::c_char,
        overwrite: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn SDL_qsort(
        base: *mut libc::c_void,
        nmemb: usize,
        size: usize,
        compare: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const libc::c_void,
                arg2: *const libc::c_void,
            ) -> libc::c_int,
        >,
    );
}
extern "C" {
    pub fn SDL_bsearch(
        key: *const libc::c_void,
        base: *const libc::c_void,
        nmemb: usize,
        size: usize,
        compare: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const libc::c_void,
                arg2: *const libc::c_void,
            ) -> libc::c_int,
        >,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn SDL_abs(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_isalpha(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_isalnum(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_isblank(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_iscntrl(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_isdigit(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_isxdigit(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_ispunct(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_isspace(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_isupper(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_islower(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_isprint(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_isgraph(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_toupper(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_tolower(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_crc16(crc: Uint16, data: *const libc::c_void, len: usize) -> Uint16;
}
extern "C" {
    pub fn SDL_crc32(crc: Uint32, data: *const libc::c_void, len: usize) -> Uint32;
}
extern "C" {
    pub fn SDL_memset(dst: *mut libc::c_void, c: libc::c_int, len: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn SDL_memset4(dst: *mut libc::c_void, val: Uint32, dwords: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn SDL_memcpy(
        dst: *mut libc::c_void,
        src: *const libc::c_void,
        len: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn SDL_memmove(
        dst: *mut libc::c_void,
        src: *const libc::c_void,
        len: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn SDL_memcmp(s1: *const libc::c_void, s2: *const libc::c_void, len: usize) -> libc::c_int;
}
extern "C" {
    pub fn SDL_wcslen(wstr: *const wchar_t) -> usize;
}
extern "C" {
    pub fn SDL_wcsnlen(wstr: *const wchar_t, maxlen: usize) -> usize;
}
extern "C" {
    pub fn SDL_wcslcpy(dst: *mut wchar_t, src: *const wchar_t, maxlen: usize) -> usize;
}
extern "C" {
    pub fn SDL_wcslcat(dst: *mut wchar_t, src: *const wchar_t, maxlen: usize) -> usize;
}
extern "C" {
    pub fn SDL_wcsdup(wstr: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn SDL_wcsstr(haystack: *const wchar_t, needle: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn SDL_wcscmp(str1: *const wchar_t, str2: *const wchar_t) -> libc::c_int;
}
extern "C" {
    pub fn SDL_wcsncmp(str1: *const wchar_t, str2: *const wchar_t, maxlen: usize) -> libc::c_int;
}
extern "C" {
    pub fn SDL_wcscasecmp(str1: *const wchar_t, str2: *const wchar_t) -> libc::c_int;
}
extern "C" {
    pub fn SDL_wcsncasecmp(str1: *const wchar_t, str2: *const wchar_t, len: usize) -> libc::c_int;
}
extern "C" {
    pub fn SDL_wcstol(
        str_: *const wchar_t,
        endp: *mut *mut wchar_t,
        base: libc::c_int,
    ) -> libc::c_long;
}
extern "C" {
    pub fn SDL_strlen(str_: *const libc::c_char) -> usize;
}
extern "C" {
    pub fn SDL_strnlen(str_: *const libc::c_char, maxlen: usize) -> usize;
}
extern "C" {
    pub fn SDL_strlcpy(dst: *mut libc::c_char, src: *const libc::c_char, maxlen: usize) -> usize;
}
extern "C" {
    pub fn SDL_utf8strlcpy(
        dst: *mut libc::c_char,
        src: *const libc::c_char,
        dst_bytes: usize,
    ) -> usize;
}
extern "C" {
    pub fn SDL_strlcat(dst: *mut libc::c_char, src: *const libc::c_char, maxlen: usize) -> usize;
}
extern "C" {
    pub fn SDL_strdup(str_: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_strndup(str_: *const libc::c_char, maxlen: usize) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_strrev(str_: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_strupr(str_: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_strlwr(str_: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_strchr(str_: *const libc::c_char, c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_strrchr(str_: *const libc::c_char, c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_strstr(
        haystack: *const libc::c_char,
        needle: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_strcasestr(
        haystack: *const libc::c_char,
        needle: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_strtok_r(
        s1: *mut libc::c_char,
        s2: *const libc::c_char,
        saveptr: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_utf8strlen(str_: *const libc::c_char) -> usize;
}
extern "C" {
    pub fn SDL_utf8strnlen(str_: *const libc::c_char, bytes: usize) -> usize;
}
extern "C" {
    pub fn SDL_itoa(
        value: libc::c_int,
        str_: *mut libc::c_char,
        radix: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_uitoa(
        value: libc::c_uint,
        str_: *mut libc::c_char,
        radix: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_ltoa(
        value: libc::c_long,
        str_: *mut libc::c_char,
        radix: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_ultoa(
        value: libc::c_ulong,
        str_: *mut libc::c_char,
        radix: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_lltoa(
        value: Sint64,
        str_: *mut libc::c_char,
        radix: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_ulltoa(
        value: Uint64,
        str_: *mut libc::c_char,
        radix: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_atoi(str_: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn SDL_atof(str_: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn SDL_strtol(
        str_: *const libc::c_char,
        endp: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> libc::c_long;
}
extern "C" {
    pub fn SDL_strtoul(
        str_: *const libc::c_char,
        endp: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn SDL_strtoll(
        str_: *const libc::c_char,
        endp: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> Sint64;
}
extern "C" {
    pub fn SDL_strtoull(
        str_: *const libc::c_char,
        endp: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> Uint64;
}
extern "C" {
    pub fn SDL_strtod(str_: *const libc::c_char, endp: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn SDL_strcmp(str1: *const libc::c_char, str2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn SDL_strncmp(
        str1: *const libc::c_char,
        str2: *const libc::c_char,
        maxlen: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn SDL_strcasecmp(str1: *const libc::c_char, str2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn SDL_strncasecmp(
        str1: *const libc::c_char,
        str2: *const libc::c_char,
        len: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn SDL_sscanf(text: *const libc::c_char, fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn SDL_vsscanf(
        text: *const libc::c_char,
        fmt: *const libc::c_char,
        ap: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn SDL_snprintf(
        text: *mut libc::c_char,
        maxlen: usize,
        fmt: *const libc::c_char,
        ...
    ) -> libc::c_int;
}
extern "C" {
    pub fn SDL_swprintf(text: *mut wchar_t, maxlen: usize, fmt: *const wchar_t, ...)
        -> libc::c_int;
}
extern "C" {
    pub fn SDL_vsnprintf(
        text: *mut libc::c_char,
        maxlen: usize,
        fmt: *const libc::c_char,
        ap: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn SDL_vswprintf(
        text: *mut wchar_t,
        maxlen: usize,
        fmt: *const wchar_t,
        ap: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn SDL_asprintf(strp: *mut *mut libc::c_char, fmt: *const libc::c_char, ...)
        -> libc::c_int;
}
extern "C" {
    pub fn SDL_vasprintf(
        strp: *mut *mut libc::c_char,
        fmt: *const libc::c_char,
        ap: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Use this function to compute arc cosine of `x`.\n\n The definition of `y = acos(x)` is `x = cos(y)`.\n\n Domain: `-1 <= x <= 1`\n\n Range: `0 <= y <= Pi`\n\n \\param x floating point value, in radians.\n \\returns arc cosine of `x`.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_acos(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_acosf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_asin(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_asinf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_atan(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_atanf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_atan2(y: f64, x: f64) -> f64;
}
extern "C" {
    pub fn SDL_atan2f(y: f32, x: f32) -> f32;
}
extern "C" {
    pub fn SDL_ceil(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_ceilf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_copysign(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn SDL_copysignf(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn SDL_cos(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_cosf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_exp(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_expf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_fabs(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_fabsf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_floor(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_floorf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_trunc(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_truncf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_fmod(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn SDL_fmodf(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn SDL_log(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_logf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_log10(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_log10f(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_modf(x: f64, y: *mut f64) -> f64;
}
extern "C" {
    pub fn SDL_modff(x: f32, y: *mut f32) -> f32;
}
extern "C" {
    pub fn SDL_pow(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn SDL_powf(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn SDL_round(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_roundf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_lround(x: f64) -> libc::c_long;
}
extern "C" {
    pub fn SDL_lroundf(x: f32) -> libc::c_long;
}
extern "C" {
    pub fn SDL_scalbn(x: f64, n: libc::c_int) -> f64;
}
extern "C" {
    pub fn SDL_scalbnf(x: f32, n: libc::c_int) -> f32;
}
extern "C" {
    pub fn SDL_sin(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_sinf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_sqrt(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_sqrtf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_tan(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_tanf(x: f32) -> f32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_iconv_data_t {
    _unused: [u8; 0],
}
pub type SDL_iconv_t = *mut SDL_iconv_data_t;
extern "C" {
    pub fn SDL_iconv_open(
        tocode: *const libc::c_char,
        fromcode: *const libc::c_char,
    ) -> SDL_iconv_t;
}
extern "C" {
    pub fn SDL_iconv_close(cd: SDL_iconv_t) -> libc::c_int;
}
extern "C" {
    pub fn SDL_iconv(
        cd: SDL_iconv_t,
        inbuf: *mut *const libc::c_char,
        inbytesleft: *mut usize,
        outbuf: *mut *mut libc::c_char,
        outbytesleft: *mut usize,
    ) -> usize;
}
extern "C" {
    #[doc = " This function converts a buffer or string between encodings in one pass,\n returning a string that must be freed with SDL_free() or NULL on error.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_iconv_string(
        tocode: *const libc::c_char,
        fromcode: *const libc::c_char,
        inbuf: *const libc::c_char,
        inbytesleft: usize,
    ) -> *mut libc::c_char;
}
pub type SDL_FunctionPointer = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_AssertState {
    #[doc = "< Retry the assert immediately."]
    SDL_ASSERTION_RETRY = 0,
    #[doc = "< Make the debugger trigger a breakpoint."]
    SDL_ASSERTION_BREAK = 1,
    #[doc = "< Terminate the program."]
    SDL_ASSERTION_ABORT = 2,
    #[doc = "< Ignore the assert."]
    SDL_ASSERTION_IGNORE = 3,
    #[doc = "< Ignore the assert from now on."]
    SDL_ASSERTION_ALWAYS_IGNORE = 4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_AssertData {
    pub always_ignore: libc::c_int,
    pub trigger_count: libc::c_uint,
    pub condition: *const libc::c_char,
    pub filename: *const libc::c_char,
    pub linenum: libc::c_int,
    pub function: *const libc::c_char,
    pub next: *const SDL_AssertData,
}
#[test]
fn bindgen_test_layout_SDL_AssertData() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_AssertData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_AssertData>(),
        48usize,
        concat!("Size of: ", stringify!(SDL_AssertData))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_AssertData>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_AssertData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).always_ignore) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(always_ignore)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).trigger_count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(trigger_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).condition) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(condition)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).linenum) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(linenum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).function) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    #[doc = " Never call this directly.\n\n Use the SDL_assert* macros.\n\n \\param data assert data structure\n \\param func function name\n \\param file file name\n \\param line line number\n \\returns assert state\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_ReportAssertion(
        data: *mut SDL_AssertData,
        func: *const libc::c_char,
        file: *const libc::c_char,
        line: libc::c_int,
    ) -> SDL_AssertState;
}
#[doc = " A callback that fires when an SDL assertion fails.\n\n \\param data a pointer to the SDL_AssertData structure corresponding to the\n             current assertion\n \\param userdata what was passed as `userdata` to SDL_SetAssertionHandler()\n \\returns an SDL_AssertState value indicating how to handle the failure."]
pub type SDL_AssertionHandler = ::core::option::Option<
    unsafe extern "C" fn(
        data: *const SDL_AssertData,
        userdata: *mut libc::c_void,
    ) -> SDL_AssertState,
>;
extern "C" {
    #[doc = " Set an application-defined assertion handler.\n\n This function allows an application to show its own assertion UI and/or\n force the response to an assertion failure. If the application doesn't\n provide this, SDL will try to do the right thing, popping up a\n system-specific GUI dialog, and probably minimizing any fullscreen windows.\n\n This callback may fire from any thread, but it runs wrapped in a mutex, so\n it will only fire from one thread at a time.\n\n This callback is NOT reset to SDL's internal handler upon SDL_Quit()!\n\n \\param handler the SDL_AssertionHandler function to call when an assertion\n                fails or NULL for the default handler\n \\param userdata a pointer that is passed to `handler`\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetAssertionHandler"]
    pub fn SDL_SetAssertionHandler(handler: SDL_AssertionHandler, userdata: *mut libc::c_void);
}
extern "C" {
    #[doc = " Get the default assertion handler.\n\n This returns the function pointer that is called by default when an\n assertion is triggered. This is an internal function provided by SDL, that\n is used for assertions when SDL_SetAssertionHandler() hasn't been used to\n provide a different function.\n\n \\returns the default SDL_AssertionHandler that is called when an assert\n          triggers.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetAssertionHandler"]
    pub fn SDL_GetDefaultAssertionHandler() -> SDL_AssertionHandler;
}
extern "C" {
    #[doc = " Get the current assertion handler.\n\n This returns the function pointer that is called when an assertion is\n triggered. This is either the value last passed to\n SDL_SetAssertionHandler(), or if no application-specified function is set,\n is equivalent to calling SDL_GetDefaultAssertionHandler().\n\n The parameter `puserdata` is a pointer to a void*, which will store the\n \"userdata\" pointer that was passed to SDL_SetAssertionHandler(). This value\n will always be NULL for the default handler. If you don't care about this\n data, it is safe to pass a NULL pointer to this function to ignore it.\n\n \\param puserdata pointer which is filled with the \"userdata\" pointer that\n                  was passed to SDL_SetAssertionHandler()\n \\returns the SDL_AssertionHandler that is called when an assert triggers.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetAssertionHandler"]
    pub fn SDL_GetAssertionHandler(puserdata: *mut *mut libc::c_void) -> SDL_AssertionHandler;
}
extern "C" {
    #[doc = " Get a list of all assertion failures.\n\n This function gets all assertions triggered since the last call to\n SDL_ResetAssertionReport(), or the start of the program.\n\n The proper way to examine this data looks something like this:\n\n ```c\n const SDL_AssertData *item = SDL_GetAssertionReport();\n while (item) {\n    printf(\"'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\\\n\",\n           item->condition, item->function, item->filename,\n           item->linenum, item->trigger_count,\n           item->always_ignore ? \"yes\" : \"no\");\n    item = item->next;\n }\n ```\n\n \\returns a list of all failed assertions or NULL if the list is empty. This\n          memory should not be modified or freed by the application.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_ResetAssertionReport"]
    pub fn SDL_GetAssertionReport() -> *const SDL_AssertData;
}
extern "C" {
    #[doc = " Clear the list of all assertion failures.\n\n This function will clear the list of all assertions triggered up to that\n point. Immediately following this call, SDL_GetAssertionReport will return\n no items. In addition, any previously-triggered assertions will be reset to\n a trigger_count of zero, and their always_ignore state will be false.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetAssertionReport"]
    pub fn SDL_ResetAssertionReport();
}
pub type SDL_SpinLock = libc::c_int;
extern "C" {
    #[doc = " Try to lock a spin lock by setting it to a non-zero value.\n\n ***Please note that spinlocks are dangerous if you don't know what you're\n doing. Please be careful using any sort of spinlock!***\n\n \\param lock a pointer to a lock variable\n \\returns SDL_TRUE if the lock succeeded, SDL_FALSE if the lock is already\n          held.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_AtomicLock\n \\sa SDL_AtomicUnlock"]
    pub fn SDL_AtomicTryLock(lock: *mut SDL_SpinLock) -> SDL_bool;
}
extern "C" {
    #[doc = " Lock a spin lock by setting it to a non-zero value.\n\n ***Please note that spinlocks are dangerous if you don't know what you're\n doing. Please be careful using any sort of spinlock!***\n\n \\param lock a pointer to a lock variable\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_AtomicTryLock\n \\sa SDL_AtomicUnlock"]
    pub fn SDL_AtomicLock(lock: *mut SDL_SpinLock);
}
extern "C" {
    #[doc = " Unlock a spin lock by setting it to 0.\n\n Always returns immediately.\n\n ***Please note that spinlocks are dangerous if you don't know what you're\n doing. Please be careful using any sort of spinlock!***\n\n \\param lock a pointer to a lock variable\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_AtomicLock\n \\sa SDL_AtomicTryLock"]
    pub fn SDL_AtomicUnlock(lock: *mut SDL_SpinLock);
}
extern "C" {
    #[doc = " Memory barriers are designed to prevent reads and writes from being\n reordered by the compiler and being seen out of order on multi-core CPUs.\n\n A typical pattern would be for thread A to write some data and a flag, and\n for thread B to read the flag and get the data. In this case you would\n insert a release barrier between writing the data and the flag,\n guaranteeing that the data write completes no later than the flag is\n written, and you would insert an acquire barrier between reading the flag\n and reading the data, to ensure that all the reads associated with the flag\n have completed.\n\n In this pattern you should always see a release barrier paired with an\n acquire barrier and you should gate the data reads/writes with a single\n flag variable.\n\n For more information on these semantics, take a look at the blog post:\n http://preshing.com/20120913/acquire-and-release-semantics\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_MemoryBarrierReleaseFunction();
}
extern "C" {
    pub fn SDL_MemoryBarrierAcquireFunction();
}
#[doc = " \\brief A type representing an atomic integer value.  It is a struct\n        so people don't accidentally use numeric operations on it."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_AtomicInt {
    pub value: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_AtomicInt() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_AtomicInt> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_AtomicInt>(),
        4usize,
        concat!("Size of: ", stringify!(SDL_AtomicInt))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_AtomicInt>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_AtomicInt))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AtomicInt),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Set an atomic variable to a new value if it is currently an old value.\n\n ***Note: If you don't know what this function is for, you shouldn't use\n it!***\n\n \\param a a pointer to an SDL_AtomicInt variable to be modified\n \\param oldval the old value\n \\param newval the new value\n \\returns SDL_TRUE if the atomic variable was set, SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_AtomicCASPtr\n \\sa SDL_AtomicGet\n \\sa SDL_AtomicSet"]
    pub fn SDL_AtomicCAS(
        a: *mut SDL_AtomicInt,
        oldval: libc::c_int,
        newval: libc::c_int,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Set an atomic variable to a value.\n\n This function also acts as a full memory barrier.\n\n ***Note: If you don't know what this function is for, you shouldn't use\n it!***\n\n \\param a a pointer to an SDL_AtomicInt variable to be modified\n \\param v the desired value\n \\returns the previous value of the atomic variable.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_AtomicGet"]
    pub fn SDL_AtomicSet(a: *mut SDL_AtomicInt, v: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the value of an atomic variable.\n\n ***Note: If you don't know what this function is for, you shouldn't use\n it!***\n\n \\param a a pointer to an SDL_AtomicInt variable\n \\returns the current value of an atomic variable.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_AtomicSet"]
    pub fn SDL_AtomicGet(a: *mut SDL_AtomicInt) -> libc::c_int;
}
extern "C" {
    #[doc = " Add to an atomic variable.\n\n This function also acts as a full memory barrier.\n\n ***Note: If you don't know what this function is for, you shouldn't use\n it!***\n\n \\param a a pointer to an SDL_AtomicInt variable to be modified\n \\param v the desired value to add\n \\returns the previous value of the atomic variable.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_AtomicDecRef\n \\sa SDL_AtomicIncRef"]
    pub fn SDL_AtomicAdd(a: *mut SDL_AtomicInt, v: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Set a pointer to a new value if it is currently an old value.\n\n ***Note: If you don't know what this function is for, you shouldn't use\n it!***\n\n \\param a a pointer to a pointer\n \\param oldval the old pointer value\n \\param newval the new pointer value\n \\returns SDL_TRUE if the pointer was set, SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_AtomicCAS\n \\sa SDL_AtomicGetPtr\n \\sa SDL_AtomicSetPtr"]
    pub fn SDL_AtomicCASPtr(
        a: *mut *mut libc::c_void,
        oldval: *mut libc::c_void,
        newval: *mut libc::c_void,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Set a pointer to a value atomically.\n\n ***Note: If you don't know what this function is for, you shouldn't use\n it!***\n\n \\param a a pointer to a pointer\n \\param v the desired pointer value\n \\returns the previous value of the pointer.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_AtomicCASPtr\n \\sa SDL_AtomicGetPtr"]
    pub fn SDL_AtomicSetPtr(a: *mut *mut libc::c_void, v: *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Get the value of a pointer atomically.\n\n ***Note: If you don't know what this function is for, you shouldn't use\n it!***\n\n \\param a a pointer to a pointer\n \\returns the current value of a pointer.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_AtomicCASPtr\n \\sa SDL_AtomicSetPtr"]
    pub fn SDL_AtomicGetPtr(a: *mut *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Set the SDL error message for the current thread.\n\n Calling this function will replace any previous error message that was set.\n\n This function always returns -1, since SDL frequently uses -1 to signify an\n failing result, leading to this idiom:\n\n ```c\n if (error_code) {\n     return SDL_SetError(\"This operation has failed: %d\", error_code);\n }\n ```\n\n \\param fmt a printf()-style message format string\n \\param ... additional parameters matching % tokens in the `fmt` string, if\n            any\n \\returns always -1.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_ClearError\n \\sa SDL_GetError"]
    pub fn SDL_SetError(fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    #[doc = " Retrieve a message about the last error that occurred on the current\n thread.\n\n It is possible for multiple errors to occur before calling SDL_GetError().\n Only the last error is returned.\n\n The message is only applicable when an SDL function has signaled an error.\n You must check the return values of SDL function calls to determine when to\n appropriately call SDL_GetError(). You should *not* use the results of\n SDL_GetError() to decide if an error has occurred! Sometimes SDL will set\n an error string even when reporting success.\n\n SDL will *not* clear the error string for successful API calls. You *must*\n check return values for failure cases before you can assume the error\n string applies.\n\n Error strings are set per-thread, so an error set in a different thread\n will not interfere with the current thread's operation.\n\n The returned string is internally allocated and must not be freed by the\n application.\n\n \\returns a message with information about the specific error that occurred,\n          or an empty string if there hasn't been an error message set since\n          the last call to SDL_ClearError(). The message is only applicable\n          when an SDL function has signaled an error. You must check the\n          return values of SDL function calls to determine when to\n          appropriately call SDL_GetError().\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_ClearError\n \\sa SDL_SetError"]
    pub fn SDL_GetError() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the last error message that was set for the current thread.\n\n This allows the caller to copy the error string into a provided buffer, but\n otherwise operates exactly the same as SDL_GetError().\n\n \\param errstr A buffer to fill with the last error message that was set for\n               the current thread\n \\param maxlen The size of the buffer pointed to by the errstr parameter\n \\returns the pointer passed in as the `errstr` parameter.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetError"]
    pub fn SDL_GetErrorMsg(errstr: *mut libc::c_char, maxlen: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Clear any previous error message for this thread.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetError\n \\sa SDL_SetError"]
    pub fn SDL_ClearError();
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_errorcode {
    SDL_ENOMEM = 0,
    SDL_EFREAD = 1,
    SDL_EFWRITE = 2,
    SDL_EFSEEK = 3,
    SDL_UNSUPPORTED = 4,
    SDL_LASTERROR = 5,
}
extern "C" {
    #[doc = " SDL_Error()\n\n \\param code Error code\n \\returns unconditionally -1.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_Error(code: SDL_errorcode) -> libc::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Mutex {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a new mutex.\n\n All newly-created mutexes begin in the _unlocked_ state.\n\n Calls to SDL_LockMutex() will not return while the mutex is locked by\n another thread. See SDL_TryLockMutex() to attempt to lock without blocking.\n\n SDL mutexes are reentrant.\n\n \\returns the initialized and unlocked mutex or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_DestroyMutex\n \\sa SDL_LockMutex\n \\sa SDL_TryLockMutex\n \\sa SDL_UnlockMutex"]
    pub fn SDL_CreateMutex() -> *mut SDL_Mutex;
}
extern "C" {
    #[doc = " Lock the mutex.\n\n This will block until the mutex is available, which is to say it is in the\n unlocked state and the OS has chosen the caller as the next thread to lock\n it. Of all threads waiting to lock the mutex, only one may do so at a time.\n\n It is legal for the owning thread to lock an already-locked mutex. It must\n unlock it the same number of times before it is actually made available for\n other threads in the system (this is known as a \"recursive mutex\").\n\n \\param mutex the mutex to lock\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_LockMutex(mutex: *mut SDL_Mutex) -> libc::c_int;
}
extern "C" {
    #[doc = " Try to lock a mutex without blocking.\n\n This works just like SDL_LockMutex(), but if the mutex is not available,\n this function returns `SDL_MUTEX_TIMEDOUT` immediately.\n\n This technique is useful if you need exclusive access to a resource but\n don't want to wait for it, and will return to it to try again later.\n\n \\param mutex the mutex to try to lock\n \\returns 0, `SDL_MUTEX_TIMEDOUT`, or -1 on error; call SDL_GetError() for\n          more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateMutex\n \\sa SDL_DestroyMutex\n \\sa SDL_LockMutex\n \\sa SDL_UnlockMutex"]
    pub fn SDL_TryLockMutex(mutex: *mut SDL_Mutex) -> libc::c_int;
}
extern "C" {
    #[doc = " Unlock the mutex.\n\n It is legal for the owning thread to lock an already-locked mutex. It must\n unlock it the same number of times before it is actually made available for\n other threads in the system (this is known as a \"recursive mutex\").\n\n It is illegal to unlock a mutex that has not been locked by the current\n thread, and doing so results in undefined behavior.\n\n \\param mutex the mutex to unlock.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_UnlockMutex(mutex: *mut SDL_Mutex) -> libc::c_int;
}
extern "C" {
    #[doc = " Destroy a mutex created with SDL_CreateMutex().\n\n This function must be called on any mutex that is no longer needed. Failure\n to destroy a mutex will result in a system memory or resource leak. While\n it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt\n to destroy a locked mutex, and may result in undefined behavior depending\n on the platform.\n\n \\param mutex the mutex to destroy\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateMutex\n \\sa SDL_LockMutex\n \\sa SDL_TryLockMutex\n \\sa SDL_UnlockMutex"]
    pub fn SDL_DestroyMutex(mutex: *mut SDL_Mutex);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_RWLock {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a new read/write lock.\n\n A read/write lock is useful for situations where you have multiple threads\n trying to access a resource that is rarely updated. All threads requesting\n a read-only lock will be allowed to run in parallel; if a thread requests a\n write lock, it will be provided exclusive access. This makes it safe for\n multiple threads to use a resource at the same time if they promise not to\n change it, and when it has to be changed, the rwlock will serve as a\n gateway to make sure those changes can be made safely.\n\n In the right situation, a rwlock can be more efficient than a mutex, which\n only lets a single thread proceed at a time, even if it won't be modifying\n the data.\n\n All newly-created read/write locks begin in the _unlocked_ state.\n\n Calls to SDL_LockRWLockForReading() and SDL_LockRWLockForWriting will not\n return while the rwlock is locked _for writing_ by another thread. See\n SDL_TryLockRWLockForReading() and SDL_TryLockRWLockForWriting() to attempt\n to lock without blocking.\n\n SDL read/write locks are only recursive for read-only locks! They are not\n guaranteed to be fair, or provide access in a FIFO manner! They are not\n guaranteed to favor writers. You may not lock a rwlock for both read-only\n and write access at the same time from the same thread (so you can't\n promote your read-only lock to a write lock without unlocking first).\n\n \\returns the initialized and unlocked read/write lock or NULL on failure;\n          call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_DestroyRWLock\n \\sa SDL_LockRWLockForReading\n \\sa SDL_TryLockRWLockForReading\n \\sa SDL_LockRWLockForWriting\n \\sa SDL_TryLockRWLockForWriting\n \\sa SDL_UnlockRWLock"]
    pub fn SDL_CreateRWLock() -> *mut SDL_RWLock;
}
extern "C" {
    #[doc = " Lock the read/write lock for _read only_ operations.\n\n This will block until the rwlock is available, which is to say it is not\n locked for writing by any other thread. Of all threads waiting to lock the\n rwlock, all may do so at the same time as long as they are requesting\n read-only access; if a thread wants to lock for writing, only one may do so\n at a time, and no other threads, read-only or not, may hold the lock at the\n same time.\n\n It is legal for the owning thread to lock an already-locked rwlock for\n reading. It must unlock it the same number of times before it is actually\n made available for other threads in the system (this is known as a\n \"recursive rwlock\").\n\n Note that locking for writing is not recursive (this is only available to\n read-only locks).\n\n It is illegal to request a read-only lock from a thread that already holds\n the write lock. Doing so results in undefined behavior. Unlock the write\n lock before requesting a read-only lock. (But, of course, if you have the\n write lock, you don't need further locks to read in any case.)\n\n \\param rwlock the read/write lock to lock\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_UnlockRWLock"]
    pub fn SDL_LockRWLockForReading(rwlock: *mut SDL_RWLock) -> libc::c_int;
}
extern "C" {
    #[doc = " Lock the read/write lock for _write_ operations.\n\n This will block until the rwlock is available, which is to say it is not\n locked for reading or writing by any other thread. Only one thread may hold\n the lock when it requests write access; all other threads, whether they\n also want to write or only want read-only access, must wait until the\n writer thread has released the lock.\n\n It is illegal for the owning thread to lock an already-locked rwlock for\n writing (read-only may be locked recursively, writing can not). Doing so\n results in undefined behavior.\n\n It is illegal to request a write lock from a thread that already holds a\n read-only lock. Doing so results in undefined behavior. Unlock the\n read-only lock before requesting a write lock.\n\n \\param rwlock the read/write lock to lock\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_UnlockRWLock"]
    pub fn SDL_LockRWLockForWriting(rwlock: *mut SDL_RWLock) -> libc::c_int;
}
extern "C" {
    #[doc = " Try to lock a read/write lock _for reading_ without blocking.\n\n This works just like SDL_LockRWLockForReading(), but if the rwlock is not\n available, then this function returns `SDL_RWLOCK_TIMEDOUT` immediately.\n\n This technique is useful if you need access to a resource but don't want to\n wait for it, and will return to it to try again later.\n\n Trying to lock for read-only access can succeed if other threads are\n holding read-only locks, as this won't prevent access.\n\n \\param rwlock the rwlock to try to lock\n \\returns 0, `SDL_RWLOCK_TIMEDOUT`, or -1 on error; call SDL_GetError() for\n          more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateRWLock\n \\sa SDL_DestroyRWLock\n \\sa SDL_TryLockRWLockForReading\n \\sa SDL_UnlockRWLock"]
    pub fn SDL_TryLockRWLockForReading(rwlock: *mut SDL_RWLock) -> libc::c_int;
}
extern "C" {
    #[doc = " Try to lock a read/write lock _for writing_ without blocking.\n\n This works just like SDL_LockRWLockForWriting(), but if the rwlock is not\n available, this function returns `SDL_RWLOCK_TIMEDOUT` immediately.\n\n This technique is useful if you need exclusive access to a resource but\n don't want to wait for it, and will return to it to try again later.\n\n It is illegal for the owning thread to lock an already-locked rwlock for\n writing (read-only may be locked recursively, writing can not). Doing so\n results in undefined behavior.\n\n It is illegal to request a write lock from a thread that already holds a\n read-only lock. Doing so results in undefined behavior. Unlock the\n read-only lock before requesting a write lock.\n\n \\param rwlock the rwlock to try to lock\n \\returns 0, `SDL_RWLOCK_TIMEDOUT`, or -1 on error; call SDL_GetError() for\n          more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateRWLock\n \\sa SDL_DestroyRWLock\n \\sa SDL_TryLockRWLockForWriting\n \\sa SDL_UnlockRWLock"]
    pub fn SDL_TryLockRWLockForWriting(rwlock: *mut SDL_RWLock) -> libc::c_int;
}
extern "C" {
    #[doc = " Unlock the read/write lock.\n\n Use this function to unlock the rwlock, whether it was locked for read-only\n or write operations.\n\n It is legal for the owning thread to lock an already-locked read-only lock.\n It must unlock it the same number of times before it is actually made\n available for other threads in the system (this is known as a \"recursive\n rwlock\").\n\n It is illegal to unlock a rwlock that has not been locked by the current\n thread, and doing so results in undefined behavior.\n\n \\param rwlock the rwlock to unlock.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_UnlockRWLock(rwlock: *mut SDL_RWLock) -> libc::c_int;
}
extern "C" {
    #[doc = " Destroy a read/write lock created with SDL_CreateRWLock().\n\n This function must be called on any read/write lock that is no longer\n needed. Failure to destroy a rwlock will result in a system memory or\n resource leak. While it is safe to destroy a rwlock that is _unlocked_, it\n is not safe to attempt to destroy a locked rwlock, and may result in\n undefined behavior depending on the platform.\n\n \\param rwlock the rwlock to destroy\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateRWLock\n \\sa SDL_LockRWLockForReading\n \\sa SDL_LockRWLockForWriting\n \\sa SDL_TryLockRWLockForReading\n \\sa SDL_TryLockRWLockForWriting\n \\sa SDL_UnlockRWLock"]
    pub fn SDL_DestroyRWLock(rwlock: *mut SDL_RWLock);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Semaphore {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a semaphore.\n\n This function creates a new semaphore and initializes it with the value\n `initial_value`. Each wait operation on the semaphore will atomically\n decrement the semaphore value and potentially block if the semaphore value\n is 0. Each post operation will atomically increment the semaphore value and\n wake waiting threads and allow them to retry the wait operation.\n\n \\param initial_value the starting value of the semaphore\n \\returns a new semaphore or NULL on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_DestroySemaphore\n \\sa SDL_PostSemaphore\n \\sa SDL_TryWaitSemaphore\n \\sa SDL_GetSemaphoreValue\n \\sa SDL_WaitSemaphore\n \\sa SDL_WaitSemaphoreTimeout"]
    pub fn SDL_CreateSemaphore(initial_value: Uint32) -> *mut SDL_Semaphore;
}
extern "C" {
    #[doc = " Destroy a semaphore.\n\n It is not safe to destroy a semaphore if there are threads currently\n waiting on it.\n\n \\param sem the semaphore to destroy\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateSemaphore\n \\sa SDL_PostSemaphore\n \\sa SDL_TryWaitSemaphore\n \\sa SDL_GetSemaphoreValue\n \\sa SDL_WaitSemaphore\n \\sa SDL_WaitSemaphoreTimeout"]
    pub fn SDL_DestroySemaphore(sem: *mut SDL_Semaphore);
}
extern "C" {
    #[doc = " Wait until a semaphore has a positive value and then decrements it.\n\n This function suspends the calling thread until either the semaphore\n pointed to by `sem` has a positive value or the call is interrupted by a\n signal or error. If the call is successful it will atomically decrement the\n semaphore value.\n\n This function is the equivalent of calling SDL_WaitSemaphoreTimeout() with\n a time length of `SDL_MUTEX_MAXWAIT`.\n\n \\param sem the semaphore wait on\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateSemaphore\n \\sa SDL_DestroySemaphore\n \\sa SDL_PostSemaphore\n \\sa SDL_TryWaitSemaphore\n \\sa SDL_GetSemaphoreValue\n \\sa SDL_WaitSemaphore\n \\sa SDL_WaitSemaphoreTimeout"]
    pub fn SDL_WaitSemaphore(sem: *mut SDL_Semaphore) -> libc::c_int;
}
extern "C" {
    #[doc = " See if a semaphore has a positive value and decrement it if it does.\n\n This function checks to see if the semaphore pointed to by `sem` has a\n positive value and atomically decrements the semaphore value if it does. If\n the semaphore doesn't have a positive value, the function immediately\n returns SDL_MUTEX_TIMEDOUT.\n\n \\param sem the semaphore to wait on\n \\returns 0 if the wait succeeds, `SDL_MUTEX_TIMEDOUT` if the wait would\n          block, or a negative error code on failure; call SDL_GetError()\n          for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateSemaphore\n \\sa SDL_DestroySemaphore\n \\sa SDL_PostSemaphore\n \\sa SDL_GetSemaphoreValue\n \\sa SDL_WaitSemaphore\n \\sa SDL_WaitSemaphoreTimeout"]
    pub fn SDL_TryWaitSemaphore(sem: *mut SDL_Semaphore) -> libc::c_int;
}
extern "C" {
    #[doc = " Wait until a semaphore has a positive value and then decrements it.\n\n This function suspends the calling thread until either the semaphore\n pointed to by `sem` has a positive value, the call is interrupted by a\n signal or error, or the specified time has elapsed. If the call is\n successful it will atomically decrement the semaphore value.\n\n \\param sem the semaphore to wait on\n \\param timeoutMS the length of the timeout, in milliseconds\n \\returns 0 if the wait succeeds, `SDL_MUTEX_TIMEDOUT` if the wait does not\n          succeed in the allotted time, or a negative error code on failure;\n          call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateSemaphore\n \\sa SDL_DestroySemaphore\n \\sa SDL_PostSemaphore\n \\sa SDL_TryWaitSemaphore\n \\sa SDL_GetSemaphoreValue\n \\sa SDL_WaitSemaphore"]
    pub fn SDL_WaitSemaphoreTimeout(sem: *mut SDL_Semaphore, timeoutMS: Sint32) -> libc::c_int;
}
extern "C" {
    #[doc = " Atomically increment a semaphore's value and wake waiting threads.\n\n \\param sem the semaphore to increment\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateSemaphore\n \\sa SDL_DestroySemaphore\n \\sa SDL_TryWaitSemaphore\n \\sa SDL_GetSemaphoreValue\n \\sa SDL_WaitSemaphore\n \\sa SDL_WaitSemaphoreTimeout"]
    pub fn SDL_PostSemaphore(sem: *mut SDL_Semaphore) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the current value of a semaphore.\n\n \\param sem the semaphore to query\n \\returns the current value of the semaphore.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateSemaphore"]
    pub fn SDL_GetSemaphoreValue(sem: *mut SDL_Semaphore) -> Uint32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Condition {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a condition variable.\n\n \\returns a new condition variable or NULL on failure; call SDL_GetError()\n          for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_BroadcastCondition\n \\sa SDL_SignalCondition\n \\sa SDL_WaitCondition\n \\sa SDL_WaitConditionTimeout\n \\sa SDL_DestroyCondition"]
    pub fn SDL_CreateCondition() -> *mut SDL_Condition;
}
extern "C" {
    #[doc = " Destroy a condition variable.\n\n \\param cond the condition variable to destroy\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_BroadcastCondition\n \\sa SDL_SignalCondition\n \\sa SDL_WaitCondition\n \\sa SDL_WaitConditionTimeout\n \\sa SDL_CreateCondition"]
    pub fn SDL_DestroyCondition(cond: *mut SDL_Condition);
}
extern "C" {
    #[doc = " Restart one of the threads that are waiting on the condition variable.\n\n \\param cond the condition variable to signal\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_BroadcastCondition\n \\sa SDL_WaitCondition\n \\sa SDL_WaitConditionTimeout\n \\sa SDL_CreateCondition\n \\sa SDL_DestroyCondition"]
    pub fn SDL_SignalCondition(cond: *mut SDL_Condition) -> libc::c_int;
}
extern "C" {
    #[doc = " Restart all threads that are waiting on the condition variable.\n\n \\param cond the condition variable to signal\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SignalCondition\n \\sa SDL_WaitCondition\n \\sa SDL_WaitConditionTimeout\n \\sa SDL_CreateCondition\n \\sa SDL_DestroyCondition"]
    pub fn SDL_BroadcastCondition(cond: *mut SDL_Condition) -> libc::c_int;
}
extern "C" {
    #[doc = " Wait until a condition variable is signaled.\n\n This function unlocks the specified `mutex` and waits for another thread to\n call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition\n variable `cond`. Once the condition variable is signaled, the mutex is\n re-locked and the function returns.\n\n The mutex must be locked before calling this function. Locking the mutex\n recursively (more than once) is not supported and leads to undefined\n behavior.\n\n This function is the equivalent of calling SDL_WaitConditionTimeout() with\n a time length of `SDL_MUTEX_MAXWAIT`.\n\n \\param cond the condition variable to wait on\n \\param mutex the mutex used to coordinate thread access\n \\returns 0 when it is signaled or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_BroadcastCondition\n \\sa SDL_SignalCondition\n \\sa SDL_WaitConditionTimeout\n \\sa SDL_CreateCondition\n \\sa SDL_DestroyCondition"]
    pub fn SDL_WaitCondition(cond: *mut SDL_Condition, mutex: *mut SDL_Mutex) -> libc::c_int;
}
extern "C" {
    #[doc = " Wait until a condition variable is signaled or a certain time has passed.\n\n This function unlocks the specified `mutex` and waits for another thread to\n call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition\n variable `cond`, or for the specified time to elapse. Once the condition\n variable is signaled or the time elapsed, the mutex is re-locked and the\n function returns.\n\n The mutex must be locked before calling this function. Locking the mutex\n recursively (more than once) is not supported and leads to undefined\n behavior.\n\n \\param cond the condition variable to wait on\n \\param mutex the mutex used to coordinate thread access\n \\param timeoutMS the maximum time to wait, in milliseconds, or\n                  `SDL_MUTEX_MAXWAIT` to wait indefinitely\n \\returns 0 if the condition variable is signaled, `SDL_MUTEX_TIMEDOUT` if\n          the condition is not signaled in the allotted time, or a negative\n          error code on failure; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_BroadcastCondition\n \\sa SDL_SignalCondition\n \\sa SDL_WaitCondition\n \\sa SDL_CreateCondition\n \\sa SDL_DestroyCondition"]
    pub fn SDL_WaitConditionTimeout(
        cond: *mut SDL_Condition,
        mutex: *mut SDL_Mutex,
        timeoutMS: Sint32,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Thread {
    _unused: [u8; 0],
}
pub type SDL_threadID = libc::c_ulong;
pub type SDL_TLSID = libc::c_uint;
#[repr(u32)]
#[doc = "  The SDL thread priority.\n\n  SDL will make system changes as necessary in order to apply the thread priority.\n  Code which attempts to control thread state related to priority should be aware\n  that calling SDL_SetThreadPriority may alter such state.\n  SDL_HINT_THREAD_PRIORITY_POLICY can be used to control aspects of this behavior.\n\n  \\note On many systems you require special privileges to set high or time critical priority."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_ThreadPriority {
    SDL_THREAD_PRIORITY_LOW = 0,
    SDL_THREAD_PRIORITY_NORMAL = 1,
    SDL_THREAD_PRIORITY_HIGH = 2,
    SDL_THREAD_PRIORITY_TIME_CRITICAL = 3,
}
#[doc = " The function passed to SDL_CreateThread().\n\n \\param data what was passed as `data` to SDL_CreateThread()\n \\returns a value that can be reported through SDL_WaitThread()."]
pub type SDL_ThreadFunction =
    ::core::option::Option<unsafe extern "C" fn(data: *mut libc::c_void) -> libc::c_int>;
extern "C" {
    #[doc = " Create a new thread with a default stack size.\n\n This is equivalent to calling:\n\n ```c\n SDL_CreateThreadWithStackSize(fn, name, 0, data);\n ```\n\n \\param fn the SDL_ThreadFunction function to call in the new thread\n \\param name the name of the thread\n \\param data a pointer that is passed to `fn`\n \\returns an opaque pointer to the new thread object on success, NULL if the\n          new thread could not be created; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateThreadWithStackSize\n \\sa SDL_WaitThread"]
    pub fn SDL_CreateThread(
        fn_: SDL_ThreadFunction,
        name: *const libc::c_char,
        data: *mut libc::c_void,
    ) -> *mut SDL_Thread;
}
extern "C" {
    #[doc = " Create a new thread with a specific stack size.\n\n SDL makes an attempt to report `name` to the system, so that debuggers can\n display it. Not all platforms support this.\n\n Thread naming is a little complicated: Most systems have very small limits\n for the string length (Haiku has 32 bytes, Linux currently has 16, Visual\n C++ 6.0 has _nine_!), and possibly other arbitrary rules. You'll have to\n see what happens with your system's debugger. The name should be UTF-8 (but\n using the naming limits of C identifiers is a better bet). There are no\n requirements for thread naming conventions, so long as the string is\n null-terminated UTF-8, but these guidelines are helpful in choosing a name:\n\n https://stackoverflow.com/questions/149932/naming-conventions-for-threads\n\n If a system imposes requirements, SDL will try to munge the string for it\n (truncate, etc), but the original string contents will be available from\n SDL_GetThreadName().\n\n The size (in bytes) of the new stack can be specified. Zero means \"use the\n system default\" which might be wildly different between platforms. x86\n Linux generally defaults to eight megabytes, an embedded device might be a\n few kilobytes instead. You generally need to specify a stack that is a\n multiple of the system's page size (in many cases, this is 4 kilobytes, but\n check your system documentation).\n\n In SDL 2.1, stack size will be folded into the original SDL_CreateThread\n function, but for backwards compatibility, this is currently a separate\n function.\n\n \\param fn the SDL_ThreadFunction function to call in the new thread\n \\param name the name of the thread\n \\param stacksize the size, in bytes, to allocate for the new thread stack.\n \\param data a pointer that is passed to `fn`\n \\returns an opaque pointer to the new thread object on success, NULL if the\n          new thread could not be created; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_WaitThread"]
    pub fn SDL_CreateThreadWithStackSize(
        fn_: SDL_ThreadFunction,
        name: *const libc::c_char,
        stacksize: usize,
        data: *mut libc::c_void,
    ) -> *mut SDL_Thread;
}
extern "C" {
    #[doc = " Get the thread name as it was specified in SDL_CreateThread().\n\n This is internal memory, not to be freed by the caller, and remains valid\n until the specified thread is cleaned up by SDL_WaitThread().\n\n \\param thread the thread to query\n \\returns a pointer to a UTF-8 string that names the specified thread, or\n          NULL if it doesn't have a name.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateThread"]
    pub fn SDL_GetThreadName(thread: *mut SDL_Thread) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the thread identifier for the current thread.\n\n This thread identifier is as reported by the underlying operating system.\n If SDL is running on a platform that does not support threads the return\n value will always be zero.\n\n This function also returns a valid thread ID when called from the main\n thread.\n\n \\returns the ID of the current thread.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetThreadID"]
    pub fn SDL_ThreadID() -> SDL_threadID;
}
extern "C" {
    #[doc = " Get the thread identifier for the specified thread.\n\n This thread identifier is as reported by the underlying operating system.\n If SDL is running on a platform that does not support threads the return\n value will always be zero.\n\n \\param thread the thread to query\n \\returns the ID of the specified thread, or the ID of the current thread if\n          `thread` is NULL.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_ThreadID"]
    pub fn SDL_GetThreadID(thread: *mut SDL_Thread) -> SDL_threadID;
}
extern "C" {
    #[doc = " Set the priority for the current thread.\n\n Note that some platforms will not let you alter the priority (or at least,\n promote the thread to a higher priority) at all, and some require you to be\n an administrator account. Be prepared for this to fail.\n\n \\param priority the SDL_ThreadPriority to set\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_SetThreadPriority(priority: SDL_ThreadPriority) -> libc::c_int;
}
extern "C" {
    #[doc = " Wait for a thread to finish.\n\n Threads that haven't been detached will remain (as a \"zombie\") until this\n function cleans them up. Not doing so is a resource leak.\n\n Once a thread has been cleaned up through this function, the SDL_Thread\n that references it becomes invalid and should not be referenced again. As\n such, only one thread may call SDL_WaitThread() on another.\n\n The return code for the thread function is placed in the area pointed to by\n `status`, if `status` is not NULL.\n\n You may not wait on a thread that has been used in a call to\n SDL_DetachThread(). Use either that function or this one, but not both, or\n behavior is undefined.\n\n It is safe to pass a NULL thread to this function; it is a no-op.\n\n Note that the thread pointer is freed by this function and is not valid\n afterward.\n\n \\param thread the SDL_Thread pointer that was returned from the\n               SDL_CreateThread() call that started this thread\n \\param status pointer to an integer that will receive the value returned\n               from the thread function by its 'return', or NULL to not\n               receive such value back.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateThread\n \\sa SDL_DetachThread"]
    pub fn SDL_WaitThread(thread: *mut SDL_Thread, status: *mut libc::c_int);
}
extern "C" {
    #[doc = " Let a thread clean up on exit without intervention.\n\n A thread may be \"detached\" to signify that it should not remain until\n another thread has called SDL_WaitThread() on it. Detaching a thread is\n useful for long-running threads that nothing needs to synchronize with or\n further manage. When a detached thread is done, it simply goes away.\n\n There is no way to recover the return code of a detached thread. If you\n need this, don't detach the thread and instead use SDL_WaitThread().\n\n Once a thread is detached, you should usually assume the SDL_Thread isn't\n safe to reference again, as it will become invalid immediately upon the\n detached thread's exit, instead of remaining until someone has called\n SDL_WaitThread() to finally clean it up. As such, don't detach the same\n thread more than once.\n\n If a thread has already exited when passed to SDL_DetachThread(), it will\n stop waiting for a call to SDL_WaitThread() and clean up immediately. It is\n not safe to detach a thread that might be used with SDL_WaitThread().\n\n You may not call SDL_WaitThread() on a thread that has been detached. Use\n either that function or this one, but not both, or behavior is undefined.\n\n It is safe to pass NULL to this function; it is a no-op.\n\n \\param thread the SDL_Thread pointer that was returned from the\n               SDL_CreateThread() call that started this thread\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateThread\n \\sa SDL_WaitThread"]
    pub fn SDL_DetachThread(thread: *mut SDL_Thread);
}
extern "C" {
    #[doc = " Create a piece of thread-local storage.\n\n This creates an identifier that is globally visible to all threads but\n refers to data that is thread-specific.\n\n \\returns the newly created thread local storage identifier or 0 on error.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetTLS\n \\sa SDL_SetTLS"]
    pub fn SDL_CreateTLS() -> SDL_TLSID;
}
extern "C" {
    #[doc = " Get the current thread's value associated with a thread local storage ID.\n\n \\param id the thread local storage ID\n \\returns the value associated with the ID for the current thread or NULL if\n          no value has been set; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateTLS\n \\sa SDL_SetTLS"]
    pub fn SDL_GetTLS(id: SDL_TLSID) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Set the current thread's value associated with a thread local storage ID.\n\n The function prototype for `destructor` is:\n\n ```c\n void destructor(void *value)\n ```\n\n where its parameter `value` is what was passed as `value` to SDL_SetTLS().\n\n \\param id the thread local storage ID\n \\param value the value to associate with the ID for the current thread\n \\param destructor a function called when the thread exits, to free the\n                   value\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateTLS\n \\sa SDL_GetTLS"]
    pub fn SDL_SetTLS(
        id: SDL_TLSID,
        value: *const libc::c_void,
        destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Cleanup all TLS data for this thread.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_CleanupTLS();
}
#[doc = " This is the read/write operation structure -- very basic."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_RWops {
    #[doc = "  Return the size of the file in this rwops, or -1 if unknown"]
    pub size: ::core::option::Option<unsafe extern "C" fn(context: *mut SDL_RWops) -> Sint64>,
    #[doc = "  Seek to \\c offset relative to \\c whence, one of stdio's whence values:\n  SDL_RW_SEEK_SET, SDL_RW_SEEK_CUR, SDL_RW_SEEK_END\n\n  \\return the final offset in the data stream, or -1 on error."]
    pub seek: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut SDL_RWops,
            offset: Sint64,
            whence: libc::c_int,
        ) -> Sint64,
    >,
    #[doc = "  Read up to \\c size bytes from the data stream to the area pointed\n  at by \\c ptr.\n\n  It is an error to use a negative \\c size, but this parameter is\n  signed so you definitely cannot overflow the return value on a\n  successful run with enormous amounts of data.\n\n  \\return the number of objects read, or 0 on end of file, or -1 on error."]
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut SDL_RWops,
            ptr: *mut libc::c_void,
            size: Sint64,
        ) -> Sint64,
    >,
    #[doc = "  Write exactly \\c size bytes from the area pointed at by \\c ptr\n  to data stream. May write less than requested (error, non-blocking i/o,\n  etc). Returns -1 on error when nothing was written.\n\n  It is an error to use a negative \\c size, but this parameter is\n  signed so you definitely cannot overflow the return value on a\n  successful run with enormous amounts of data.\n\n  \\return the number of bytes written, which might be less than \\c size,\n          and -1 on error."]
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut SDL_RWops,
            ptr: *const libc::c_void,
            size: Sint64,
        ) -> Sint64,
    >,
    #[doc = "  Close and free an allocated SDL_RWops structure.\n\n  \\return 0 if successful or -1 on write error when flushing data."]
    pub close: ::core::option::Option<unsafe extern "C" fn(context: *mut SDL_RWops) -> libc::c_int>,
    pub type_: Uint32,
    pub hidden: SDL_RWops__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_RWops__bindgen_ty_1 {
    pub stdio: SDL_RWops__bindgen_ty_1__bindgen_ty_1,
    pub mem: SDL_RWops__bindgen_ty_1__bindgen_ty_2,
    pub unknown: SDL_RWops__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_1 {
    pub autoclose: SDL_bool,
    pub fp: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_RWops__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).autoclose) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(autoclose)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(fp)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_2 {
    pub base: *mut Uint8,
    pub here: *mut Uint8,
    pub stop: *mut Uint8,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_RWops__bindgen_ty_1__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).here) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(here)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(stop)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_3 {
    pub data1: *mut libc::c_void,
    pub data2: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_RWops__bindgen_ty_1__bindgen_ty_3> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(data1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(data2)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_RWops__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_RWops__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_RWops__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_RWops__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_RWops__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stdio) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1),
            "::",
            stringify!(stdio)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mem) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unknown) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1),
            "::",
            stringify!(unknown)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_RWops() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_RWops> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_RWops>(),
        72usize,
        concat!("Size of: ", stringify!(SDL_RWops))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_RWops>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_RWops))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hidden) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(hidden)
        )
    );
}
extern "C" {
    #[doc = " Use this function to create a new SDL_RWops structure for reading from\n and/or writing to a named file.\n\n The `mode` string is treated roughly the same as in a call to the C\n library's fopen(), even if SDL doesn't happen to use fopen() behind the\n scenes.\n\n Available `mode` strings:\n\n - \"r\": Open a file for reading. The file must exist.\n - \"w\": Create an empty file for writing. If a file with the same name\n   already exists its content is erased and the file is treated as a new\n   empty file.\n - \"a\": Append to a file. Writing operations append data at the end of the\n   file. The file is created if it does not exist.\n - \"r+\": Open a file for update both reading and writing. The file must\n   exist.\n - \"w+\": Create an empty file for both reading and writing. If a file with\n   the same name already exists its content is erased and the file is\n   treated as a new empty file.\n - \"a+\": Open a file for reading and appending. All writing operations are\n   performed at the end of the file, protecting the previous content to be\n   overwritten. You can reposition (fseek, rewind) the internal pointer to\n   anywhere in the file for reading, but writing operations will move it\n   back to the end of file. The file is created if it does not exist.\n\n **NOTE**: In order to open a file as a binary file, a \"b\" character has to\n be included in the `mode` string. This additional \"b\" character can either\n be appended at the end of the string (thus making the following compound\n modes: \"rb\", \"wb\", \"ab\", \"r+b\", \"w+b\", \"a+b\") or be inserted between the\n letter and the \"+\" sign for the mixed modes (\"rb+\", \"wb+\", \"ab+\").\n Additional characters may follow the sequence, although they should have no\n effect. For example, \"t\" is sometimes appended to make explicit the file is\n a text file.\n\n This function supports Unicode filenames, but they must be encoded in UTF-8\n format, regardless of the underlying operating system.\n\n As a fallback, SDL_RWFromFile() will transparently open a matching filename\n in an Android app's `assets`.\n\n Closing the SDL_RWops will close the file handle SDL is holding internally.\n\n \\param file a UTF-8 string representing the filename to open\n \\param mode an ASCII string representing the mode to be used for opening\n             the file.\n \\returns a pointer to the SDL_RWops structure that is created, or NULL on\n          failure; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_RWclose\n \\sa SDL_RWFromConstMem\n \\sa SDL_RWFromMem\n \\sa SDL_RWread\n \\sa SDL_RWseek\n \\sa SDL_RWtell\n \\sa SDL_RWwrite"]
    pub fn SDL_RWFromFile(file: *const libc::c_char, mode: *const libc::c_char) -> *mut SDL_RWops;
}
extern "C" {
    #[doc = " Use this function to prepare a read-write memory buffer for use with\n SDL_RWops.\n\n This function sets up an SDL_RWops struct based on a memory area of a\n certain size, for both read and write access.\n\n This memory buffer is not copied by the RWops; the pointer you provide must\n remain valid until you close the stream. Closing the stream will not free\n the original buffer.\n\n If you need to make sure the RWops never writes to the memory buffer, you\n should use SDL_RWFromConstMem() with a read-only buffer of memory instead.\n\n \\param mem a pointer to a buffer to feed an SDL_RWops stream\n \\param size the buffer size, in bytes\n \\returns a pointer to a new SDL_RWops structure, or NULL if it fails; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_RWclose\n \\sa SDL_RWFromConstMem\n \\sa SDL_RWFromFile\n \\sa SDL_RWFromMem\n \\sa SDL_RWread\n \\sa SDL_RWseek\n \\sa SDL_RWtell\n \\sa SDL_RWwrite"]
    pub fn SDL_RWFromMem(mem: *mut libc::c_void, size: usize) -> *mut SDL_RWops;
}
extern "C" {
    #[doc = " Use this function to prepare a read-only memory buffer for use with RWops.\n\n This function sets up an SDL_RWops struct based on a memory area of a\n certain size. It assumes the memory area is not writable.\n\n Attempting to write to this RWops stream will report an error without\n writing to the memory buffer.\n\n This memory buffer is not copied by the RWops; the pointer you provide must\n remain valid until you close the stream. Closing the stream will not free\n the original buffer.\n\n If you need to write to a memory buffer, you should use SDL_RWFromMem()\n with a writable buffer of memory instead.\n\n \\param mem a pointer to a read-only buffer to feed an SDL_RWops stream\n \\param size the buffer size, in bytes\n \\returns a pointer to a new SDL_RWops structure, or NULL if it fails; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_RWclose\n \\sa SDL_RWFromConstMem\n \\sa SDL_RWFromFile\n \\sa SDL_RWFromMem\n \\sa SDL_RWread\n \\sa SDL_RWseek\n \\sa SDL_RWtell"]
    pub fn SDL_RWFromConstMem(mem: *const libc::c_void, size: usize) -> *mut SDL_RWops;
}
extern "C" {
    #[doc = " Use this function to allocate an empty, unpopulated SDL_RWops structure.\n\n Applications do not need to use this function unless they are providing\n their own SDL_RWops implementation. If you just need a SDL_RWops to\n read/write a common data source, you should use the built-in\n implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc.\n\n You must free the returned pointer with SDL_DestroyRW(). Depending on your\n operating system and compiler, there may be a difference between the\n malloc() and free() your program uses and the versions SDL calls\n internally. Trying to mix the two can cause crashing such as segmentation\n faults. Since all SDL_RWops must free themselves when their **close**\n method is called, all SDL_RWops must be allocated through this function, so\n they can all be freed correctly with SDL_DestroyRW().\n\n \\returns a pointer to the allocated memory on success, or NULL on failure;\n          call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_DestroyRW"]
    pub fn SDL_CreateRW() -> *mut SDL_RWops;
}
extern "C" {
    #[doc = " Use this function to free an SDL_RWops structure allocated by\n SDL_CreateRW().\n\n Applications do not need to use this function unless they are providing\n their own SDL_RWops implementation. If you just need a SDL_RWops to\n read/write a common data source, you should use the built-in\n implementations in SDL, like SDL_RWFromFile() or SDL_RWFromMem(), etc, and\n call the **close** method on those SDL_RWops pointers when you are done\n with them.\n\n Only use SDL_DestroyRW() on pointers returned by SDL_CreateRW(). The\n pointer is invalid as soon as this function returns. Any extra memory\n allocated during creation of the SDL_RWops is not freed by SDL_DestroyRW();\n the programmer must be responsible for managing that memory in their\n **close** method.\n\n \\param area the SDL_RWops structure to be freed\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateRW"]
    pub fn SDL_DestroyRW(area: *mut SDL_RWops);
}
extern "C" {
    #[doc = " Use this function to get the size of the data stream in an SDL_RWops.\n\n Prior to SDL 2.0.10, this function was a macro.\n\n \\param context the SDL_RWops to get the size of the data stream from\n \\returns the size of the data stream in the SDL_RWops on success, -1 if\n          unknown or a negative error code on failure; call SDL_GetError()\n          for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_RWsize(context: *mut SDL_RWops) -> Sint64;
}
extern "C" {
    #[doc = " Seek within an SDL_RWops data stream.\n\n This function seeks to byte `offset`, relative to `whence`.\n\n `whence` may be any of the following values:\n\n - `SDL_RW_SEEK_SET`: seek from the beginning of data\n - `SDL_RW_SEEK_CUR`: seek relative to current read point\n - `SDL_RW_SEEK_END`: seek relative to the end of data\n\n If this stream can not seek, it will return -1.\n\n SDL_RWseek() is actually a wrapper function that calls the SDL_RWops's\n `seek` method appropriately, to simplify application development.\n\n Prior to SDL 2.0.10, this function was a macro.\n\n \\param context a pointer to an SDL_RWops structure\n \\param offset an offset in bytes, relative to **whence** location; can be\n               negative\n \\param whence any of `SDL_RW_SEEK_SET`, `SDL_RW_SEEK_CUR`,\n               `SDL_RW_SEEK_END`\n \\returns the final offset in the data stream after the seek or -1 on error.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_RWclose\n \\sa SDL_RWFromConstMem\n \\sa SDL_RWFromFile\n \\sa SDL_RWFromMem\n \\sa SDL_RWread\n \\sa SDL_RWtell\n \\sa SDL_RWwrite"]
    pub fn SDL_RWseek(context: *mut SDL_RWops, offset: Sint64, whence: libc::c_int) -> Sint64;
}
extern "C" {
    #[doc = " Determine the current read/write offset in an SDL_RWops data stream.\n\n SDL_RWtell is actually a wrapper function that calls the SDL_RWops's `seek`\n method, with an offset of 0 bytes from `SDL_RW_SEEK_CUR`, to simplify\n application development.\n\n Prior to SDL 2.0.10, this function was a macro.\n\n \\param context a SDL_RWops data stream object from which to get the current\n                offset\n \\returns the current offset in the stream, or -1 if the information can not\n          be determined.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_RWclose\n \\sa SDL_RWFromConstMem\n \\sa SDL_RWFromFile\n \\sa SDL_RWFromMem\n \\sa SDL_RWread\n \\sa SDL_RWseek\n \\sa SDL_RWwrite"]
    pub fn SDL_RWtell(context: *mut SDL_RWops) -> Sint64;
}
extern "C" {
    #[doc = " Read from a data source.\n\n This function reads up `size` bytes from the data source to the area\n pointed at by `ptr`. This function may read less bytes than requested. It\n will return zero when the data stream is completely read, or -1 on error.\n For streams that support non-blocking operation, if nothing was read\n because it would require blocking, this function returns -2 to distinguish\n that this is not an error or end-of-file, and the caller can try again\n later.\n\n SDL_RWread() is actually a function wrapper that calls the SDL_RWops's\n `read` method appropriately, to simplify application development.\n\n It is an error to specify a negative `size`, but this parameter is signed\n so you definitely cannot overflow the return value on a successful run with\n enormous amounts of data.\n\n \\param context a pointer to an SDL_RWops structure\n \\param ptr a pointer to a buffer to read data into\n \\param size the number of bytes to read from the data source.\n \\returns the number of bytes read, 0 at end of file, -1 on error, and -2\n          for data not ready with a non-blocking context.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_RWclose\n \\sa SDL_RWFromConstMem\n \\sa SDL_RWFromFile\n \\sa SDL_RWFromMem\n \\sa SDL_RWseek\n \\sa SDL_RWwrite"]
    pub fn SDL_RWread(context: *mut SDL_RWops, ptr: *mut libc::c_void, size: Sint64) -> Sint64;
}
extern "C" {
    #[doc = " Write to an SDL_RWops data stream.\n\n This function writes exactly `size` bytes from the area pointed at by `ptr`\n to the stream. If this fails for any reason, it'll return less than `size`\n to demonstrate how far the write progressed. On success, it returns `num`.\n\n On error, this function still attempts to write as much as possible, so it\n might return a positive value less than the requested write size. If the\n function failed to write anything and there was an actual error, it will\n return -1. For streams that support non-blocking operation, if nothing was\n written because it would require blocking, this function returns -2 to\n distinguish that this is not an error and the caller can try again later.\n\n SDL_RWwrite is actually a function wrapper that calls the SDL_RWops's\n `write` method appropriately, to simplify application development.\n\n It is an error to specify a negative `size`, but this parameter is signed\n so you definitely cannot overflow the return value on a successful run with\n enormous amounts of data.\n\n \\param context a pointer to an SDL_RWops structure\n \\param ptr a pointer to a buffer containing data to write\n \\param size the number of bytes to write\n \\returns the number of bytes written, which will be less than `num` on\n          error; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_RWclose\n \\sa SDL_RWFromConstMem\n \\sa SDL_RWFromFile\n \\sa SDL_RWFromMem\n \\sa SDL_RWread\n \\sa SDL_RWseek"]
    pub fn SDL_RWwrite(context: *mut SDL_RWops, ptr: *const libc::c_void, size: Sint64) -> Sint64;
}
extern "C" {
    #[doc = " Close and free an allocated SDL_RWops structure.\n\n SDL_RWclose() closes and cleans up the SDL_RWops stream. It releases any\n resources used by the stream and frees the SDL_RWops itself with\n SDL_DestroyRW(). This returns 0 on success, or -1 if the stream failed to\n flush to its output (e.g. to disk).\n\n Note that if this fails to flush the stream to disk, this function reports\n an error, but the SDL_RWops is still invalid once this function returns.\n\n Prior to SDL 2.0.10, this function was a macro.\n\n \\param context SDL_RWops structure to close\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_RWFromConstMem\n \\sa SDL_RWFromFile\n \\sa SDL_RWFromMem\n \\sa SDL_RWread\n \\sa SDL_RWseek\n \\sa SDL_RWwrite"]
    pub fn SDL_RWclose(context: *mut SDL_RWops) -> libc::c_int;
}
extern "C" {
    #[doc = " Load all the data from an SDL data stream.\n\n The data is allocated with a zero byte at the end (null terminated) for\n convenience. This extra byte is not included in the value reported via\n `datasize`.\n\n The data should be freed with SDL_free().\n\n \\param src the SDL_RWops to read all available data from\n \\param datasize if not NULL, will store the number of bytes read\n \\param freesrc if SDL_TRUE, calls SDL_RWclose() on `src` before returning,\n                even in the case of an error\n \\returns the data, or NULL if there was an error.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_LoadFile_RW(
        src: *mut SDL_RWops,
        datasize: *mut usize,
        freesrc: SDL_bool,
    ) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Load all the data from a file path.\n\n The data is allocated with a zero byte at the end (null terminated) for\n convenience. This extra byte is not included in the value reported via\n `datasize`.\n\n The data should be freed with SDL_free().\n\n Prior to SDL 2.0.10, this function was a macro wrapping around\n SDL_LoadFile_RW.\n\n \\param file the path to read all available data from\n \\param datasize if not NULL, will store the number of bytes read\n \\returns the data, or NULL if there was an error.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_LoadFile(file: *const libc::c_char, datasize: *mut usize) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Use this function to read a byte from an SDL_RWops.\n\n \\param src the SDL_RWops to read from\n \\returns the read byte on success or 0 on failure; call SDL_GetError() for\n          more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_WriteU8"]
    pub fn SDL_ReadU8(src: *mut SDL_RWops) -> Uint8;
}
extern "C" {
    #[doc = " Use this function to read 16 bits of little-endian data from an SDL_RWops\n and return in native format.\n\n SDL byteswaps the data only if necessary, so the data returned will be in\n the native byte order.\n\n \\param src the stream from which to read data\n \\returns 16 bits of data in the native byte order of the platform.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_ReadBE16"]
    pub fn SDL_ReadLE16(src: *mut SDL_RWops) -> Uint16;
}
extern "C" {
    #[doc = " Use this function to read 16 bits of big-endian data from an SDL_RWops and\n return in native format.\n\n SDL byteswaps the data only if necessary, so the data returned will be in\n the native byte order.\n\n \\param src the stream from which to read data\n \\returns 16 bits of data in the native byte order of the platform.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_ReadLE16"]
    pub fn SDL_ReadBE16(src: *mut SDL_RWops) -> Uint16;
}
extern "C" {
    #[doc = " Use this function to read 32 bits of little-endian data from an SDL_RWops\n and return in native format.\n\n SDL byteswaps the data only if necessary, so the data returned will be in\n the native byte order.\n\n \\param src the stream from which to read data\n \\returns 32 bits of data in the native byte order of the platform.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_ReadBE32"]
    pub fn SDL_ReadLE32(src: *mut SDL_RWops) -> Uint32;
}
extern "C" {
    #[doc = " Use this function to read 32 bits of big-endian data from an SDL_RWops and\n return in native format.\n\n SDL byteswaps the data only if necessary, so the data returned will be in\n the native byte order.\n\n \\param src the stream from which to read data\n \\returns 32 bits of data in the native byte order of the platform.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_ReadLE32"]
    pub fn SDL_ReadBE32(src: *mut SDL_RWops) -> Uint32;
}
extern "C" {
    #[doc = " Use this function to read 64 bits of little-endian data from an SDL_RWops\n and return in native format.\n\n SDL byteswaps the data only if necessary, so the data returned will be in\n the native byte order.\n\n \\param src the stream from which to read data\n \\returns 64 bits of data in the native byte order of the platform.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_ReadBE64"]
    pub fn SDL_ReadLE64(src: *mut SDL_RWops) -> Uint64;
}
extern "C" {
    #[doc = " Use this function to read 64 bits of big-endian data from an SDL_RWops and\n return in native format.\n\n SDL byteswaps the data only if necessary, so the data returned will be in\n the native byte order.\n\n \\param src the stream from which to read data\n \\returns 64 bits of data in the native byte order of the platform.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_ReadLE64"]
    pub fn SDL_ReadBE64(src: *mut SDL_RWops) -> Uint64;
}
extern "C" {
    #[doc = " Use this function to write a byte to an SDL_RWops.\n\n \\param dst the SDL_RWops to write to\n \\param value the byte value to write\n \\returns 1 on success or 0 on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_ReadU8"]
    pub fn SDL_WriteU8(dst: *mut SDL_RWops, value: Uint8) -> usize;
}
extern "C" {
    #[doc = " Use this function to write 16 bits in native format to a SDL_RWops as\n little-endian data.\n\n SDL byteswaps the data only if necessary, so the application always\n specifies native format, and the data written will be in little-endian\n format.\n\n \\param dst the stream to which data will be written\n \\param value the data to be written, in native format\n \\returns 1 on successful write, 0 on error.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_WriteBE16"]
    pub fn SDL_WriteLE16(dst: *mut SDL_RWops, value: Uint16) -> usize;
}
extern "C" {
    #[doc = " Use this function to write 16 bits in native format to a SDL_RWops as\n big-endian data.\n\n SDL byteswaps the data only if necessary, so the application always\n specifies native format, and the data written will be in big-endian format.\n\n \\param dst the stream to which data will be written\n \\param value the data to be written, in native format\n \\returns 1 on successful write, 0 on error.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_WriteLE16"]
    pub fn SDL_WriteBE16(dst: *mut SDL_RWops, value: Uint16) -> usize;
}
extern "C" {
    #[doc = " Use this function to write 32 bits in native format to a SDL_RWops as\n little-endian data.\n\n SDL byteswaps the data only if necessary, so the application always\n specifies native format, and the data written will be in little-endian\n format.\n\n \\param dst the stream to which data will be written\n \\param value the data to be written, in native format\n \\returns 1 on successful write, 0 on error.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_WriteBE32"]
    pub fn SDL_WriteLE32(dst: *mut SDL_RWops, value: Uint32) -> usize;
}
extern "C" {
    #[doc = " Use this function to write 32 bits in native format to a SDL_RWops as\n big-endian data.\n\n SDL byteswaps the data only if necessary, so the application always\n specifies native format, and the data written will be in big-endian format.\n\n \\param dst the stream to which data will be written\n \\param value the data to be written, in native format\n \\returns 1 on successful write, 0 on error.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_WriteLE32"]
    pub fn SDL_WriteBE32(dst: *mut SDL_RWops, value: Uint32) -> usize;
}
extern "C" {
    #[doc = " Use this function to write 64 bits in native format to a SDL_RWops as\n little-endian data.\n\n SDL byteswaps the data only if necessary, so the application always\n specifies native format, and the data written will be in little-endian\n format.\n\n \\param dst the stream to which data will be written\n \\param value the data to be written, in native format\n \\returns 1 on successful write, 0 on error.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_WriteBE64"]
    pub fn SDL_WriteLE64(dst: *mut SDL_RWops, value: Uint64) -> usize;
}
extern "C" {
    #[doc = " Use this function to write 64 bits in native format to a SDL_RWops as\n big-endian data.\n\n SDL byteswaps the data only if necessary, so the application always\n specifies native format, and the data written will be in big-endian format.\n\n \\param dst the stream to which data will be written\n \\param value the data to be written, in native format\n \\returns 1 on successful write, 0 on error.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_WriteLE64"]
    pub fn SDL_WriteBE64(dst: *mut SDL_RWops, value: Uint64) -> usize;
}
#[doc = "  \\brief Audio format flags.\n\n  These are what the 16 bits in SDL_AudioFormat currently mean...\n  (Unspecified bits are always zero).\n\n  \\verbatim\n++-----------------------sample is signed if set\n||\n||       ++-----------sample is bigendian if set\n||       ||\n||       ||          ++---sample is float if set\n||       ||          ||\n||       ||          || +---sample bit size---+\n||       ||          || |                     |\n15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n\\endverbatim\n\n  There are macros in SDL 2.0 and later to query these bits."]
pub type SDL_AudioFormat = Uint16;
#[doc = "  This function is called when the audio device needs more data.\n\n  \\param userdata An application-specific parameter saved in\n                  the SDL_AudioSpec structure\n  \\param stream A pointer to the audio data buffer.\n  \\param len    The length of that buffer in bytes.\n\n  Once the callback returns, the buffer will no longer be valid.\n  Stereo samples are stored in a LRLRLR ordering.\n\n  You can choose to avoid callbacks and use SDL_QueueAudio() instead, if\n  you like. Just open your audio device with a NULL callback."]
pub type SDL_AudioCallback = ::core::option::Option<
    unsafe extern "C" fn(userdata: *mut libc::c_void, stream: *mut Uint8, len: libc::c_int),
>;
#[doc = "  The calculated values in this structure are calculated by SDL_OpenAudioDevice().\n\n  For multi-channel audio, the default SDL channel mapping is:\n  2:  FL  FR                          (stereo)\n  3:  FL  FR LFE                      (2.1 surround)\n  4:  FL  FR  BL  BR                  (quad)\n  5:  FL  FR LFE  BL  BR              (4.1 surround)\n  6:  FL  FR  FC LFE  SL  SR          (5.1 surround - last two can also be BL BR)\n  7:  FL  FR  FC LFE  BC  SL  SR      (6.1 surround)\n  8:  FL  FR  FC LFE  BL  BR  SL  SR  (7.1 surround)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_AudioSpec {
    #[doc = "< DSP frequency -- samples per second"]
    pub freq: libc::c_int,
    #[doc = "< Audio data format"]
    pub format: SDL_AudioFormat,
    #[doc = "< Number of channels: 1 mono, 2 stereo"]
    pub channels: Uint8,
    #[doc = "< Audio buffer silence value (calculated)"]
    pub silence: Uint8,
    #[doc = "< Audio buffer size in sample FRAMES (total samples divided by channel count)"]
    pub samples: Uint16,
    #[doc = "< Necessary for some compile environments"]
    pub padding: Uint16,
    #[doc = "< Audio buffer size in bytes (calculated)"]
    pub size: Uint32,
    #[doc = "< Callback that feeds the audio device (NULL to use SDL_QueueAudio())."]
    pub callback: SDL_AudioCallback,
    #[doc = "< Userdata passed to callback (ignored for NULL callbacks)."]
    pub userdata: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_AudioSpec() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_AudioSpec> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_AudioSpec>(),
        32usize,
        concat!("Size of: ", stringify!(SDL_AudioSpec))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_AudioSpec>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_AudioSpec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).freq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).silence) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(silence)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).samples) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(samples)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).userdata) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(userdata)
        )
    );
}
extern "C" {
    #[doc = " Use this function to get the number of built-in audio drivers.\n\n This function returns a hardcoded number. This never returns a negative\n value; if there are no drivers compiled into this build of SDL, this\n function returns zero. The presence of a driver in this list does not mean\n it will function, it just means SDL is capable of interacting with that\n interface. For example, a build of SDL might have esound support, but if\n there's no esound server available, SDL's esound driver would fail if used.\n\n By default, SDL tries all drivers, in its preferred order, until one is\n found to be usable.\n\n \\returns the number of built-in audio drivers.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetAudioDriver"]
    pub fn SDL_GetNumAudioDrivers() -> libc::c_int;
}
extern "C" {
    #[doc = " Use this function to get the name of a built in audio driver.\n\n The list of audio drivers is given in the order that they are normally\n initialized by default; the drivers that seem more reasonable to choose\n first (as far as the SDL developers believe) are earlier in the list.\n\n The names of drivers are all simple, low-ASCII identifiers, like \"alsa\",\n \"coreaudio\" or \"xaudio2\". These never have Unicode characters, and are not\n meant to be proper names.\n\n \\param index the index of the audio driver; the value ranges from 0 to\n              SDL_GetNumAudioDrivers() - 1\n \\returns the name of the audio driver at the requested index, or NULL if an\n          invalid index was specified.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetNumAudioDrivers"]
    pub fn SDL_GetAudioDriver(index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the name of the current audio driver.\n\n The returned string points to internal static memory and thus never becomes\n invalid, even if you quit the audio subsystem and initialize a new driver\n (although such a case would return a different static string from another\n call to this function, of course). As such, you should not modify or free\n the returned string.\n\n \\returns the name of the current audio driver or NULL if no driver has been\n          initialized.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetCurrentAudioDriver() -> *const libc::c_char;
}
#[doc = "  SDL Audio Device IDs."]
pub type SDL_AudioDeviceID = Uint32;
extern "C" {
    #[doc = " Get the number of built-in audio devices.\n\n This function is only valid after successfully initializing the audio\n subsystem.\n\n Note that audio capture support is not implemented as of SDL 2.0.4, so the\n `iscapture` parameter is for future expansion and should always be zero for\n now.\n\n This function will return -1 if an explicit list of devices can't be\n determined. Returning -1 is not an error. For example, if SDL is set up to\n talk to a remote audio server, it can't list every one available on the\n Internet, but it will still allow a specific host to be specified in\n SDL_OpenAudioDevice().\n\n In many common cases, when this function returns a value <= 0, it can still\n successfully open the default device (NULL for first argument of\n SDL_OpenAudioDevice()).\n\n This function may trigger a complete redetect of available hardware. It\n should not be called for each iteration of a loop, but rather once at the\n start of a loop:\n\n ```c\n // Don't do this:\n for (int i = 0; i < SDL_GetNumAudioDevices(0); i++)\n\n // do this instead:\n const int count = SDL_GetNumAudioDevices(0);\n for (int i = 0; i < count; ++i) { do_something_here(); }\n ```\n\n \\param iscapture zero to request playback devices, non-zero to request\n                  recording devices\n \\returns the number of available devices exposed by the current driver or\n          -1 if an explicit list of devices can't be determined. A return\n          value of -1 does not necessarily mean an error condition.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetAudioDeviceName\n \\sa SDL_OpenAudioDevice"]
    pub fn SDL_GetNumAudioDevices(iscapture: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the human-readable name of a specific audio device.\n\n This function is only valid after successfully initializing the audio\n subsystem. The values returned by this function reflect the latest call to\n SDL_GetNumAudioDevices(); re-call that function to redetect available\n hardware.\n\n The string returned by this function is UTF-8 encoded, read-only, and\n managed internally. You are not to free it. If you need to keep the string\n for any length of time, you should make your own copy of it, as it will be\n invalid next time any of several other SDL functions are called.\n\n \\param index the index of the audio device; valid values range from 0 to\n              SDL_GetNumAudioDevices() - 1\n \\param iscapture non-zero to query the list of recording devices, zero to\n                  query the list of output devices.\n \\returns the name of the audio device at the requested index, or NULL on\n          error.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetNumAudioDevices\n \\sa SDL_GetDefaultAudioInfo"]
    pub fn SDL_GetAudioDeviceName(
        index: libc::c_int,
        iscapture: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the preferred audio format of a specific audio device.\n\n This function is only valid after a successfully initializing the audio\n subsystem. The values returned by this function reflect the latest call to\n SDL_GetNumAudioDevices(); re-call that function to redetect available\n hardware.\n\n `spec` will be filled with the sample rate, sample format, and channel\n count.\n\n \\param index the index of the audio device; valid values range from 0 to\n              SDL_GetNumAudioDevices() - 1\n \\param iscapture non-zero to query the list of recording devices, zero to\n                  query the list of output devices.\n \\param spec The SDL_AudioSpec to be initialized by this function.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetNumAudioDevices\n \\sa SDL_GetDefaultAudioInfo"]
    pub fn SDL_GetAudioDeviceSpec(
        index: libc::c_int,
        iscapture: libc::c_int,
        spec: *mut SDL_AudioSpec,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the name and preferred format of the default audio device.\n\n Some (but not all!) platforms have an isolated mechanism to get information\n about the \"default\" device. This can actually be a completely different\n device that's not in the list you get from SDL_GetAudioDeviceSpec(). It can\n even be a network address! (This is discussed in SDL_OpenAudioDevice().)\n\n As a result, this call is not guaranteed to be performant, as it can query\n the sound server directly every time, unlike the other query functions. You\n should call this function sparingly!\n\n `spec` will be filled with the sample rate, sample format, and channel\n count, if a default device exists on the system. If `name` is provided,\n will be filled with either a dynamically-allocated UTF-8 string or NULL.\n\n \\param name A pointer to be filled with the name of the default device (can\n             be NULL). Please call SDL_free() when you are done with this\n             pointer!\n \\param spec The SDL_AudioSpec to be initialized by this function.\n \\param iscapture non-zero to query the default recording device, zero to\n                  query the default output device.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetAudioDeviceName\n \\sa SDL_GetAudioDeviceSpec\n \\sa SDL_OpenAudioDevice"]
    pub fn SDL_GetDefaultAudioInfo(
        name: *mut *mut libc::c_char,
        spec: *mut SDL_AudioSpec,
        iscapture: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Open a specific audio device.\n\n Passing in a `device` name of NULL requests the most reasonable default.\n The `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(),\n but some drivers allow arbitrary and driver-specific strings, such as a\n hostname/IP address for a remote audio server, or a filename in the\n diskaudio driver.\n\n An opened audio device starts out paused, and should be enabled for playing\n by calling SDL_PlayAudioDevice(devid) when you are ready for your audio\n callback function to be called. Since the audio driver may modify the\n requested size of the audio buffer, you should allocate any local mixing\n buffers after you open the audio device.\n\n The audio callback runs in a separate thread in most cases; you can prevent\n race conditions between your callback and other threads without fully\n pausing playback with SDL_LockAudioDevice(). For more information about the\n callback, see SDL_AudioSpec.\n\n Managing the audio spec via 'desired' and 'obtained':\n\n When filling in the desired audio spec structure:\n\n - `desired->freq` should be the frequency in sample-frames-per-second (Hz).\n - `desired->format` should be the audio format (`SDL_AUDIO_S16SYS`, etc).\n - `desired->samples` is the desired size of the audio buffer, in _sample\n   frames_ (with stereo output, two samples--left and right--would make a\n   single sample frame). This number should be a power of two, and may be\n   adjusted by the audio driver to a value more suitable for the hardware.\n   Good values seem to range between 512 and 8096 inclusive, depending on\n   the application and CPU speed. Smaller values reduce latency, but can\n   lead to underflow if the application is doing heavy processing and cannot\n   fill the audio buffer in time. Note that the number of sample frames is\n   directly related to time by the following formula: `ms =\n   (sampleframes*1000)/freq`\n - `desired->size` is the size in _bytes_ of the audio buffer, and is\n   calculated by SDL_OpenAudioDevice(). You don't initialize this.\n - `desired->silence` is the value used to set the buffer to silence, and is\n   calculated by SDL_OpenAudioDevice(). You don't initialize this.\n - `desired->callback` should be set to a function that will be called when\n   the audio device is ready for more data. It is passed a pointer to the\n   audio buffer, and the length in bytes of the audio buffer. This function\n   usually runs in a separate thread, and so you should protect data\n   structures that it accesses by calling SDL_LockAudioDevice() and\n   SDL_UnlockAudioDevice() in your code. Alternately, you may pass a NULL\n   pointer here, and call SDL_QueueAudio() with some frequency, to queue\n   more audio samples to be played (or for capture devices, call\n   SDL_DequeueAudio() with some frequency, to obtain audio samples).\n - `desired->userdata` is passed as the first parameter to your callback\n   function. If you passed a NULL callback, this value is ignored.\n\n `allowed_changes` can have the following flags OR'd together:\n\n - `SDL_AUDIO_ALLOW_FREQUENCY_CHANGE`\n - `SDL_AUDIO_ALLOW_FORMAT_CHANGE`\n - `SDL_AUDIO_ALLOW_CHANNELS_CHANGE`\n - `SDL_AUDIO_ALLOW_SAMPLES_CHANGE`\n - `SDL_AUDIO_ALLOW_ANY_CHANGE`\n\n These flags specify how SDL should behave when a device cannot offer a\n specific feature. If the application requests a feature that the hardware\n doesn't offer, SDL will always try to get the closest equivalent.\n\n For example, if you ask for float32 audio format, but the sound card only\n supports int16, SDL will set the hardware to int16. If you had set\n SDL_AUDIO_ALLOW_FORMAT_CHANGE, SDL will change the format in the `obtained`\n structure. If that flag was *not* set, SDL will prepare to convert your\n callback's float32 audio to int16 before feeding it to the hardware and\n will keep the originally requested format in the `obtained` structure.\n\n The resulting audio specs, varying depending on hardware and on what\n changes were allowed, will then be written back to `obtained`.\n\n If your application can only handle one specific data format, pass a zero\n for `allowed_changes` and let SDL transparently handle any differences.\n\n \\param device a UTF-8 string reported by SDL_GetAudioDeviceName() or a\n               driver-specific name as appropriate. NULL requests the most\n               reasonable default device.\n \\param iscapture non-zero to specify a device should be opened for\n                  recording, not playback\n \\param desired an SDL_AudioSpec structure representing the desired output\n                format\n \\param obtained an SDL_AudioSpec structure filled in with the actual output\n                 format\n \\param allowed_changes 0, or one or more flags OR'd together\n \\returns a valid device ID that is > 0 on success or 0 on failure; call\n          SDL_GetError() for more information.\n\n          For compatibility with SDL 1.2, this will never return 1, since\n          SDL reserves that ID for the legacy SDL_OpenAudio() function.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CloseAudioDevice\n \\sa SDL_GetAudioDeviceName\n \\sa SDL_LockAudioDevice\n \\sa SDL_PlayAudioDevice\n \\sa SDL_PauseAudioDevice\n \\sa SDL_UnlockAudioDevice"]
    pub fn SDL_OpenAudioDevice(
        device: *const libc::c_char,
        iscapture: libc::c_int,
        desired: *const SDL_AudioSpec,
        obtained: *mut SDL_AudioSpec,
        allowed_changes: libc::c_int,
    ) -> SDL_AudioDeviceID;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_AudioStatus {
    SDL_AUDIO_STOPPED = 0,
    SDL_AUDIO_PLAYING = 1,
    SDL_AUDIO_PAUSED = 2,
}
extern "C" {
    #[doc = " Use this function to get the current audio state of an audio device.\n\n \\param dev the ID of an audio device previously opened with\n            SDL_OpenAudioDevice()\n \\returns the SDL_AudioStatus of the specified audio device.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_PlayAudioDevice\n \\sa SDL_PauseAudioDevice"]
    pub fn SDL_GetAudioDeviceStatus(dev: SDL_AudioDeviceID) -> SDL_AudioStatus;
}
extern "C" {
    #[doc = " Use this function to play audio on a specified device.\n\n Newly-opened audio devices start in the paused state, so you must call this\n function after opening the specified audio device to start playing sound.\n This allows you to safely initialize data for your callback function after\n opening the audio device. Silence will be written to the audio device while\n paused, and the audio callback is guaranteed to not be called. Pausing one\n device does not prevent other unpaused devices from running their\n callbacks.\n\n \\param dev a device opened by SDL_OpenAudioDevice()\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_LockAudioDevice\n \\sa SDL_PauseAudioDevice"]
    pub fn SDL_PlayAudioDevice(dev: SDL_AudioDeviceID) -> libc::c_int;
}
extern "C" {
    #[doc = " Use this function to pause audio playback on a specified device.\n\n This function pauses the audio callback processing for a given device.\n Silence will be written to the audio device while paused, and the audio\n callback is guaranteed to not be called. Pausing one device does not\n prevent other unpaused devices from running their callbacks.\n\n If you just need to protect a few variables from race conditions vs your\n callback, you shouldn't pause the audio device, as it will lead to dropouts\n in the audio playback. Instead, you should use SDL_LockAudioDevice().\n\n \\param dev a device opened by SDL_OpenAudioDevice()\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_LockAudioDevice\n \\sa SDL_PlayAudioDevice"]
    pub fn SDL_PauseAudioDevice(dev: SDL_AudioDeviceID) -> libc::c_int;
}
extern "C" {
    #[doc = " Load the audio data of a WAVE file into memory.\n\n Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to\n be valid pointers. The entire data portion of the file is then loaded into\n memory and decoded if necessary.\n\n Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and\n 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and\n A-law and mu-law (8 bits). Other formats are currently unsupported and\n cause an error.\n\n If this function succeeds, the pointer returned by it is equal to `spec`\n and the pointer to the audio data allocated by the function is written to\n `audio_buf` and its length in bytes to `audio_len`. The SDL_AudioSpec\n members `freq`, `channels`, and `format` are set to the values of the audio\n data in the buffer. The `samples` member is set to a sane default and all\n others are set to zero.\n\n It's necessary to use SDL_free() to free the audio data returned in\n `audio_buf` when it is no longer used.\n\n Because of the underspecification of the .WAV format, there are many\n problematic files in the wild that cause issues with strict decoders. To\n provide compatibility with these files, this decoder is lenient in regards\n to the truncation of the file, the fact chunk, and the size of the RIFF\n chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,\n `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to\n tune the behavior of the loading process.\n\n Any file that is invalid (due to truncation, corruption, or wrong values in\n the headers), too big, or unsupported causes an error. Additionally, any\n critical I/O error from the data source will terminate the loading process\n with an error. The function returns NULL on error and in all cases (with\n the exception of `src` being NULL), an appropriate error message will be\n set.\n\n It is required that the data source supports seeking.\n\n Example:\n\n ```c\n SDL_LoadWAV_RW(SDL_RWFromFile(\"sample.wav\", \"rb\"), 1, &spec, &buf, &len);\n ```\n\n Note that the SDL_LoadWAV macro does this same thing for you, but in a less\n messy way:\n\n ```c\n SDL_LoadWAV(\"sample.wav\", &spec, &buf, &len);\n ```\n\n \\param src The data source for the WAVE data\n \\param freesrc if SDL_TRUE, calls SDL_RWclose() on `src` before returning,\n                even in the case of an error\n \\param spec An SDL_AudioSpec that will be filled in with the wave file's\n             format details\n \\param audio_buf A pointer filled with the audio data, allocated by the\n                  function\n \\param audio_len A pointer filled with the length of the audio data buffer\n                  in bytes\n \\returns This function, if successfully called, returns `spec`, which will\n          be filled with the audio data format of the wave source data.\n          `audio_buf` will be filled with a pointer to an allocated buffer\n          containing the audio data, and `audio_len` is filled with the\n          length of that audio buffer in bytes.\n\n          This function returns NULL if the .WAV file cannot be opened, uses\n          an unknown data format, or is corrupt; call SDL_GetError() for\n          more information.\n\n          When the application is done with the data returned in\n          `audio_buf`, it should call SDL_free() to dispose of it.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_free\n \\sa SDL_LoadWAV"]
    pub fn SDL_LoadWAV_RW(
        src: *mut SDL_RWops,
        freesrc: SDL_bool,
        spec: *mut SDL_AudioSpec,
        audio_buf: *mut *mut Uint8,
        audio_len: *mut Uint32,
    ) -> *mut SDL_AudioSpec;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_AudioStream {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a new audio stream.\n\n \\param src_format The format of the source audio\n \\param src_channels The number of channels of the source audio\n \\param src_rate The sampling rate of the source audio\n \\param dst_format The format of the desired audio output\n \\param dst_channels The number of channels of the desired audio output\n \\param dst_rate The sampling rate of the desired audio output\n \\returns 0 on success, or -1 on error.\n\n \\threadsafety It is safe to call this function from any thread.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_PutAudioStreamData\n \\sa SDL_GetAudioStreamData\n \\sa SDL_GetAudioStreamAvailable\n \\sa SDL_FlushAudioStream\n \\sa SDL_ClearAudioStream\n \\sa SDL_ChangeAudioStreamOutput\n \\sa SDL_DestroyAudioStream"]
    pub fn SDL_CreateAudioStream(
        src_format: SDL_AudioFormat,
        src_channels: libc::c_int,
        src_rate: libc::c_int,
        dst_format: SDL_AudioFormat,
        dst_channels: libc::c_int,
        dst_rate: libc::c_int,
    ) -> *mut SDL_AudioStream;
}
extern "C" {
    #[doc = " Query the current format of an audio stream.\n\n \\param stream the SDL_AudioStream to query.\n \\param src_format Where to store the input audio format; ignored if NULL.\n \\param src_channels Where to store the input channel count; ignored if\n                     NULL.\n \\param src_rate Where to store the input sample rate; ignored if NULL.\n \\param dst_format Where to store the output audio format; ignored if NULL.\n \\param dst_channels Where to store the output channel count; ignored if\n                     NULL.\n \\param dst_rate Where to store the output sample rate; ignored if NULL.\n \\returns 0 on success, or -1 on error.\n\n \\threadsafety It is safe to call this function from any thread, as it holds\n               a stream-specific mutex while running.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetAudioStreamFormat(
        stream: *mut SDL_AudioStream,
        src_format: *mut SDL_AudioFormat,
        src_channels: *mut libc::c_int,
        src_rate: *mut libc::c_int,
        dst_format: *mut SDL_AudioFormat,
        dst_channels: *mut libc::c_int,
        dst_rate: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Change the input and output formats of an audio stream.\n\n Future calls to and SDL_GetAudioStreamAvailable and SDL_GetAudioStreamData\n will reflect the new format, and future calls to SDL_PutAudioStreamData\n must provide data in the new input formats.\n\n \\param stream The stream the format is being changed\n \\param src_format The format of the audio input\n \\param src_channels The number of channels of the audio input\n \\param src_rate The sampling rate of the audio input\n \\param dst_format The format of the desired audio output\n \\param dst_channels The number of channels of the desired audio output\n \\param dst_rate The sampling rate of the desired audio output\n \\returns 0 on success, or -1 on error.\n\n \\threadsafety It is safe to call this function from any thread, as it holds\n               a stream-specific mutex while running.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetAudioStreamFormat\n \\sa SDL_PutAudioStreamData\n \\sa SDL_GetAudioStreamData\n \\sa SDL_GetAudioStreamAvailable"]
    pub fn SDL_SetAudioStreamFormat(
        stream: *mut SDL_AudioStream,
        src_format: SDL_AudioFormat,
        src_channels: libc::c_int,
        src_rate: libc::c_int,
        dst_format: SDL_AudioFormat,
        dst_channels: libc::c_int,
        dst_rate: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Add data to be converted/resampled to the stream.\n\n This data must match the format/channels/samplerate specified in the latest\n call to SDL_SetAudioStreamFormat, or the format specified when creating the\n stream if it hasn't been changed.\n\n Note that this call simply queues unconverted data for later. This is\n different than SDL2, where data was converted during the Put call and the\n Get call would just dequeue the previously-converted data.\n\n \\param stream The stream the audio data is being added to\n \\param buf A pointer to the audio data to add\n \\param len The number of bytes to write to the stream\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateAudioStream\n \\sa SDL_GetAudioStreamData\n \\sa SDL_GetAudioStreamAvailable\n \\sa SDL_FlushAudioStream\n \\sa SDL_ClearAudioStream\n \\sa SDL_DestroyAudioStream"]
    pub fn SDL_PutAudioStreamData(
        stream: *mut SDL_AudioStream,
        buf: *const libc::c_void,
        len: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get converted/resampled data from the stream.\n\n The input/output data format/channels/samplerate is specified when creating\n the stream, and can be changed after creation by calling\n SDL_SetAudioStreamFormat.\n\n Note that any conversion and resampling necessary is done during this call,\n and SDL_PutAudioStreamData simply queues unconverted data for later. This\n is different than SDL2, where that work was done while inputting new data\n to the stream and requesting the output just copied the converted data.\n\n \\param stream The stream the audio is being requested from\n \\param buf A buffer to fill with audio data\n \\param len The maximum number of bytes to fill\n \\returns the number of bytes read from the stream, or -1 on error\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateAudioStream\n \\sa SDL_PutAudioStreamData\n \\sa SDL_GetAudioStreamAvailable\n \\sa SDL_SetAudioStreamFormat\n \\sa SDL_FlushAudioStream\n \\sa SDL_ClearAudioStream\n \\sa SDL_DestroyAudioStream"]
    pub fn SDL_GetAudioStreamData(
        stream: *mut SDL_AudioStream,
        buf: *mut libc::c_void,
        len: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the number of converted/resampled bytes available.\n\n The stream may be buffering data behind the scenes until it has enough to\n resample correctly, so this number might be lower than what you expect, or\n even be zero. Add more data or flush the stream if you need the data now.\n\n If the stream has so much data that it would overflow an int, the return\n value is clamped to a maximum value, but no queued data is lost; if there\n are gigabytes of data queued, the app might need to read some of it with\n SDL_GetAudioStreamData before this function's return value is no longer\n clamped.\n\n \\param stream The audio stream to query\n \\returns the number of converted/resampled bytes available.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateAudioStream\n \\sa SDL_PutAudioStreamData\n \\sa SDL_GetAudioStreamData\n \\sa SDL_FlushAudioStream\n \\sa SDL_ClearAudioStream\n \\sa SDL_DestroyAudioStream"]
    pub fn SDL_GetAudioStreamAvailable(stream: *mut SDL_AudioStream) -> libc::c_int;
}
extern "C" {
    #[doc = " Tell the stream that you're done sending data, and anything being buffered\n should be converted/resampled and made available immediately.\n\n It is legal to add more data to a stream after flushing, but there will be\n audio gaps in the output. Generally this is intended to signal the end of\n input, so the complete output becomes available.\n\n \\param stream The audio stream to flush\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateAudioStream\n \\sa SDL_PutAudioStreamData\n \\sa SDL_GetAudioStreamData\n \\sa SDL_GetAudioStreamAvailable\n \\sa SDL_ClearAudioStream\n \\sa SDL_DestroyAudioStream"]
    pub fn SDL_FlushAudioStream(stream: *mut SDL_AudioStream) -> libc::c_int;
}
extern "C" {
    #[doc = " Clear any pending data in the stream without converting it\n\n \\param stream The audio stream to clear\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateAudioStream\n \\sa SDL_PutAudioStreamData\n \\sa SDL_GetAudioStreamData\n \\sa SDL_GetAudioStreamAvailable\n \\sa SDL_FlushAudioStream\n \\sa SDL_DestroyAudioStream"]
    pub fn SDL_ClearAudioStream(stream: *mut SDL_AudioStream) -> libc::c_int;
}
extern "C" {
    #[doc = " Free an audio stream\n\n \\param stream The audio stream to free\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateAudioStream\n \\sa SDL_PutAudioStreamData\n \\sa SDL_GetAudioStreamData\n \\sa SDL_GetAudioStreamAvailable\n \\sa SDL_FlushAudioStream\n \\sa SDL_ClearAudioStream"]
    pub fn SDL_DestroyAudioStream(stream: *mut SDL_AudioStream);
}
extern "C" {
    #[doc = " Mix audio data in a specified format.\n\n This takes an audio buffer `src` of `len` bytes of `format` data and mixes\n it into `dst`, performing addition, volume adjustment, and overflow\n clipping. The buffer pointed to by `dst` must also be `len` bytes of\n `format` data.\n\n This is provided for convenience -- you can mix your own audio data.\n\n Do not use this function for mixing together more than two streams of\n sample data. The output from repeated application of this function may be\n distorted by clipping, because there is no accumulator with greater range\n than the input (not to mention this being an inefficient way of doing it).\n\n It is a common misconception that this function is required to write audio\n data to an output stream in an audio callback. While you can do that,\n SDL_MixAudioFormat() is really only needed when you're mixing a single\n audio stream with a volume adjustment.\n\n \\param dst the destination for the mixed audio\n \\param src the source audio buffer to be mixed\n \\param format the SDL_AudioFormat structure representing the desired audio\n               format\n \\param len the length of the audio buffer in bytes\n \\param volume ranges from 0 - 128, and should be set to SDL_MIX_MAXVOLUME\n               for full audio volume\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_MixAudioFormat(
        dst: *mut Uint8,
        src: *const Uint8,
        format: SDL_AudioFormat,
        len: Uint32,
        volume: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Queue more audio on non-callback devices.\n\n If you are looking to retrieve queued audio from a non-callback capture\n device, you want SDL_DequeueAudio() instead. SDL_QueueAudio() will return\n -1 to signify an error if you use it with capture devices.\n\n SDL offers two ways to feed audio to the device: you can either supply a\n callback that SDL triggers with some frequency to obtain more audio (pull\n method), or you can supply no callback, and then SDL will expect you to\n supply data at regular intervals (push method) with this function.\n\n There are no limits on the amount of data you can queue, short of\n exhaustion of address space. Queued data will drain to the device as\n necessary without further intervention from you. If the device needs audio\n but there is not enough queued, it will play silence to make up the\n difference. This means you will have skips in your audio playback if you\n aren't routinely queueing sufficient data.\n\n This function copies the supplied data, so you are safe to free it when the\n function returns. This function is thread-safe, but queueing to the same\n device from two threads at once does not promise which buffer will be\n queued first.\n\n You may not queue audio on a device that is using an application-supplied\n callback; doing so returns an error. You have to use the audio callback or\n queue audio with this function, but not both.\n\n You should not call SDL_LockAudio() on the device before queueing; SDL\n handles locking internally for this function.\n\n Note that SDL does not support planar audio. You will need to resample from\n planar audio formats into a non-planar one (see SDL_AudioFormat) before\n queuing audio.\n\n \\param dev the device ID to which we will queue audio\n \\param data the data to queue to the device for later playback\n \\param len the number of bytes (not samples!) to which `data` points\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_ClearQueuedAudio\n \\sa SDL_GetQueuedAudioSize"]
    pub fn SDL_QueueAudio(
        dev: SDL_AudioDeviceID,
        data: *const libc::c_void,
        len: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Dequeue more audio on non-callback devices.\n\n If you are looking to queue audio for output on a non-callback playback\n device, you want SDL_QueueAudio() instead. SDL_DequeueAudio() will always\n return 0 if you use it with playback devices.\n\n SDL offers two ways to retrieve audio from a capture device: you can either\n supply a callback that SDL triggers with some frequency as the device\n records more audio data, (push method), or you can supply no callback, and\n then SDL will expect you to retrieve data at regular intervals (pull\n method) with this function.\n\n There are no limits on the amount of data you can queue, short of\n exhaustion of address space. Data from the device will keep queuing as\n necessary without further intervention from you. This means you will\n eventually run out of memory if you aren't routinely dequeueing data.\n\n Capture devices will not queue data when paused; if you are expecting to\n not need captured audio for some length of time, use SDL_PauseAudioDevice()\n to stop the capture device from queueing more data. This can be useful\n during, say, level loading times. When unpaused, capture devices will start\n queueing data from that point, having flushed any capturable data available\n while paused.\n\n This function is thread-safe, but dequeueing from the same device from two\n threads at once does not promise which thread will dequeue data first.\n\n You may not dequeue audio from a device that is using an\n application-supplied callback; doing so returns an error. You have to use\n the audio callback, or dequeue audio with this function, but not both.\n\n You should not call SDL_LockAudio() on the device before dequeueing; SDL\n handles locking internally for this function.\n\n \\param dev the device ID from which we will dequeue audio\n \\param data a pointer into where audio data should be copied\n \\param len the number of bytes (not samples!) to which (data) points\n \\returns the number of bytes dequeued, which could be less than requested;\n          call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_ClearQueuedAudio\n \\sa SDL_GetQueuedAudioSize"]
    pub fn SDL_DequeueAudio(dev: SDL_AudioDeviceID, data: *mut libc::c_void, len: Uint32)
        -> Uint32;
}
extern "C" {
    #[doc = " Get the number of bytes of still-queued audio.\n\n For playback devices: this is the number of bytes that have been queued for\n playback with SDL_QueueAudio(), but have not yet been sent to the hardware.\n\n Once we've sent it to the hardware, this function can not decide the exact\n byte boundary of what has been played. It's possible that we just gave the\n hardware several kilobytes right before you called this function, but it\n hasn't played any of it yet, or maybe half of it, etc.\n\n For capture devices, this is the number of bytes that have been captured by\n the device and are waiting for you to dequeue. This number may grow at any\n time, so this only informs of the lower-bound of available data.\n\n You may not queue or dequeue audio on a device that is using an\n application-supplied callback; calling this function on such a device\n always returns 0. You have to use the audio callback or queue audio, but\n not both.\n\n You should not call SDL_LockAudio() on the device before querying; SDL\n handles locking internally for this function.\n\n \\param dev the device ID of which we will query queued audio size\n \\returns the number of bytes (not samples!) of queued audio.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_ClearQueuedAudio\n \\sa SDL_QueueAudio\n \\sa SDL_DequeueAudio"]
    pub fn SDL_GetQueuedAudioSize(dev: SDL_AudioDeviceID) -> Uint32;
}
extern "C" {
    #[doc = " Drop any queued audio data waiting to be sent to the hardware.\n\n Immediately after this call, SDL_GetQueuedAudioSize() will return 0. For\n output devices, the hardware will start playing silence if more audio isn't\n queued. For capture devices, the hardware will start filling the empty\n queue with new data if the capture device isn't paused.\n\n This will not prevent playback of queued audio that's already been sent to\n the hardware, as we can not undo that, so expect there to be some fraction\n of a second of audio that might still be heard. This can be useful if you\n want to, say, drop any pending music or any unprocessed microphone input\n during a level change in your game.\n\n You may not queue or dequeue audio on a device that is using an\n application-supplied callback; calling this function on such a device\n always returns 0. You have to use the audio callback or queue audio, but\n not both.\n\n You should not call SDL_LockAudio() on the device before clearing the\n queue; SDL handles locking internally for this function.\n\n This function always succeeds and thus returns void.\n\n \\param dev the device ID of which to clear the audio queue\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetQueuedAudioSize\n \\sa SDL_QueueAudio\n \\sa SDL_DequeueAudio"]
    pub fn SDL_ClearQueuedAudio(dev: SDL_AudioDeviceID) -> libc::c_int;
}
extern "C" {
    #[doc = " Use this function to lock out the audio callback function for a specified\n device.\n\n The lock manipulated by these functions protects the audio callback\n function specified in SDL_OpenAudioDevice(). During a\n SDL_LockAudioDevice()/SDL_UnlockAudioDevice() pair, you can be guaranteed\n that the callback function for that device is not running, even if the\n device is not paused. While a device is locked, any other unpaused,\n unlocked devices may still run their callbacks.\n\n Calling this function from inside your audio callback is unnecessary. SDL\n obtains this lock before calling your function, and releases it when the\n function returns.\n\n You should not hold the lock longer than absolutely necessary. If you hold\n it too long, you'll experience dropouts in your audio playback. Ideally,\n your application locks the device, sets a few variables and unlocks again.\n Do not do heavy work while holding the lock for a device.\n\n It is safe to lock the audio device multiple times, as long as you unlock\n it an equivalent number of times. The callback will not run until the\n device has been unlocked completely in this way. If your application fails\n to unlock the device appropriately, your callback will never run, you might\n hear repeating bursts of audio, and SDL_CloseAudioDevice() will probably\n deadlock.\n\n Internally, the audio device lock is a mutex; if you lock from two threads\n at once, not only will you block the audio callback, you'll block the other\n thread.\n\n \\param dev the ID of the device to be locked\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_UnlockAudioDevice"]
    pub fn SDL_LockAudioDevice(dev: SDL_AudioDeviceID) -> libc::c_int;
}
extern "C" {
    #[doc = " Use this function to unlock the audio callback function for a specified\n device.\n\n This function should be paired with a previous SDL_LockAudioDevice() call.\n\n \\param dev the ID of the device to be unlocked\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_LockAudioDevice"]
    pub fn SDL_UnlockAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
    #[doc = " Use this function to shut down audio processing and close the audio device.\n\n The application should close open audio devices once they are no longer\n needed. Calling this function will wait until the device's audio callback\n is not running, release the audio hardware and then clean up internal\n state. No further audio will play from this device once this function\n returns.\n\n This function may block briefly while pending audio data is played by the\n hardware, so that applications don't drop the last buffer of data they\n supplied.\n\n The device ID is invalid as soon as the device is closed, and is eligible\n for reuse in a new SDL_OpenAudioDevice() call immediately.\n\n \\param dev an audio device previously opened with SDL_OpenAudioDevice()\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_OpenAudioDevice"]
    pub fn SDL_CloseAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
    #[doc = " Convert some audio data of one format to another format.\n\n Please note that this function is for convenience, but should not be used\n to resample audio in blocks, as it will introduce audio artifacts on the\n boundaries. You should only use this function if you are converting audio\n data in its entirety in one call. If you want to convert audio in smaller\n chunks, use an SDL_AudioStream, which is designed for this situation.\n\n Internally, this function creates and destroys an SDL_AudioStream on each\n use, so it's also less efficient than using one directly, if you need to\n convert multiple times.\n\n \\param src_format The format of the source audio\n \\param src_channels The number of channels of the source audio\n \\param src_rate The sampling rate of the source audio\n \\param src_data The audio data to be converted\n \\param src_len The len of src_data\n \\param dst_format The format of the desired audio output\n \\param dst_channels The number of channels of the desired audio output\n \\param dst_rate The sampling rate of the desired audio output\n \\param dst_data Will be filled with a pointer to converted audio data,\n                 which should be freed with SDL_free(). On error, it will be\n                 NULL.\n \\param dst_len Will be filled with the len of dst_data\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateAudioStream"]
    pub fn SDL_ConvertAudioSamples(
        src_format: SDL_AudioFormat,
        src_channels: Uint8,
        src_rate: libc::c_int,
        src_data: *const Uint8,
        src_len: libc::c_int,
        dst_format: SDL_AudioFormat,
        dst_channels: Uint8,
        dst_rate: libc::c_int,
        dst_data: *mut *mut Uint8,
        dst_len: *mut libc::c_int,
    ) -> libc::c_int;
}
#[repr(u32)]
#[doc = "  \\brief The blend mode used in SDL_RenderTexture() and drawing operations."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_BlendMode {
    #[doc = "< no blending\ndstRGBA = srcRGBA"]
    SDL_BLENDMODE_NONE = 0,
    #[doc = "< alpha blending\ndstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA))\ndstA = srcA + (dstA * (1-srcA))"]
    SDL_BLENDMODE_BLEND = 1,
    #[doc = "< additive blending\ndstRGB = (srcRGB * srcA) + dstRGB\ndstA = dstA"]
    SDL_BLENDMODE_ADD = 2,
    #[doc = "< color modulate\ndstRGB = srcRGB * dstRGB\ndstA = dstA"]
    SDL_BLENDMODE_MOD = 4,
    #[doc = "< color multiply\ndstRGB = (srcRGB * dstRGB) + (dstRGB * (1-srcA))\ndstA = dstA"]
    SDL_BLENDMODE_MUL = 8,
    SDL_BLENDMODE_INVALID = 2147483647,
}
#[repr(u32)]
#[doc = "  \\brief The blend operation used when combining source and destination pixel components"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_BlendOperation {
    #[doc = "< dst + src: supported by all renderers"]
    SDL_BLENDOPERATION_ADD = 1,
    #[doc = "< dst - src : supported by D3D9, D3D11, OpenGL, OpenGLES"]
    SDL_BLENDOPERATION_SUBTRACT = 2,
    #[doc = "< src - dst : supported by D3D9, D3D11, OpenGL, OpenGLES"]
    SDL_BLENDOPERATION_REV_SUBTRACT = 3,
    #[doc = "< min(dst, src) : supported by D3D9, D3D11"]
    SDL_BLENDOPERATION_MINIMUM = 4,
    #[doc = "< max(dst, src) : supported by D3D9, D3D11"]
    SDL_BLENDOPERATION_MAXIMUM = 5,
}
#[repr(u32)]
#[doc = "  \\brief The normalized factor used to multiply pixel components"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_BlendFactor {
    #[doc = "< 0, 0, 0, 0"]
    SDL_BLENDFACTOR_ZERO = 1,
    #[doc = "< 1, 1, 1, 1"]
    SDL_BLENDFACTOR_ONE = 2,
    #[doc = "< srcR, srcG, srcB, srcA"]
    SDL_BLENDFACTOR_SRC_COLOR = 3,
    #[doc = "< 1-srcR, 1-srcG, 1-srcB, 1-srcA"]
    SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR = 4,
    #[doc = "< srcA, srcA, srcA, srcA"]
    SDL_BLENDFACTOR_SRC_ALPHA = 5,
    #[doc = "< 1-srcA, 1-srcA, 1-srcA, 1-srcA"]
    SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA = 6,
    #[doc = "< dstR, dstG, dstB, dstA"]
    SDL_BLENDFACTOR_DST_COLOR = 7,
    #[doc = "< 1-dstR, 1-dstG, 1-dstB, 1-dstA"]
    SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR = 8,
    #[doc = "< dstA, dstA, dstA, dstA"]
    SDL_BLENDFACTOR_DST_ALPHA = 9,
    #[doc = "< 1-dstA, 1-dstA, 1-dstA, 1-dstA"]
    SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA = 10,
}
extern "C" {
    #[doc = " Compose a custom blend mode for renderers.\n\n The functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept\n the SDL_BlendMode returned by this function if the renderer supports it.\n\n A blend mode controls how the pixels from a drawing operation (source) get\n combined with the pixels from the render target (destination). First, the\n components of the source and destination pixels get multiplied with their\n blend factors. Then, the blend operation takes the two products and\n calculates the result that will get stored in the render target.\n\n Expressed in pseudocode, it would look like this:\n\n ```c\n dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);\n dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);\n ```\n\n Where the functions `colorOperation(src, dst)` and `alphaOperation(src,\n dst)` can return one of the following:\n\n - `src + dst`\n - `src - dst`\n - `dst - src`\n - `min(src, dst)`\n - `max(src, dst)`\n\n The red, green, and blue components are always multiplied with the first,\n second, and third components of the SDL_BlendFactor, respectively. The\n fourth component is not used.\n\n The alpha component is always multiplied with the fourth component of the\n SDL_BlendFactor. The other components are not used in the alpha\n calculation.\n\n Support for these blend modes varies for each renderer. To check if a\n specific SDL_BlendMode is supported, create a renderer and pass it to\n either SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will\n return with an error if the blend mode is not supported.\n\n This list describes the support of custom blend modes for each renderer in\n SDL 2.0.6. All renderers support the four blend modes listed in the\n SDL_BlendMode enumeration.\n\n - **direct3d**: Supports all operations with all factors. However, some\n   factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and\n   `SDL_BLENDOPERATION_MAXIMUM`.\n - **direct3d11**: Same as Direct3D 9.\n - **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all\n   factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly with SDL\n   2.0.6.\n - **opengles**: Supports the `SDL_BLENDOPERATION_ADD` operation with all\n   factors. Color and alpha factors need to be the same. OpenGL ES 1\n   implementation specific: May also support `SDL_BLENDOPERATION_SUBTRACT`\n   and `SDL_BLENDOPERATION_REV_SUBTRACT`. May support color and alpha\n   operations being different from each other. May support color and alpha\n   factors being different from each other.\n - **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,\n   `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`\n   operations with all factors.\n - **psp**: No custom blend mode support.\n - **software**: No custom blend mode support.\n\n Some renderers do not provide an alpha component for the default render\n target. The `SDL_BLENDFACTOR_DST_ALPHA` and\n `SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this\n case.\n\n \\param srcColorFactor the SDL_BlendFactor applied to the red, green, and\n                       blue components of the source pixels\n \\param dstColorFactor the SDL_BlendFactor applied to the red, green, and\n                       blue components of the destination pixels\n \\param colorOperation the SDL_BlendOperation used to combine the red,\n                       green, and blue components of the source and\n                       destination pixels\n \\param srcAlphaFactor the SDL_BlendFactor applied to the alpha component of\n                       the source pixels\n \\param dstAlphaFactor the SDL_BlendFactor applied to the alpha component of\n                       the destination pixels\n \\param alphaOperation the SDL_BlendOperation used to combine the alpha\n                       component of the source and destination pixels\n \\returns an SDL_BlendMode that represents the chosen factors and\n          operations.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetRenderDrawBlendMode\n \\sa SDL_GetRenderDrawBlendMode\n \\sa SDL_SetTextureBlendMode\n \\sa SDL_GetTextureBlendMode"]
    pub fn SDL_ComposeCustomBlendMode(
        srcColorFactor: SDL_BlendFactor,
        dstColorFactor: SDL_BlendFactor,
        colorOperation: SDL_BlendOperation,
        srcAlphaFactor: SDL_BlendFactor,
        dstAlphaFactor: SDL_BlendFactor,
        alphaOperation: SDL_BlendOperation,
    ) -> SDL_BlendMode;
}
extern "C" {
    #[doc = " Put UTF-8 text into the clipboard.\n\n \\param text the text to store in the clipboard\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetClipboardText\n \\sa SDL_HasClipboardText"]
    pub fn SDL_SetClipboardText(text: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Get UTF-8 text from the clipboard, which must be freed with SDL_free().\n\n This functions returns empty string if there was not enough memory left for\n a copy of the clipboard's content.\n\n \\returns the clipboard text on success or an empty string on failure; call\n          SDL_GetError() for more information. Caller must call SDL_free()\n          on the returned pointer when done with it (even if there was an\n          error).\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HasClipboardText\n \\sa SDL_SetClipboardText"]
    pub fn SDL_GetClipboardText() -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Query whether the clipboard exists and contains a non-empty text string.\n\n \\returns SDL_TRUE if the clipboard has text, or SDL_FALSE if it does not.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetClipboardText\n \\sa SDL_SetClipboardText"]
    pub fn SDL_HasClipboardText() -> SDL_bool;
}
extern "C" {
    #[doc = " Put UTF-8 text into the primary selection.\n\n \\param text the text to store in the primary selection\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetPrimarySelectionText\n \\sa SDL_HasPrimarySelectionText"]
    pub fn SDL_SetPrimarySelectionText(text: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Get UTF-8 text from the primary selection, which must be freed with\n SDL_free().\n\n This functions returns empty string if there was not enough memory left for\n a copy of the primary selection's content.\n\n \\returns the primary selection text on success or an empty string on\n          failure; call SDL_GetError() for more information. Caller must\n          call SDL_free() on the returned pointer when done with it (even if\n          there was an error).\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HasPrimarySelectionText\n \\sa SDL_SetPrimarySelectionText"]
    pub fn SDL_GetPrimarySelectionText() -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Query whether the primary selection exists and contains a non-empty text\n string.\n\n \\returns SDL_TRUE if the primary selection has text, or SDL_FALSE if it\n          does not.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetPrimarySelectionText\n \\sa SDL_SetPrimarySelectionText"]
    pub fn SDL_HasPrimarySelectionText() -> SDL_bool;
}
#[doc = " Callback function that will be called when data for the specified mime-type\n is requested by the OS.\n\n The callback function is called with NULL as the mime_type when the clipboard\n is cleared or new data is set. The clipboard is automatically cleared in SDL_Quit().\n\n \\param userdata  A pointer to provided user data\n \\param mime_type The requested mime-type\n \\param size      A pointer filled in with the length of the returned data\n \\returns a pointer to the data for the provided mime-type. Returning NULL or\n          setting length to 0 will cause no data to be sent to the \"receiver\". It is\n          up to the receiver to handle this. Essentially returning no data is more or\n          less undefined behavior and may cause breakage in receiving applications.\n          The returned data will not be freed so it needs to be retained and dealt\n          with internally.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetClipboardData"]
pub type SDL_ClipboardDataCallback = ::core::option::Option<
    unsafe extern "C" fn(
        userdata: *mut libc::c_void,
        mime_type: *const libc::c_char,
        size: *mut usize,
    ) -> *const libc::c_void,
>;
#[doc = " Callback function that will be called when the clipboard is cleared, or new data is set.\n\n \\param userdata A pointer to provided user data\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetClipboardData"]
pub type SDL_ClipboardCleanupCallback =
    ::core::option::Option<unsafe extern "C" fn(userdata: *mut libc::c_void)>;
extern "C" {
    #[doc = " Offer clipboard data to the OS\n\n Tell the operating system that the application is offering clipboard data\n for each of the proivded mime-types. Once another application requests the\n data the callback function will be called allowing it to generate and\n respond with the data for the requested mime-type.\n\n The size of text data does not include any terminator, and the text does\n not need to be null terminated (e.g. you can directly copy a portion of a\n document)\n\n \\param callback A function pointer to the function that provides the\n                 clipboard data\n \\param cleanup A function pointer to the function that cleans up the\n                clipboard data\n \\param userdata An opaque pointer that will be forwarded to the callbacks\n \\param mime_types A list of mime-types that are being offered\n \\param num_mime_types The number of mime-types in the mime_types list\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_ClipboardDataCallback\n \\sa SDL_SetClipboardData\n \\sa SDL_GetClipboardData\n \\sa SDL_HasClipboardData"]
    pub fn SDL_SetClipboardData(
        callback: SDL_ClipboardDataCallback,
        cleanup: SDL_ClipboardCleanupCallback,
        userdata: *mut libc::c_void,
        mime_types: *mut *const libc::c_char,
        num_mime_types: usize,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Clear the clipboard data\n\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetClipboardData"]
    pub fn SDL_ClearClipboardData() -> libc::c_int;
}
extern "C" {
    #[doc = " Get the data from clipboard for a given mime type\n\n The size of text data does not include the terminator, but the text is\n guaranteed to be null terminated.\n\n \\param mime_type The mime type to read from the clipboard\n \\param size A pointer filled in with the length of the returned data\n \\returns the retrieved data buffer or NULL on failure; call SDL_GetError()\n          for more information. Caller must call SDL_free() on the returned\n          pointer when done with it.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetClipboardData"]
    pub fn SDL_GetClipboardData(
        mime_type: *const libc::c_char,
        size: *mut usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Query whether there is data in the clipboard for the provided mime type\n\n \\param mime_type The mime type to check for data for\n \\returns SDL_TRUE if there exists data in clipboard for the provided mime\n          type, SDL_FALSE if it does not.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetClipboardData\n \\sa SDL_GetClipboardData"]
    pub fn SDL_HasClipboardData(mime_type: *const libc::c_char) -> SDL_bool;
}
extern "C" {
    #[doc = " Get the number of CPU cores available.\n\n \\returns the total number of logical CPU cores. On CPUs that include\n          technologies such as hyperthreading, the number of logical cores\n          may be more than the number of physical cores.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetCPUCount() -> libc::c_int;
}
extern "C" {
    #[doc = " Determine the L1 cache line size of the CPU.\n\n This is useful for determining multi-threaded structure padding or SIMD\n prefetch sizes.\n\n \\returns the L1 cache line size of the CPU, in bytes.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetCPUCacheLineSize() -> libc::c_int;
}
extern "C" {
    #[doc = " Determine whether the CPU has AltiVec features.\n\n This always returns false on CPUs that aren't using PowerPC instruction\n sets.\n\n \\returns SDL_TRUE if the CPU has AltiVec features or SDL_FALSE if not.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HasAVX\n \\sa SDL_HasAVX2\n \\sa SDL_HasAVX512F\n \\sa SDL_HasMMX\n \\sa SDL_HasSSE\n \\sa SDL_HasSSE2\n \\sa SDL_HasSSE3\n \\sa SDL_HasSSE41\n \\sa SDL_HasSSE42"]
    pub fn SDL_HasAltiVec() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has MMX features.\n\n This always returns false on CPUs that aren't using Intel instruction sets.\n\n \\returns SDL_TRUE if the CPU has MMX features or SDL_FALSE if not.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HasAltiVec\n \\sa SDL_HasAVX\n \\sa SDL_HasAVX2\n \\sa SDL_HasAVX512F\n \\sa SDL_HasSSE\n \\sa SDL_HasSSE2\n \\sa SDL_HasSSE3\n \\sa SDL_HasSSE41\n \\sa SDL_HasSSE42"]
    pub fn SDL_HasMMX() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has SSE features.\n\n This always returns false on CPUs that aren't using Intel instruction sets.\n\n \\returns SDL_TRUE if the CPU has SSE features or SDL_FALSE if not.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HasAltiVec\n \\sa SDL_HasAVX\n \\sa SDL_HasAVX2\n \\sa SDL_HasAVX512F\n \\sa SDL_HasMMX\n \\sa SDL_HasSSE2\n \\sa SDL_HasSSE3\n \\sa SDL_HasSSE41\n \\sa SDL_HasSSE42"]
    pub fn SDL_HasSSE() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has SSE2 features.\n\n This always returns false on CPUs that aren't using Intel instruction sets.\n\n \\returns SDL_TRUE if the CPU has SSE2 features or SDL_FALSE if not.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HasAltiVec\n \\sa SDL_HasAVX\n \\sa SDL_HasAVX2\n \\sa SDL_HasAVX512F\n \\sa SDL_HasMMX\n \\sa SDL_HasSSE\n \\sa SDL_HasSSE3\n \\sa SDL_HasSSE41\n \\sa SDL_HasSSE42"]
    pub fn SDL_HasSSE2() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has SSE3 features.\n\n This always returns false on CPUs that aren't using Intel instruction sets.\n\n \\returns SDL_TRUE if the CPU has SSE3 features or SDL_FALSE if not.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HasAltiVec\n \\sa SDL_HasAVX\n \\sa SDL_HasAVX2\n \\sa SDL_HasAVX512F\n \\sa SDL_HasMMX\n \\sa SDL_HasSSE\n \\sa SDL_HasSSE2\n \\sa SDL_HasSSE41\n \\sa SDL_HasSSE42"]
    pub fn SDL_HasSSE3() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has SSE4.1 features.\n\n This always returns false on CPUs that aren't using Intel instruction sets.\n\n \\returns SDL_TRUE if the CPU has SSE4.1 features or SDL_FALSE if not.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HasAltiVec\n \\sa SDL_HasAVX\n \\sa SDL_HasAVX2\n \\sa SDL_HasAVX512F\n \\sa SDL_HasMMX\n \\sa SDL_HasSSE\n \\sa SDL_HasSSE2\n \\sa SDL_HasSSE3\n \\sa SDL_HasSSE42"]
    pub fn SDL_HasSSE41() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has SSE4.2 features.\n\n This always returns false on CPUs that aren't using Intel instruction sets.\n\n \\returns SDL_TRUE if the CPU has SSE4.2 features or SDL_FALSE if not.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HasAltiVec\n \\sa SDL_HasAVX\n \\sa SDL_HasAVX2\n \\sa SDL_HasAVX512F\n \\sa SDL_HasMMX\n \\sa SDL_HasSSE\n \\sa SDL_HasSSE2\n \\sa SDL_HasSSE3\n \\sa SDL_HasSSE41"]
    pub fn SDL_HasSSE42() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has AVX features.\n\n This always returns false on CPUs that aren't using Intel instruction sets.\n\n \\returns SDL_TRUE if the CPU has AVX features or SDL_FALSE if not.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HasAltiVec\n \\sa SDL_HasAVX2\n \\sa SDL_HasAVX512F\n \\sa SDL_HasMMX\n \\sa SDL_HasSSE\n \\sa SDL_HasSSE2\n \\sa SDL_HasSSE3\n \\sa SDL_HasSSE41\n \\sa SDL_HasSSE42"]
    pub fn SDL_HasAVX() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has AVX2 features.\n\n This always returns false on CPUs that aren't using Intel instruction sets.\n\n \\returns SDL_TRUE if the CPU has AVX2 features or SDL_FALSE if not.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HasAltiVec\n \\sa SDL_HasAVX\n \\sa SDL_HasAVX512F\n \\sa SDL_HasMMX\n \\sa SDL_HasSSE\n \\sa SDL_HasSSE2\n \\sa SDL_HasSSE3\n \\sa SDL_HasSSE41\n \\sa SDL_HasSSE42"]
    pub fn SDL_HasAVX2() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has AVX-512F (foundation) features.\n\n This always returns false on CPUs that aren't using Intel instruction sets.\n\n \\returns SDL_TRUE if the CPU has AVX-512F features or SDL_FALSE if not.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HasAltiVec\n \\sa SDL_HasAVX\n \\sa SDL_HasAVX2\n \\sa SDL_HasMMX\n \\sa SDL_HasSSE\n \\sa SDL_HasSSE2\n \\sa SDL_HasSSE3\n \\sa SDL_HasSSE41\n \\sa SDL_HasSSE42"]
    pub fn SDL_HasAVX512F() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has ARM SIMD (ARMv6) features.\n\n This is different from ARM NEON, which is a different instruction set.\n\n This always returns false on CPUs that aren't using ARM instruction sets.\n\n \\returns SDL_TRUE if the CPU has ARM SIMD features or SDL_FALSE if not.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HasNEON"]
    pub fn SDL_HasARMSIMD() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has NEON (ARM SIMD) features.\n\n This always returns false on CPUs that aren't using ARM instruction sets.\n\n \\returns SDL_TRUE if the CPU has ARM NEON features or SDL_FALSE if not.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_HasNEON() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has LSX (LOONGARCH SIMD) features.\n\n This always returns false on CPUs that aren't using LOONGARCH instruction\n sets.\n\n \\returns SDL_TRUE if the CPU has LOONGARCH LSX features or SDL_FALSE if\n          not.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_HasLSX() -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether the CPU has LASX (LOONGARCH SIMD) features.\n\n This always returns false on CPUs that aren't using LOONGARCH instruction\n sets.\n\n \\returns SDL_TRUE if the CPU has LOONGARCH LASX features or SDL_FALSE if\n          not.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_HasLASX() -> SDL_bool;
}
extern "C" {
    #[doc = " Get the amount of RAM configured in the system.\n\n \\returns the amount of RAM configured in the system in MiB.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetSystemRAM() -> libc::c_int;
}
extern "C" {
    #[doc = " Report the alignment this system needs for SIMD allocations.\n\n This will return the minimum number of bytes to which a pointer must be\n aligned to be compatible with SIMD instructions on the current machine. For\n example, if the machine supports SSE only, it will return 16, but if it\n supports AVX-512F, it'll return 64 (etc). This only reports values for\n instruction sets SDL knows about, so if your SDL build doesn't have\n SDL_HasAVX512F(), then it might return 16 for the SSE support it sees and\n not 64 for the AVX-512 instructions that exist but SDL doesn't know about.\n Plan accordingly.\n\n \\returns the alignment in bytes needed for available, known SIMD\n          instructions.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_aligned_alloc\n \\sa SDL_aligned_free"]
    pub fn SDL_SIMDGetAlignment() -> usize;
}
#[doc = "  \\brief SDL_sensor.h\n\n  In order to use these functions, SDL_Init() must have been called\n  with the ::SDL_INIT_SENSOR flag.  This causes SDL to scan the system\n  for sensors, and load appropriate drivers."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Sensor {
    _unused: [u8; 0],
}
#[doc = " This is a unique ID for a sensor for the time it is connected to the system,\n and is never reused for the lifetime of the application.\n\n The ID value starts at 1 and increments from there. The value 0 is an invalid ID."]
pub type SDL_SensorID = Uint32;
#[repr(i32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_SensorType {
    #[doc = "< Returned for an invalid sensor"]
    SDL_SENSOR_INVALID = -1,
    #[doc = "< Unknown sensor type"]
    SDL_SENSOR_UNKNOWN = 0,
    #[doc = "< Accelerometer"]
    SDL_SENSOR_ACCEL = 1,
    #[doc = "< Gyroscope"]
    SDL_SENSOR_GYRO = 2,
    #[doc = "< Accelerometer for left Joy-Con controller and Wii nunchuk"]
    SDL_SENSOR_ACCEL_L = 3,
    #[doc = "< Gyroscope for left Joy-Con controller"]
    SDL_SENSOR_GYRO_L = 4,
    #[doc = "< Accelerometer for right Joy-Con controller"]
    SDL_SENSOR_ACCEL_R = 5,
    #[doc = "< Gyroscope for right Joy-Con controller"]
    SDL_SENSOR_GYRO_R = 6,
}
extern "C" {
    #[doc = " Get a list of currently connected sensors.\n\n \\param count a pointer filled in with the number of sensors returned\n \\returns a 0 terminated array of sensor instance IDs which should be freed\n          with SDL_free(), or NULL on error; call SDL_GetError() for more\n          details.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetSensors(count: *mut libc::c_int) -> *mut SDL_SensorID;
}
extern "C" {
    #[doc = " Get the implementation dependent name of a sensor.\n\n \\param instance_id the sensor instance ID\n \\returns the sensor name, or NULL if `instance_id` is not valid\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetSensorInstanceName(instance_id: SDL_SensorID) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the type of a sensor.\n\n \\param instance_id the sensor instance ID\n \\returns the SDL_SensorType, or `SDL_SENSOR_INVALID` if `instance_id` is\n          not valid\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetSensorInstanceType(instance_id: SDL_SensorID) -> SDL_SensorType;
}
extern "C" {
    #[doc = " Get the platform dependent type of a sensor.\n\n \\param instance_id the sensor instance ID\n \\returns the sensor platform dependent type, or -1 if `instance_id` is not\n          valid\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetSensorInstanceNonPortableType(instance_id: SDL_SensorID) -> libc::c_int;
}
extern "C" {
    #[doc = " Open a sensor for use.\n\n \\param instance_id the sensor instance ID\n \\returns an SDL_Sensor sensor object, or NULL if an error occurred.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_OpenSensor(instance_id: SDL_SensorID) -> *mut SDL_Sensor;
}
extern "C" {
    #[doc = " Return the SDL_Sensor associated with an instance ID.\n\n \\param instance_id the sensor instance ID\n \\returns an SDL_Sensor object.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetSensorFromInstanceID(instance_id: SDL_SensorID) -> *mut SDL_Sensor;
}
extern "C" {
    #[doc = " Get the implementation dependent name of a sensor\n\n \\param sensor The SDL_Sensor object\n \\returns the sensor name, or NULL if `sensor` is NULL.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetSensorName(sensor: *mut SDL_Sensor) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the type of a sensor.\n\n \\param sensor The SDL_Sensor object to inspect\n \\returns the SDL_SensorType type, or `SDL_SENSOR_INVALID` if `sensor` is\n          NULL.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetSensorType(sensor: *mut SDL_Sensor) -> SDL_SensorType;
}
extern "C" {
    #[doc = " Get the platform dependent type of a sensor.\n\n \\param sensor The SDL_Sensor object to inspect\n \\returns the sensor platform dependent type, or -1 if `sensor` is NULL.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetSensorNonPortableType(sensor: *mut SDL_Sensor) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the instance ID of a sensor.\n\n \\param sensor The SDL_Sensor object to inspect\n \\returns the sensor instance ID, or 0 if `sensor` is NULL.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetSensorInstanceID(sensor: *mut SDL_Sensor) -> SDL_SensorID;
}
extern "C" {
    #[doc = " Get the current state of an opened sensor.\n\n The number of values and interpretation of the data is sensor dependent.\n\n \\param sensor The SDL_Sensor object to query\n \\param data A pointer filled with the current sensor state\n \\param num_values The number of values to write to data\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetSensorData(
        sensor: *mut SDL_Sensor,
        data: *mut f32,
        num_values: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Close a sensor previously opened with SDL_OpenSensor().\n\n \\param sensor The SDL_Sensor object to close\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_CloseSensor(sensor: *mut SDL_Sensor);
}
extern "C" {
    #[doc = " Update the current state of the open sensors.\n\n This is called automatically by the event loop if sensor events are\n enabled.\n\n This needs to be called from the thread that initialized the sensor\n subsystem.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_UpdateSensors();
}
#[doc = " An SDL_GUID is a 128-bit identifier for an input device that\n   identifies that device across runs of SDL programs on the same\n   platform.  If the device is detached and then re-attached to a\n   different port, or if the base system is rebooted, the device\n   should still report the same GUID.\n\n GUIDs are as precise as possible but are not guaranteed to\n   distinguish physically distinct but equivalent devices.  For\n   example, two game controllers from the same vendor with the same\n   product ID and revision may have the same GUID.\n\n GUIDs may be platform-dependent (i.e., the same device may report\n   different GUIDs on different operating systems)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_GUID {
    pub data: [Uint8; 16usize],
}
#[test]
fn bindgen_test_layout_SDL_GUID() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_GUID> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_GUID>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_GUID))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_GUID>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_GUID))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GUID),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Get an ASCII string representation for a given ::SDL_GUID.\n\n You should supply at least 33 bytes for pszGUID.\n\n \\param guid the ::SDL_GUID you wish to convert to string\n \\param pszGUID buffer in which to write the ASCII string\n \\param cbGUID the size of pszGUID\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GUIDFromString"]
    pub fn SDL_GUIDToString(
        guid: SDL_GUID,
        pszGUID: *mut libc::c_char,
        cbGUID: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Convert a GUID string into a ::SDL_GUID structure.\n\n Performs no error checking. If this function is given a string containing\n an invalid GUID, the function will silently succeed, but the GUID generated\n will not be useful.\n\n \\param pchGUID string containing an ASCII representation of a GUID\n \\returns a ::SDL_GUID structure.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GUIDToString"]
    pub fn SDL_GUIDFromString(pchGUID: *const libc::c_char) -> SDL_GUID;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Joystick {
    _unused: [u8; 0],
}
#[doc = " An SDL_GUID is a 128-bit identifier for an input device that\n   identifies that device across runs of SDL programs on the same\n   platform.  If the device is detached and then re-attached to a\n   different port, or if the base system is rebooted, the device\n   should still report the same GUID.\n\n GUIDs are as precise as possible but are not guaranteed to\n   distinguish physically distinct but equivalent devices.  For\n   example, two game controllers from the same vendor with the same\n   product ID and revision may have the same GUID.\n\n GUIDs may be platform-dependent (i.e., the same device may report\n   different GUIDs on different operating systems)."]
pub type SDL_JoystickGUID = SDL_GUID;
#[doc = " This is a unique ID for a joystick for the time it is connected to the system,\n and is never reused for the lifetime of the application. If the joystick is\n disconnected and reconnected, it will get a new ID.\n\n The ID value starts at 1 and increments from there. The value 0 is an invalid ID."]
pub type SDL_JoystickID = Uint32;
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_JoystickType {
    SDL_JOYSTICK_TYPE_UNKNOWN = 0,
    SDL_JOYSTICK_TYPE_GAMEPAD = 1,
    SDL_JOYSTICK_TYPE_WHEEL = 2,
    SDL_JOYSTICK_TYPE_ARCADE_STICK = 3,
    SDL_JOYSTICK_TYPE_FLIGHT_STICK = 4,
    SDL_JOYSTICK_TYPE_DANCE_PAD = 5,
    SDL_JOYSTICK_TYPE_GUITAR = 6,
    SDL_JOYSTICK_TYPE_DRUM_KIT = 7,
    SDL_JOYSTICK_TYPE_ARCADE_PAD = 8,
    SDL_JOYSTICK_TYPE_THROTTLE = 9,
}
#[repr(i32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_JoystickPowerLevel {
    SDL_JOYSTICK_POWER_UNKNOWN = -1,
    SDL_JOYSTICK_POWER_EMPTY = 0,
    SDL_JOYSTICK_POWER_LOW = 1,
    SDL_JOYSTICK_POWER_MEDIUM = 2,
    SDL_JOYSTICK_POWER_FULL = 3,
    SDL_JOYSTICK_POWER_WIRED = 4,
    SDL_JOYSTICK_POWER_MAX = 5,
}
extern "C" {
    #[doc = " Locking for atomic access to the joystick API\n\n The SDL joystick functions are thread-safe, however you can lock the\n joysticks while processing to guarantee that the joystick list won't change\n and joystick and gamepad events will not be delivered.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_LockJoysticks();
}
extern "C" {
    #[doc = " Unlocking for atomic access to the joystick API\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_UnlockJoysticks();
}
extern "C" {
    #[doc = " Get a list of currently connected joysticks.\n\n \\param count a pointer filled in with the number of joysticks returned\n \\returns a 0 terminated array of joystick instance IDs which should be\n          freed with SDL_free(), or NULL on error; call SDL_GetError() for\n          more details.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_OpenJoystick"]
    pub fn SDL_GetJoysticks(count: *mut libc::c_int) -> *mut SDL_JoystickID;
}
extern "C" {
    #[doc = " Get the implementation dependent name of a joystick.\n\n This can be called before any joysticks are opened.\n\n \\param instance_id the joystick instance ID\n \\returns the name of the selected joystick. If no name can be found, this\n          function returns NULL; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetJoystickName\n \\sa SDL_OpenJoystick"]
    pub fn SDL_GetJoystickInstanceName(instance_id: SDL_JoystickID) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the implementation dependent path of a joystick.\n\n This can be called before any joysticks are opened.\n\n \\param instance_id the joystick instance ID\n \\returns the path of the selected joystick. If no path can be found, this\n          function returns NULL; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetJoystickPath\n \\sa SDL_OpenJoystick"]
    pub fn SDL_GetJoystickInstancePath(instance_id: SDL_JoystickID) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the player index of a joystick.\n\n This can be called before any joysticks are opened.\n\n \\param instance_id the joystick instance ID\n \\returns the player index of a joystick, or -1 if it's not available\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetJoystickPlayerIndex\n \\sa SDL_OpenJoystick"]
    pub fn SDL_GetJoystickInstancePlayerIndex(instance_id: SDL_JoystickID) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the implementation-dependent GUID of a joystick.\n\n This can be called before any joysticks are opened.\n\n \\param instance_id the joystick instance ID\n \\returns the GUID of the selected joystick. If called on an invalid index,\n          this function returns a zero GUID\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetJoystickGUID\n \\sa SDL_GetJoystickGUIDString"]
    pub fn SDL_GetJoystickInstanceGUID(instance_id: SDL_JoystickID) -> SDL_JoystickGUID;
}
extern "C" {
    #[doc = " Get the USB vendor ID of a joystick, if available.\n\n This can be called before any joysticks are opened. If the vendor ID isn't\n available this function returns 0.\n\n \\param instance_id the joystick instance ID\n \\returns the USB vendor ID of the selected joystick. If called on an\n          invalid index, this function returns zero\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetJoystickInstanceVendor(instance_id: SDL_JoystickID) -> Uint16;
}
extern "C" {
    #[doc = " Get the USB product ID of a joystick, if available.\n\n This can be called before any joysticks are opened. If the product ID isn't\n available this function returns 0.\n\n \\param instance_id the joystick instance ID\n \\returns the USB product ID of the selected joystick. If called on an\n          invalid index, this function returns zero\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetJoystickInstanceProduct(instance_id: SDL_JoystickID) -> Uint16;
}
extern "C" {
    #[doc = " Get the product version of a joystick, if available.\n\n This can be called before any joysticks are opened. If the product version\n isn't available this function returns 0.\n\n \\param instance_id the joystick instance ID\n \\returns the product version of the selected joystick. If called on an\n          invalid index, this function returns zero\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetJoystickInstanceProductVersion(instance_id: SDL_JoystickID) -> Uint16;
}
extern "C" {
    #[doc = " Get the type of a joystick, if available.\n\n This can be called before any joysticks are opened.\n\n \\param instance_id the joystick instance ID\n \\returns the SDL_JoystickType of the selected joystick. If called on an\n          invalid index, this function returns `SDL_JOYSTICK_TYPE_UNKNOWN`\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetJoystickInstanceType(instance_id: SDL_JoystickID) -> SDL_JoystickType;
}
extern "C" {
    #[doc = " Open a joystick for use.\n\n The joystick subsystem must be initialized before a joystick can be opened\n for use.\n\n \\param instance_id the joystick instance ID\n \\returns a joystick identifier or NULL if an error occurred; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CloseJoystick"]
    pub fn SDL_OpenJoystick(instance_id: SDL_JoystickID) -> *mut SDL_Joystick;
}
extern "C" {
    #[doc = " Get the SDL_Joystick associated with an instance ID, if it has been opened.\n\n \\param instance_id the instance ID to get the SDL_Joystick for\n \\returns an SDL_Joystick on success or NULL on failure or if it hasn't been\n          opened yet; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetJoystickFromInstanceID(instance_id: SDL_JoystickID) -> *mut SDL_Joystick;
}
extern "C" {
    #[doc = " Get the SDL_Joystick associated with a player index.\n\n \\param player_index the player index to get the SDL_Joystick for\n \\returns an SDL_Joystick on success or NULL on failure; call SDL_GetError()\n          for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetJoystickFromPlayerIndex(player_index: libc::c_int) -> *mut SDL_Joystick;
}
extern "C" {
    #[doc = " Attach a new virtual joystick.\n\n \\param type type of joystick\n \\param naxes number of axes\n \\param nbuttons number of buttons\n \\param nhats number of hats\n \\returns the joystick instance ID, or 0 if an error occurred; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_AttachVirtualJoystick(
        type_: SDL_JoystickType,
        naxes: libc::c_int,
        nbuttons: libc::c_int,
        nhats: libc::c_int,
    ) -> SDL_JoystickID;
}
#[doc = " The structure that defines an extended virtual joystick description\n\n The caller must zero the structure and then initialize the version with `SDL_VIRTUAL_JOYSTICK_DESC_VERSION` before passing it to SDL_AttachVirtualJoystickEx()\n  All other elements of this structure are optional and can be left 0.\n\n \\sa SDL_AttachVirtualJoystickEx"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_VirtualJoystickDesc {
    #[doc = "< `SDL_VIRTUAL_JOYSTICK_DESC_VERSION`"]
    pub version: Uint16,
    #[doc = "< `SDL_JoystickType`"]
    pub type_: Uint16,
    #[doc = "< the number of axes on this joystick"]
    pub naxes: Uint16,
    #[doc = "< the number of buttons on this joystick"]
    pub nbuttons: Uint16,
    #[doc = "< the number of hats on this joystick"]
    pub nhats: Uint16,
    #[doc = "< the USB vendor ID of this joystick"]
    pub vendor_id: Uint16,
    #[doc = "< the USB product ID of this joystick"]
    pub product_id: Uint16,
    #[doc = "< unused"]
    pub padding: Uint16,
    #[doc = "< A mask of which buttons are valid for this controller\ne.g. (1 << SDL_GAMEPAD_BUTTON_A)"]
    pub button_mask: Uint32,
    #[doc = "< A mask of which axes are valid for this controller\ne.g. (1 << SDL_GAMEPAD_AXIS_LEFTX)"]
    pub axis_mask: Uint32,
    #[doc = "< the name of the joystick"]
    pub name: *const libc::c_char,
    #[doc = "< User data pointer passed to callbacks"]
    pub userdata: *mut libc::c_void,
    #[doc = "< Called when the joystick state should be updated"]
    pub Update: ::core::option::Option<unsafe extern "C" fn(userdata: *mut libc::c_void)>,
    #[doc = "< Called when the player index is set"]
    pub SetPlayerIndex: ::core::option::Option<
        unsafe extern "C" fn(userdata: *mut libc::c_void, player_index: libc::c_int),
    >,
    #[doc = "< Implements SDL_RumbleJoystick()"]
    pub Rumble: ::core::option::Option<
        unsafe extern "C" fn(
            userdata: *mut libc::c_void,
            low_frequency_rumble: Uint16,
            high_frequency_rumble: Uint16,
        ) -> libc::c_int,
    >,
    #[doc = "< Implements SDL_RumbleJoystickTriggers()"]
    pub RumbleTriggers: ::core::option::Option<
        unsafe extern "C" fn(
            userdata: *mut libc::c_void,
            left_rumble: Uint16,
            right_rumble: Uint16,
        ) -> libc::c_int,
    >,
    #[doc = "< Implements SDL_SetJoystickLED()"]
    pub SetLED: ::core::option::Option<
        unsafe extern "C" fn(
            userdata: *mut libc::c_void,
            red: Uint8,
            green: Uint8,
            blue: Uint8,
        ) -> libc::c_int,
    >,
    #[doc = "< Implements SDL_SendJoystickEffect()"]
    pub SendEffect: ::core::option::Option<
        unsafe extern "C" fn(
            userdata: *mut libc::c_void,
            data: *const libc::c_void,
            size: libc::c_int,
        ) -> libc::c_int,
    >,
}
#[test]
fn bindgen_test_layout_SDL_VirtualJoystickDesc() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_VirtualJoystickDesc> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_VirtualJoystickDesc>(),
        88usize,
        concat!("Size of: ", stringify!(SDL_VirtualJoystickDesc))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_VirtualJoystickDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_VirtualJoystickDesc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_VirtualJoystickDesc),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_VirtualJoystickDesc),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).naxes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_VirtualJoystickDesc),
            "::",
            stringify!(naxes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nbuttons) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_VirtualJoystickDesc),
            "::",
            stringify!(nbuttons)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nhats) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_VirtualJoystickDesc),
            "::",
            stringify!(nhats)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vendor_id) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_VirtualJoystickDesc),
            "::",
            stringify!(vendor_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).product_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_VirtualJoystickDesc),
            "::",
            stringify!(product_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_VirtualJoystickDesc),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).button_mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_VirtualJoystickDesc),
            "::",
            stringify!(button_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).axis_mask) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_VirtualJoystickDesc),
            "::",
            stringify!(axis_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_VirtualJoystickDesc),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).userdata) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_VirtualJoystickDesc),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Update) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_VirtualJoystickDesc),
            "::",
            stringify!(Update)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SetPlayerIndex) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_VirtualJoystickDesc),
            "::",
            stringify!(SetPlayerIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Rumble) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_VirtualJoystickDesc),
            "::",
            stringify!(Rumble)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RumbleTriggers) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_VirtualJoystickDesc),
            "::",
            stringify!(RumbleTriggers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SetLED) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_VirtualJoystickDesc),
            "::",
            stringify!(SetLED)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SendEffect) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_VirtualJoystickDesc),
            "::",
            stringify!(SendEffect)
        )
    );
}
extern "C" {
    #[doc = " Attach a new virtual joystick with extended properties.\n\n \\param desc Joystick description\n \\returns the joystick instance ID, or 0 if an error occurred; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_AttachVirtualJoystickEx(desc: *const SDL_VirtualJoystickDesc) -> SDL_JoystickID;
}
extern "C" {
    #[doc = " Detach a virtual joystick.\n\n \\param instance_id the joystick instance ID, previously returned from\n                    SDL_AttachVirtualJoystick()\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_DetachVirtualJoystick(instance_id: SDL_JoystickID) -> libc::c_int;
}
extern "C" {
    #[doc = " Query whether or not a joystick is virtual.\n\n \\param instance_id the joystick instance ID\n \\returns SDL_TRUE if the joystick is virtual, SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_IsJoystickVirtual(instance_id: SDL_JoystickID) -> SDL_bool;
}
extern "C" {
    #[doc = " Set values on an opened, virtual-joystick's axis.\n\n Please note that values set here will not be applied until the next call to\n SDL_UpdateJoysticks, which can either be called directly, or can be called\n indirectly through various other SDL APIs, including, but not limited to\n the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,\n SDL_WaitEvent.\n\n Note that when sending trigger axes, you should scale the value to the full\n range of Sint16. For example, a trigger at rest would have the value of\n `SDL_JOYSTICK_AXIS_MIN`.\n\n \\param joystick the virtual joystick on which to set state.\n \\param axis the specific axis on the virtual joystick to set.\n \\param value the new value for the specified axis.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_SetJoystickVirtualAxis(
        joystick: *mut SDL_Joystick,
        axis: libc::c_int,
        value: Sint16,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set values on an opened, virtual-joystick's button.\n\n Please note that values set here will not be applied until the next call to\n SDL_UpdateJoysticks, which can either be called directly, or can be called\n indirectly through various other SDL APIs, including, but not limited to\n the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,\n SDL_WaitEvent.\n\n \\param joystick the virtual joystick on which to set state.\n \\param button the specific button on the virtual joystick to set.\n \\param value the new value for the specified button.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_SetJoystickVirtualButton(
        joystick: *mut SDL_Joystick,
        button: libc::c_int,
        value: Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set values on an opened, virtual-joystick's hat.\n\n Please note that values set here will not be applied until the next call to\n SDL_UpdateJoysticks, which can either be called directly, or can be called\n indirectly through various other SDL APIs, including, but not limited to\n the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,\n SDL_WaitEvent.\n\n \\param joystick the virtual joystick on which to set state.\n \\param hat the specific hat on the virtual joystick to set.\n \\param value the new value for the specified hat.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_SetJoystickVirtualHat(
        joystick: *mut SDL_Joystick,
        hat: libc::c_int,
        value: Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the implementation dependent name of a joystick.\n\n \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick()\n \\returns the name of the selected joystick. If no name can be found, this\n          function returns NULL; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetJoystickInstanceName\n \\sa SDL_OpenJoystick"]
    pub fn SDL_GetJoystickName(joystick: *mut SDL_Joystick) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the implementation dependent path of a joystick.\n\n \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick()\n \\returns the path of the selected joystick. If no path can be found, this\n          function returns NULL; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetJoystickInstancePath"]
    pub fn SDL_GetJoystickPath(joystick: *mut SDL_Joystick) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the player index of an opened joystick.\n\n For XInput controllers this returns the XInput user index. Many joysticks\n will not be able to supply this information.\n\n \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick()\n \\returns the player index, or -1 if it's not available.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetJoystickPlayerIndex(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the player index of an opened joystick.\n\n \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick()\n \\param player_index Player index to assign to this joystick, or -1 to clear\n                     the player index and turn off player LEDs.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_SetJoystickPlayerIndex(
        joystick: *mut SDL_Joystick,
        player_index: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the implementation-dependent GUID for the joystick.\n\n This function requires an open joystick.\n\n \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick()\n \\returns the GUID of the given joystick. If called on an invalid index,\n          this function returns a zero GUID; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetJoystickInstanceGUID\n \\sa SDL_GetJoystickGUIDString"]
    pub fn SDL_GetJoystickGUID(joystick: *mut SDL_Joystick) -> SDL_JoystickGUID;
}
extern "C" {
    #[doc = " Get the USB vendor ID of an opened joystick, if available.\n\n If the vendor ID isn't available this function returns 0.\n\n \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick()\n \\returns the USB vendor ID of the selected joystick, or 0 if unavailable.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetJoystickVendor(joystick: *mut SDL_Joystick) -> Uint16;
}
extern "C" {
    #[doc = " Get the USB product ID of an opened joystick, if available.\n\n If the product ID isn't available this function returns 0.\n\n \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick()\n \\returns the USB product ID of the selected joystick, or 0 if unavailable.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetJoystickProduct(joystick: *mut SDL_Joystick) -> Uint16;
}
extern "C" {
    #[doc = " Get the product version of an opened joystick, if available.\n\n If the product version isn't available this function returns 0.\n\n \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick()\n \\returns the product version of the selected joystick, or 0 if unavailable.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetJoystickProductVersion(joystick: *mut SDL_Joystick) -> Uint16;
}
extern "C" {
    #[doc = " Get the firmware version of an opened joystick, if available.\n\n If the firmware version isn't available this function returns 0.\n\n \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick()\n \\returns the firmware version of the selected joystick, or 0 if\n          unavailable.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetJoystickFirmwareVersion(joystick: *mut SDL_Joystick) -> Uint16;
}
extern "C" {
    #[doc = " Get the serial number of an opened joystick, if available.\n\n Returns the serial number of the joystick, or NULL if it is not available.\n\n \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick()\n \\returns the serial number of the selected joystick, or NULL if\n          unavailable.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetJoystickSerial(joystick: *mut SDL_Joystick) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the type of an opened joystick.\n\n \\param joystick the SDL_Joystick obtained from SDL_OpenJoystick()\n \\returns the SDL_JoystickType of the selected joystick.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetJoystickType(joystick: *mut SDL_Joystick) -> SDL_JoystickType;
}
extern "C" {
    #[doc = " Get an ASCII string representation for a given SDL_JoystickGUID.\n\n You should supply at least 33 bytes for pszGUID.\n\n \\param guid the SDL_JoystickGUID you wish to convert to string\n \\param pszGUID buffer in which to write the ASCII string\n \\param cbGUID the size of pszGUID\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetJoystickInstanceGUID\n \\sa SDL_GetJoystickGUID\n \\sa SDL_GetJoystickGUIDFromString"]
    pub fn SDL_GetJoystickGUIDString(
        guid: SDL_JoystickGUID,
        pszGUID: *mut libc::c_char,
        cbGUID: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Convert a GUID string into a SDL_JoystickGUID structure.\n\n Performs no error checking. If this function is given a string containing\n an invalid GUID, the function will silently succeed, but the GUID generated\n will not be useful.\n\n \\param pchGUID string containing an ASCII representation of a GUID\n \\returns a SDL_JoystickGUID structure.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetJoystickGUIDString"]
    pub fn SDL_GetJoystickGUIDFromString(pchGUID: *const libc::c_char) -> SDL_JoystickGUID;
}
extern "C" {
    #[doc = " Get the device information encoded in a SDL_JoystickGUID structure\n\n \\param guid the SDL_JoystickGUID you wish to get info about\n \\param vendor A pointer filled in with the device VID, or 0 if not\n               available\n \\param product A pointer filled in with the device PID, or 0 if not\n                available\n \\param version A pointer filled in with the device version, or 0 if not\n                available\n \\param crc16 A pointer filled in with a CRC used to distinguish different\n              products with the same VID/PID, or 0 if not available\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetJoystickInstanceGUID"]
    pub fn SDL_GetJoystickGUIDInfo(
        guid: SDL_JoystickGUID,
        vendor: *mut Uint16,
        product: *mut Uint16,
        version: *mut Uint16,
        crc16: *mut Uint16,
    );
}
extern "C" {
    #[doc = " Get the status of a specified joystick.\n\n \\param joystick the joystick to query\n \\returns SDL_TRUE if the joystick has been opened, SDL_FALSE if it has not;\n          call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CloseJoystick\n \\sa SDL_OpenJoystick"]
    pub fn SDL_JoystickConnected(joystick: *mut SDL_Joystick) -> SDL_bool;
}
extern "C" {
    #[doc = " Get the instance ID of an opened joystick.\n\n \\param joystick an SDL_Joystick structure containing joystick information\n \\returns the instance ID of the specified joystick on success or 0 on\n          failure; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_OpenJoystick"]
    pub fn SDL_GetJoystickInstanceID(joystick: *mut SDL_Joystick) -> SDL_JoystickID;
}
extern "C" {
    #[doc = " Get the number of general axis controls on a joystick.\n\n Often, the directional pad on a game controller will either look like 4\n separate buttons or a POV hat, and not axes, but all of this is up to the\n device and platform.\n\n \\param joystick an SDL_Joystick structure containing joystick information\n \\returns the number of axis controls/number of axes on success or a\n          negative error code on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetJoystickAxis\n \\sa SDL_OpenJoystick"]
    pub fn SDL_GetNumJoystickAxes(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the number of POV hats on a joystick.\n\n \\param joystick an SDL_Joystick structure containing joystick information\n \\returns the number of POV hats on success or a negative error code on\n          failure; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetJoystickHat\n \\sa SDL_OpenJoystick"]
    pub fn SDL_GetNumJoystickHats(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the number of buttons on a joystick.\n\n \\param joystick an SDL_Joystick structure containing joystick information\n \\returns the number of buttons on success or a negative error code on\n          failure; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetJoystickButton\n \\sa SDL_OpenJoystick"]
    pub fn SDL_GetNumJoystickButtons(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the state of joystick event processing.\n\n If joystick events are disabled, you must call SDL_UpdateJoysticks()\n yourself and check the state of the joystick when you want joystick\n information.\n\n \\param enabled whether to process joystick events or not\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_JoystickEventsEnabled"]
    pub fn SDL_SetJoystickEventsEnabled(enabled: SDL_bool);
}
extern "C" {
    #[doc = " Query the state of joystick event processing.\n\n If joystick events are disabled, you must call SDL_UpdateJoysticks()\n yourself and check the state of the joystick when you want joystick\n information.\n\n \\returns SDL_TRUE if joystick events are being processed, SDL_FALSE\n          otherwise.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetJoystickEventsEnabled"]
    pub fn SDL_JoystickEventsEnabled() -> SDL_bool;
}
extern "C" {
    #[doc = " Update the current state of the open joysticks.\n\n This is called automatically by the event loop if any joystick events are\n enabled.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_UpdateJoysticks();
}
extern "C" {
    #[doc = " Get the current state of an axis control on a joystick.\n\n SDL makes no promises about what part of the joystick any given axis refers\n to. Your game should have some sort of configuration UI to let users\n specify what each axis should be bound to. Alternately, SDL's higher-level\n Game Controller API makes a great effort to apply order to this lower-level\n interface, so you know that a specific axis is the \"left thumb stick,\" etc.\n\n The value returned by SDL_GetJoystickAxis() is a signed integer (-32768 to\n 32767) representing the current position of the axis. It may be necessary\n to impose certain tolerances on these values to account for jitter.\n\n \\param joystick an SDL_Joystick structure containing joystick information\n \\param axis the axis to query; the axis indices start at index 0\n \\returns a 16-bit signed integer representing the current position of the\n          axis or 0 on failure; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetNumJoystickAxes"]
    pub fn SDL_GetJoystickAxis(joystick: *mut SDL_Joystick, axis: libc::c_int) -> Sint16;
}
extern "C" {
    #[doc = " Get the initial state of an axis control on a joystick.\n\n The state is a value ranging from -32768 to 32767.\n\n The axis indices start at index 0.\n\n \\param joystick an SDL_Joystick structure containing joystick information\n \\param axis the axis to query; the axis indices start at index 0\n \\param state Upon return, the initial value is supplied here.\n \\returns SDL_TRUE if this axis has any initial value, or SDL_FALSE if not.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetJoystickAxisInitialState(
        joystick: *mut SDL_Joystick,
        axis: libc::c_int,
        state: *mut Sint16,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Get the current state of a POV hat on a joystick.\n\n The returned value will be one of the following positions:\n\n - `SDL_HAT_CENTERED`\n - `SDL_HAT_UP`\n - `SDL_HAT_RIGHT`\n - `SDL_HAT_DOWN`\n - `SDL_HAT_LEFT`\n - `SDL_HAT_RIGHTUP`\n - `SDL_HAT_RIGHTDOWN`\n - `SDL_HAT_LEFTUP`\n - `SDL_HAT_LEFTDOWN`\n\n \\param joystick an SDL_Joystick structure containing joystick information\n \\param hat the hat index to get the state from; indices start at index 0\n \\returns the current hat position.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetNumJoystickHats"]
    pub fn SDL_GetJoystickHat(joystick: *mut SDL_Joystick, hat: libc::c_int) -> Uint8;
}
extern "C" {
    #[doc = " Get the current state of a button on a joystick.\n\n \\param joystick an SDL_Joystick structure containing joystick information\n \\param button the button index to get the state from; indices start at\n               index 0\n \\returns 1 if the specified button is pressed, 0 otherwise.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetNumJoystickButtons"]
    pub fn SDL_GetJoystickButton(joystick: *mut SDL_Joystick, button: libc::c_int) -> Uint8;
}
extern "C" {
    #[doc = " Start a rumble effect.\n\n Each call to this function cancels any previous rumble effect, and calling\n it with 0 intensity stops any rumbling.\n\n \\param joystick The joystick to vibrate\n \\param low_frequency_rumble The intensity of the low frequency (left)\n                             rumble motor, from 0 to 0xFFFF\n \\param high_frequency_rumble The intensity of the high frequency (right)\n                              rumble motor, from 0 to 0xFFFF\n \\param duration_ms The duration of the rumble effect, in milliseconds\n \\returns 0, or -1 if rumble isn't supported on this joystick\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_JoystickHasRumble"]
    pub fn SDL_RumbleJoystick(
        joystick: *mut SDL_Joystick,
        low_frequency_rumble: Uint16,
        high_frequency_rumble: Uint16,
        duration_ms: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Start a rumble effect in the joystick's triggers\n\n Each call to this function cancels any previous trigger rumble effect, and\n calling it with 0 intensity stops any rumbling.\n\n Note that this is rumbling of the _triggers_ and not the game controller as\n a whole. This is currently only supported on Xbox One controllers. If you\n want the (more common) whole-controller rumble, use SDL_RumbleJoystick()\n instead.\n\n \\param joystick The joystick to vibrate\n \\param left_rumble The intensity of the left trigger rumble motor, from 0\n                    to 0xFFFF\n \\param right_rumble The intensity of the right trigger rumble motor, from 0\n                     to 0xFFFF\n \\param duration_ms The duration of the rumble effect, in milliseconds\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_JoystickHasRumbleTriggers"]
    pub fn SDL_RumbleJoystickTriggers(
        joystick: *mut SDL_Joystick,
        left_rumble: Uint16,
        right_rumble: Uint16,
        duration_ms: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Query whether a joystick has an LED.\n\n An example of a joystick LED is the light on the back of a PlayStation 4's\n DualShock 4 controller.\n\n \\param joystick The joystick to query\n \\returns SDL_TRUE if the joystick has a modifiable LED, SDL_FALSE\n          otherwise.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_JoystickHasLED(joystick: *mut SDL_Joystick) -> SDL_bool;
}
extern "C" {
    #[doc = " Query whether a joystick has rumble support.\n\n \\param joystick The joystick to query\n \\returns SDL_TRUE if the joystick has rumble, SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_RumbleJoystick"]
    pub fn SDL_JoystickHasRumble(joystick: *mut SDL_Joystick) -> SDL_bool;
}
extern "C" {
    #[doc = " Query whether a joystick has rumble support on triggers.\n\n \\param joystick The joystick to query\n \\returns SDL_TRUE if the joystick has trigger rumble, SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_RumbleJoystickTriggers"]
    pub fn SDL_JoystickHasRumbleTriggers(joystick: *mut SDL_Joystick) -> SDL_bool;
}
extern "C" {
    #[doc = " Update a joystick's LED color.\n\n An example of a joystick LED is the light on the back of a PlayStation 4's\n DualShock 4 controller.\n\n \\param joystick The joystick to update\n \\param red The intensity of the red LED\n \\param green The intensity of the green LED\n \\param blue The intensity of the blue LED\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_SetJoystickLED(
        joystick: *mut SDL_Joystick,
        red: Uint8,
        green: Uint8,
        blue: Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Send a joystick specific effect packet\n\n \\param joystick The joystick to affect\n \\param data The data to send to the joystick\n \\param size The size of the data to send to the joystick\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_SendJoystickEffect(
        joystick: *mut SDL_Joystick,
        data: *const libc::c_void,
        size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Close a joystick previously opened with SDL_OpenJoystick().\n\n \\param joystick The joystick device to close\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_OpenJoystick"]
    pub fn SDL_CloseJoystick(joystick: *mut SDL_Joystick);
}
extern "C" {
    #[doc = " Get the battery level of a joystick as SDL_JoystickPowerLevel.\n\n \\param joystick the SDL_Joystick to query\n \\returns the current battery level as SDL_JoystickPowerLevel on success or\n          `SDL_JOYSTICK_POWER_UNKNOWN` if it is unknown\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetJoystickPowerLevel(joystick: *mut SDL_Joystick) -> SDL_JoystickPowerLevel;
}
#[doc = " The structure used to identify an SDL gamepad"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Gamepad {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_GamepadType {
    SDL_GAMEPAD_TYPE_UNKNOWN = 0,
    SDL_GAMEPAD_TYPE_STANDARD = 1,
    SDL_GAMEPAD_TYPE_XBOX360 = 2,
    SDL_GAMEPAD_TYPE_XBOXONE = 3,
    SDL_GAMEPAD_TYPE_PS3 = 4,
    SDL_GAMEPAD_TYPE_PS4 = 5,
    SDL_GAMEPAD_TYPE_PS5 = 6,
    SDL_GAMEPAD_TYPE_NINTENDO_SWITCH_PRO = 7,
    SDL_GAMEPAD_TYPE_NINTENDO_SWITCH_JOYCON_LEFT = 8,
    SDL_GAMEPAD_TYPE_NINTENDO_SWITCH_JOYCON_RIGHT = 9,
    SDL_GAMEPAD_TYPE_NINTENDO_SWITCH_JOYCON_PAIR = 10,
    SDL_GAMEPAD_TYPE_MAX = 11,
}
#[repr(i32)]
#[doc = "  The list of buttons available on a gamepad"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_GamepadButton {
    SDL_GAMEPAD_BUTTON_INVALID = -1,
    SDL_GAMEPAD_BUTTON_A = 0,
    SDL_GAMEPAD_BUTTON_B = 1,
    SDL_GAMEPAD_BUTTON_X = 2,
    SDL_GAMEPAD_BUTTON_Y = 3,
    SDL_GAMEPAD_BUTTON_BACK = 4,
    SDL_GAMEPAD_BUTTON_GUIDE = 5,
    SDL_GAMEPAD_BUTTON_START = 6,
    SDL_GAMEPAD_BUTTON_LEFT_STICK = 7,
    SDL_GAMEPAD_BUTTON_RIGHT_STICK = 8,
    SDL_GAMEPAD_BUTTON_LEFT_SHOULDER = 9,
    SDL_GAMEPAD_BUTTON_RIGHT_SHOULDER = 10,
    SDL_GAMEPAD_BUTTON_DPAD_UP = 11,
    SDL_GAMEPAD_BUTTON_DPAD_DOWN = 12,
    SDL_GAMEPAD_BUTTON_DPAD_LEFT = 13,
    SDL_GAMEPAD_BUTTON_DPAD_RIGHT = 14,
    SDL_GAMEPAD_BUTTON_MISC1 = 15,
    SDL_GAMEPAD_BUTTON_PADDLE1 = 16,
    SDL_GAMEPAD_BUTTON_PADDLE2 = 17,
    SDL_GAMEPAD_BUTTON_PADDLE3 = 18,
    SDL_GAMEPAD_BUTTON_PADDLE4 = 19,
    SDL_GAMEPAD_BUTTON_TOUCHPAD = 20,
    SDL_GAMEPAD_BUTTON_MAX = 21,
}
#[repr(i32)]
#[doc = "  The list of axes available on a gamepad\n\n  Thumbstick axis values range from SDL_JOYSTICK_AXIS_MIN to SDL_JOYSTICK_AXIS_MAX,\n  and are centered within ~8000 of zero, though advanced UI will allow users to set\n  or autodetect the dead zone, which varies between gamepads.\n\n  Trigger axis values range from 0 to SDL_JOYSTICK_AXIS_MAX."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_GamepadAxis {
    SDL_GAMEPAD_AXIS_INVALID = -1,
    SDL_GAMEPAD_AXIS_LEFTX = 0,
    SDL_GAMEPAD_AXIS_LEFTY = 1,
    SDL_GAMEPAD_AXIS_RIGHTX = 2,
    SDL_GAMEPAD_AXIS_RIGHTY = 3,
    SDL_GAMEPAD_AXIS_LEFT_TRIGGER = 4,
    SDL_GAMEPAD_AXIS_RIGHT_TRIGGER = 5,
    SDL_GAMEPAD_AXIS_MAX = 6,
}
extern "C" {
    #[doc = " Add support for gamepads that SDL is unaware of or change the binding of an\n existing gamepad.\n\n The mapping string has the format \"GUID,name,mapping\", where GUID is the\n string value from SDL_GetJoystickGUIDString(), name is the human readable\n string for the device and mappings are gamepad mappings to joystick ones.\n Under Windows there is a reserved GUID of \"xinput\" that covers all XInput\n devices. The mapping format for joystick is:\n\n - `bX`: a joystick button, index X\n - `hX.Y`: hat X with value Y\n - `aX`: axis X of the joystick\n\n Buttons can be used as a gamepad axes and vice versa.\n\n This string shows an example of a valid mapping for a gamepad:\n\n ```c\n \"341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7\"\n ```\n\n \\param mapping the mapping string\n \\returns 1 if a new mapping is added, 0 if an existing mapping is updated,\n          -1 on error; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetGamepadMapping\n \\sa SDL_GetGamepadMappingForGUID"]
    pub fn SDL_AddGamepadMapping(mapping: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Load a set of gamepad mappings from a seekable SDL data stream.\n\n You can call this function several times, if needed, to load different\n database files.\n\n If a new mapping is loaded for an already known gamepad GUID, the later\n version will overwrite the one currently loaded.\n\n Mappings not belonging to the current platform or with no platform field\n specified will be ignored (i.e. mappings for Linux will be ignored in\n Windows, etc).\n\n This function will load the text database entirely in memory before\n processing it, so take this into consideration if you are in a memory\n constrained environment.\n\n \\param src the data stream for the mappings to be added\n \\param freesrc non-zero to close the stream after being read\n \\returns the number of mappings added or -1 on error; call SDL_GetError()\n          for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_AddGamepadMapping\n \\sa SDL_AddGamepadMappingsFromFile\n \\sa SDL_GetGamepadMappingForGUID"]
    pub fn SDL_AddGamepadMappingsFromRW(src: *mut SDL_RWops, freesrc: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Load a set of gamepad mappings from a file.\n\n You can call this function several times, if needed, to load different\n database files.\n\n If a new mapping is loaded for an already known gamepad GUID, the later\n version will overwrite the one currently loaded.\n\n Mappings not belonging to the current platform or with no platform field\n specified will be ignored (i.e. mappings for Linux will be ignored in\n Windows, etc).\n\n \\param file the mappings file to load\n \\returns the number of mappings added or -1 on error; call SDL_GetError()\n          for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_AddGamepadMapping\n \\sa SDL_AddGamepadMappingsFromRW\n \\sa SDL_GetGamepadMappingForGUID"]
    pub fn SDL_AddGamepadMappingsFromFile(file: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Reinitialize the SDL mapping database to its initial state.\n\n This will generate gamepad events as needed if device mappings change.\n\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_ReloadGamepadMappings() -> libc::c_int;
}
extern "C" {
    #[doc = " Get the number of mappings installed.\n\n \\returns the number of mappings.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetNumGamepadMappings() -> libc::c_int;
}
extern "C" {
    #[doc = " Get the mapping at a particular index.\n\n \\param mapping_index mapping index\n \\returns the mapping string. Must be freed with SDL_free(). Returns NULL if\n          the index is out of range.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetGamepadMappingForIndex(mapping_index: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Get the gamepad mapping string for a given GUID.\n\n The returned string must be freed with SDL_free().\n\n \\param guid a structure containing the GUID for which a mapping is desired\n \\returns a mapping string or NULL on error; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetJoystickInstanceGUID\n \\sa SDL_GetJoystickGUID"]
    pub fn SDL_GetGamepadMappingForGUID(guid: SDL_JoystickGUID) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Get the current mapping of a gamepad.\n\n The returned string must be freed with SDL_free().\n\n Details about mappings are discussed with SDL_AddGamepadMapping().\n\n \\param gamepad the gamepad you want to get the current mapping for\n \\returns a string that has the gamepad's mapping or NULL if no mapping is\n          available; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_AddGamepadMapping\n \\sa SDL_GetGamepadMappingForGUID\n \\sa SDL_SetGamepadMapping"]
    pub fn SDL_GetGamepadMapping(gamepad: *mut SDL_Gamepad) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Set the current mapping of a joystick or gamepad.\n\n Details about mappings are discussed with SDL_AddGamepadMapping().\n\n \\param instance_id the joystick instance ID\n \\param mapping the mapping to use for this device, or NULL to clear the\n                mapping\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_AddGamepadMapping\n \\sa SDL_GetGamepadMapping"]
    pub fn SDL_SetGamepadMapping(
        instance_id: SDL_JoystickID,
        mapping: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get a list of currently connected gamepads.\n\n \\param count a pointer filled in with the number of gamepads returned\n \\returns a 0 terminated array of joystick instance IDs which should be\n          freed with SDL_free(), or NULL on error; call SDL_GetError() for\n          more details.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_OpenGamepad"]
    pub fn SDL_GetGamepads(count: *mut libc::c_int) -> *mut SDL_JoystickID;
}
extern "C" {
    #[doc = " Check if the given joystick is supported by the gamepad interface.\n\n \\param instance_id the joystick instance ID\n \\returns SDL_TRUE if the given joystick is supported by the gamepad\n          interface, SDL_FALSE if it isn't or it's an invalid index.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetGamepadNameForIndex\n \\sa SDL_OpenGamepad"]
    pub fn SDL_IsGamepad(instance_id: SDL_JoystickID) -> SDL_bool;
}
extern "C" {
    #[doc = " Get the implementation dependent name of a gamepad.\n\n This can be called before any gamepads are opened.\n\n \\param instance_id the joystick instance ID\n \\returns the name of the selected gamepad. If no name can be found, this\n          function returns NULL; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetGamepadName\n \\sa SDL_OpenGamepad"]
    pub fn SDL_GetGamepadInstanceName(instance_id: SDL_JoystickID) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the implementation dependent path of a gamepad.\n\n This can be called before any gamepads are opened.\n\n \\param instance_id the joystick instance ID\n \\returns the path of the selected gamepad. If no path can be found, this\n          function returns NULL; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetGamepadPath\n \\sa SDL_OpenGamepad"]
    pub fn SDL_GetGamepadInstancePath(instance_id: SDL_JoystickID) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the player index of a gamepad.\n\n This can be called before any gamepads are opened.\n\n \\param instance_id the joystick instance ID\n \\returns the player index of a gamepad, or -1 if it's not available\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetGamepadPlayerIndex\n \\sa SDL_OpenGamepad"]
    pub fn SDL_GetGamepadInstancePlayerIndex(instance_id: SDL_JoystickID) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the implementation-dependent GUID of a gamepad.\n\n This can be called before any gamepads are opened.\n\n \\param instance_id the joystick instance ID\n \\returns the GUID of the selected gamepad. If called on an invalid index,\n          this function returns a zero GUID\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetGamepadGUID\n \\sa SDL_GetGamepadGUIDString"]
    pub fn SDL_GetGamepadInstanceGUID(instance_id: SDL_JoystickID) -> SDL_JoystickGUID;
}
extern "C" {
    #[doc = " Get the USB vendor ID of a gamepad, if available.\n\n This can be called before any gamepads are opened. If the vendor ID isn't\n available this function returns 0.\n\n \\param instance_id the joystick instance ID\n \\returns the USB vendor ID of the selected gamepad. If called on an invalid\n          index, this function returns zero\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetGamepadInstanceVendor(instance_id: SDL_JoystickID) -> Uint16;
}
extern "C" {
    #[doc = " Get the USB product ID of a gamepad, if available.\n\n This can be called before any gamepads are opened. If the product ID isn't\n available this function returns 0.\n\n \\param instance_id the joystick instance ID\n \\returns the USB product ID of the selected gamepad. If called on an\n          invalid index, this function returns zero\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetGamepadInstanceProduct(instance_id: SDL_JoystickID) -> Uint16;
}
extern "C" {
    #[doc = " Get the product version of a gamepad, if available.\n\n This can be called before any gamepads are opened. If the product version\n isn't available this function returns 0.\n\n \\param instance_id the joystick instance ID\n \\returns the product version of the selected gamepad. If called on an\n          invalid index, this function returns zero\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetGamepadInstanceProductVersion(instance_id: SDL_JoystickID) -> Uint16;
}
extern "C" {
    #[doc = " Get the type of a gamepad.\n\n This can be called before any gamepads are opened.\n\n \\param instance_id the joystick instance ID\n \\returns the gamepad type.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetGamepadInstanceType(instance_id: SDL_JoystickID) -> SDL_GamepadType;
}
extern "C" {
    #[doc = " Get the type of a gamepad, ignoring any mapping override.\n\n This can be called before any gamepads are opened.\n\n \\param instance_id the joystick instance ID\n \\returns the gamepad type.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetRealGamepadInstanceType(instance_id: SDL_JoystickID) -> SDL_GamepadType;
}
extern "C" {
    #[doc = " Get the mapping of a gamepad.\n\n This can be called before any gamepads are opened.\n\n \\param instance_id the joystick instance ID\n \\returns the mapping string. Must be freed with SDL_free(). Returns NULL if\n          no mapping is available.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetGamepadInstanceMapping(instance_id: SDL_JoystickID) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Open a gamepad for use.\n\n \\param instance_id the joystick instance ID\n \\returns a gamepad identifier or NULL if an error occurred; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CloseGamepad\n \\sa SDL_GetGamepadNameForIndex\n \\sa SDL_IsGamepad"]
    pub fn SDL_OpenGamepad(instance_id: SDL_JoystickID) -> *mut SDL_Gamepad;
}
extern "C" {
    #[doc = " Get the SDL_Gamepad associated with a joystick instance ID, if it has been\n opened.\n\n \\param instance_id the joystick instance ID of the gamepad\n \\returns an SDL_Gamepad on success or NULL on failure or if it hasn't been\n          opened yet; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetGamepadFromInstanceID(instance_id: SDL_JoystickID) -> *mut SDL_Gamepad;
}
extern "C" {
    #[doc = " Get the SDL_Gamepad associated with a player index.\n\n \\param player_index the player index, which different from the instance ID\n \\returns the SDL_Gamepad associated with a player index.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetGamepadPlayerIndex\n \\sa SDL_SetGamepadPlayerIndex"]
    pub fn SDL_GetGamepadFromPlayerIndex(player_index: libc::c_int) -> *mut SDL_Gamepad;
}
extern "C" {
    #[doc = " Get the instance ID of an opened gamepad.\n\n \\param gamepad a gamepad identifier previously returned by\n                SDL_OpenGamepad()\n \\returns the instance ID of the specified gamepad on success or 0 on\n          failure; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_OpenGamepad"]
    pub fn SDL_GetGamepadInstanceID(gamepad: *mut SDL_Gamepad) -> SDL_JoystickID;
}
extern "C" {
    #[doc = " Get the implementation-dependent name for an opened gamepad.\n\n \\param gamepad a gamepad identifier previously returned by\n                SDL_OpenGamepad()\n \\returns the implementation dependent name for the gamepad, or NULL if\n          there is no name or the identifier passed is invalid.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetGamepadNameForIndex\n \\sa SDL_OpenGamepad"]
    pub fn SDL_GetGamepadName(gamepad: *mut SDL_Gamepad) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the implementation-dependent path for an opened gamepad.\n\n \\param gamepad a gamepad identifier previously returned by\n                SDL_OpenGamepad()\n \\returns the implementation dependent path for the gamepad, or NULL if\n          there is no path or the identifier passed is invalid.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetGamepadInstancePath"]
    pub fn SDL_GetGamepadPath(gamepad: *mut SDL_Gamepad) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the type of an opened gamepad.\n\n \\param gamepad the gamepad object to query.\n \\returns the gamepad type, or SDL_GAMEPAD_TYPE_UNKNOWN if it's not\n          available.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetGamepadInstanceType"]
    pub fn SDL_GetGamepadType(gamepad: *mut SDL_Gamepad) -> SDL_GamepadType;
}
extern "C" {
    #[doc = " Get the type of an opened gamepad, ignoring any mapping override.\n\n \\param gamepad the gamepad object to query.\n \\returns the gamepad type, or SDL_GAMEPAD_TYPE_UNKNOWN if it's not\n          available.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetRealGamepadInstanceType"]
    pub fn SDL_GetRealGamepadType(gamepad: *mut SDL_Gamepad) -> SDL_GamepadType;
}
extern "C" {
    #[doc = " Get the player index of an opened gamepad.\n\n For XInput gamepads this returns the XInput user index.\n\n \\param gamepad the gamepad object to query.\n \\returns the player index for gamepad, or -1 if it's not available.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetGamepadPlayerIndex(gamepad: *mut SDL_Gamepad) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the player index of an opened gamepad.\n\n \\param gamepad the gamepad object to adjust.\n \\param player_index Player index to assign to this gamepad, or -1 to clear\n                     the player index and turn off player LEDs.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_SetGamepadPlayerIndex(
        gamepad: *mut SDL_Gamepad,
        player_index: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the USB vendor ID of an opened gamepad, if available.\n\n If the vendor ID isn't available this function returns 0.\n\n \\param gamepad the gamepad object to query.\n \\returns the USB vendor ID, or zero if unavailable.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetGamepadVendor(gamepad: *mut SDL_Gamepad) -> Uint16;
}
extern "C" {
    #[doc = " Get the USB product ID of an opened gamepad, if available.\n\n If the product ID isn't available this function returns 0.\n\n \\param gamepad the gamepad object to query.\n \\returns the USB product ID, or zero if unavailable.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetGamepadProduct(gamepad: *mut SDL_Gamepad) -> Uint16;
}
extern "C" {
    #[doc = " Get the product version of an opened gamepad, if available.\n\n If the product version isn't available this function returns 0.\n\n \\param gamepad the gamepad object to query.\n \\returns the USB product version, or zero if unavailable.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetGamepadProductVersion(gamepad: *mut SDL_Gamepad) -> Uint16;
}
extern "C" {
    #[doc = " Get the firmware version of an opened gamepad, if available.\n\n If the firmware version isn't available this function returns 0.\n\n \\param gamepad the gamepad object to query.\n \\returns the gamepad firmware version, or zero if unavailable.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetGamepadFirmwareVersion(gamepad: *mut SDL_Gamepad) -> Uint16;
}
extern "C" {
    #[doc = " Get the serial number of an opened gamepad, if available.\n\n Returns the serial number of the gamepad, or NULL if it is not available.\n\n \\param gamepad the gamepad object to query.\n \\returns the serial number, or NULL if unavailable.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetGamepadSerial(gamepad: *mut SDL_Gamepad) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the battery level of a gamepad, if available.\n\n \\param gamepad a gamepad identifier previously returned by\n                SDL_OpenGamepad()\n \\returns the current battery level as SDL_JoystickPowerLevel on success or\n          `SDL_JOYSTICK_POWER_UNKNOWN` if it is unknown\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetGamepadPowerLevel(gamepad: *mut SDL_Gamepad) -> SDL_JoystickPowerLevel;
}
extern "C" {
    #[doc = " Check if a gamepad has been opened and is currently connected.\n\n \\param gamepad a gamepad identifier previously returned by\n                SDL_OpenGamepad()\n \\returns SDL_TRUE if the gamepad has been opened and is currently\n          connected, or SDL_FALSE if not.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CloseGamepad\n \\sa SDL_OpenGamepad"]
    pub fn SDL_GamepadConnected(gamepad: *mut SDL_Gamepad) -> SDL_bool;
}
extern "C" {
    #[doc = " Get the underlying joystick from a gamepad\n\n This function will give you a SDL_Joystick object, which allows you to use\n the SDL_Joystick functions with a SDL_Gamepad object. This would be useful\n for getting a joystick's position at any given time, even if it hasn't\n moved (moving it would produce an event, which would have the axis' value).\n\n The pointer returned is owned by the SDL_Gamepad. You should not call\n SDL_CloseJoystick() on it, for example, since doing so will likely cause\n SDL to crash.\n\n \\param gamepad the gamepad object that you want to get a joystick from\n \\returns an SDL_Joystick object; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetGamepadJoystick(gamepad: *mut SDL_Gamepad) -> *mut SDL_Joystick;
}
extern "C" {
    #[doc = " Set the state of gamepad event processing.\n\n If gamepad events are disabled, you must call SDL_UpdateGamepads() yourself\n and check the state of the gamepad when you want gamepad information.\n\n \\param enabled whether to process gamepad events or not\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GamepadEventsEnabled"]
    pub fn SDL_SetGamepadEventsEnabled(enabled: SDL_bool);
}
extern "C" {
    #[doc = " Query the state of gamepad event processing.\n\n If gamepad events are disabled, you must call SDL_UpdateGamepads() yourself\n and check the state of the gamepad when you want gamepad information.\n\n \\returns SDL_TRUE if gamepad events are being processed, SDL_FALSE\n          otherwise.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetGamepadEventsEnabled"]
    pub fn SDL_GamepadEventsEnabled() -> SDL_bool;
}
extern "C" {
    #[doc = " Manually pump gamepad updates if not using the loop.\n\n This function is called automatically by the event loop if events are\n enabled. Under such circumstances, it will not be necessary to call this\n function.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_UpdateGamepads();
}
extern "C" {
    #[doc = " Convert a string into SDL_GamepadType enum.\n\n This function is called internally to translate SDL_Gamepad mapping strings\n for the underlying joystick device into the consistent SDL_Gamepad mapping.\n You do not normally need to call this function unless you are parsing\n SDL_Gamepad mappings in your own code.\n\n \\param str string representing a SDL_GamepadType type\n \\returns the SDL_GamepadType enum corresponding to the input string, or\n          `SDL_GAMEPAD_TYPE_UNKNOWN` if no match was found.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetGamepadStringForType"]
    pub fn SDL_GetGamepadTypeFromString(str_: *const libc::c_char) -> SDL_GamepadType;
}
extern "C" {
    #[doc = " Convert from an SDL_GamepadType enum to a string.\n\n The caller should not SDL_free() the returned string.\n\n \\param type an enum value for a given SDL_GamepadType\n \\returns a string for the given type, or NULL if an invalid type is\n          specified. The string returned is of the format used by\n          SDL_Gamepad mapping strings.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetGamepadTypeFromString"]
    pub fn SDL_GetGamepadStringForType(type_: SDL_GamepadType) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Convert a string into SDL_GamepadAxis enum.\n\n This function is called internally to translate SDL_Gamepad mapping strings\n for the underlying joystick device into the consistent SDL_Gamepad mapping.\n You do not normally need to call this function unless you are parsing\n SDL_Gamepad mappings in your own code.\n\n Note specially that \"righttrigger\" and \"lefttrigger\" map to\n `SDL_GAMEPAD_AXIS_RIGHT_TRIGGER` and `SDL_GAMEPAD_AXIS_LEFT_TRIGGER`,\n respectively.\n\n \\param str string representing a SDL_Gamepad axis\n \\returns the SDL_GamepadAxis enum corresponding to the input string, or\n          `SDL_GAMEPAD_AXIS_INVALID` if no match was found.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetGamepadStringForAxis"]
    pub fn SDL_GetGamepadAxisFromString(str_: *const libc::c_char) -> SDL_GamepadAxis;
}
extern "C" {
    #[doc = " Convert from an SDL_GamepadAxis enum to a string.\n\n The caller should not SDL_free() the returned string.\n\n \\param axis an enum value for a given SDL_GamepadAxis\n \\returns a string for the given axis, or NULL if an invalid axis is\n          specified. The string returned is of the format used by\n          SDL_Gamepad mapping strings.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetGamepadAxisFromString"]
    pub fn SDL_GetGamepadStringForAxis(axis: SDL_GamepadAxis) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Query whether a gamepad has a given axis.\n\n This merely reports whether the gamepad's mapping defined this axis, as\n that is all the information SDL has about the physical device.\n\n \\param gamepad a gamepad\n \\param axis an axis enum value (an SDL_GamepadAxis value)\n \\returns SDL_TRUE if the gamepad has this axis, SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GamepadHasAxis(gamepad: *mut SDL_Gamepad, axis: SDL_GamepadAxis) -> SDL_bool;
}
extern "C" {
    #[doc = " Get the current state of an axis control on a gamepad.\n\n The axis indices start at index 0.\n\n The state is a value ranging from -32768 to 32767. Triggers, however, range\n from 0 to 32767 (they never return a negative value).\n\n \\param gamepad a gamepad\n \\param axis an axis index (one of the SDL_GamepadAxis values)\n \\returns axis state (including 0) on success or 0 (also) on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetGamepadButton"]
    pub fn SDL_GetGamepadAxis(gamepad: *mut SDL_Gamepad, axis: SDL_GamepadAxis) -> Sint16;
}
extern "C" {
    #[doc = " Convert a string into an SDL_GamepadButton enum.\n\n This function is called internally to translate SDL_Gamepad mapping strings\n for the underlying joystick device into the consistent SDL_Gamepad mapping.\n You do not normally need to call this function unless you are parsing\n SDL_Gamepad mappings in your own code.\n\n \\param str string representing a SDL_Gamepad axis\n \\returns the SDL_GamepadButton enum corresponding to the input string, or\n          `SDL_GAMEPAD_AXIS_INVALID` if no match was found.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetGamepadButtonFromString(str_: *const libc::c_char) -> SDL_GamepadButton;
}
extern "C" {
    #[doc = " Convert from an SDL_GamepadButton enum to a string.\n\n The caller should not SDL_free() the returned string.\n\n \\param button an enum value for a given SDL_GamepadButton\n \\returns a string for the given button, or NULL if an invalid button is\n          specified. The string returned is of the format used by\n          SDL_Gamepad mapping strings.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetGamepadButtonFromString"]
    pub fn SDL_GetGamepadStringForButton(button: SDL_GamepadButton) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Query whether a gamepad has a given button.\n\n This merely reports whether the gamepad's mapping defined this button, as\n that is all the information SDL has about the physical device.\n\n \\param gamepad a gamepad\n \\param button a button enum value (an SDL_GamepadButton value)\n \\returns SDL_TRUE if the gamepad has this button, SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GamepadHasButton(gamepad: *mut SDL_Gamepad, button: SDL_GamepadButton) -> SDL_bool;
}
extern "C" {
    #[doc = " Get the current state of a button on a gamepad.\n\n \\param gamepad a gamepad\n \\param button a button index (one of the SDL_GamepadButton values)\n \\returns 1 for pressed state or 0 for not pressed state or error; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetGamepadAxis"]
    pub fn SDL_GetGamepadButton(gamepad: *mut SDL_Gamepad, button: SDL_GamepadButton) -> Uint8;
}
extern "C" {
    #[doc = " Get the number of touchpads on a gamepad.\n\n \\param gamepad a gamepad\n \\returns number of touchpads\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetNumGamepadTouchpads(gamepad: *mut SDL_Gamepad) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the number of supported simultaneous fingers on a touchpad on a game\n gamepad.\n\n \\param gamepad a gamepad\n \\param touchpad a touchpad\n \\returns number of supported simultaneous fingers\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetNumGamepadTouchpadFingers(
        gamepad: *mut SDL_Gamepad,
        touchpad: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the current state of a finger on a touchpad on a gamepad.\n\n \\param gamepad a gamepad\n \\param touchpad a touchpad\n \\param finger a finger\n \\param state filled with state\n \\param x filled with x position\n \\param y filled with y position\n \\param pressure filled with pressure value\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetGamepadTouchpadFinger(
        gamepad: *mut SDL_Gamepad,
        touchpad: libc::c_int,
        finger: libc::c_int,
        state: *mut Uint8,
        x: *mut f32,
        y: *mut f32,
        pressure: *mut f32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Return whether a gamepad has a particular sensor.\n\n \\param gamepad The gamepad to query\n \\param type The type of sensor to query\n \\returns SDL_TRUE if the sensor exists, SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GamepadHasSensor(gamepad: *mut SDL_Gamepad, type_: SDL_SensorType) -> SDL_bool;
}
extern "C" {
    #[doc = " Set whether data reporting for a gamepad sensor is enabled.\n\n \\param gamepad The gamepad to update\n \\param type The type of sensor to enable/disable\n \\param enabled Whether data reporting should be enabled\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_SetGamepadSensorEnabled(
        gamepad: *mut SDL_Gamepad,
        type_: SDL_SensorType,
        enabled: SDL_bool,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Query whether sensor data reporting is enabled for a gamepad.\n\n \\param gamepad The gamepad to query\n \\param type The type of sensor to query\n \\returns SDL_TRUE if the sensor is enabled, SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GamepadSensorEnabled(gamepad: *mut SDL_Gamepad, type_: SDL_SensorType) -> SDL_bool;
}
extern "C" {
    #[doc = " Get the data rate (number of events per second) of a gamepad sensor.\n\n \\param gamepad The gamepad to query\n \\param type The type of sensor to query\n \\returns the data rate, or 0.0f if the data rate is not available.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetGamepadSensorDataRate(gamepad: *mut SDL_Gamepad, type_: SDL_SensorType) -> f32;
}
extern "C" {
    #[doc = " Get the current state of a gamepad sensor.\n\n The number of values and interpretation of the data is sensor dependent.\n See SDL_sensor.h for the details for each type of sensor.\n\n \\param gamepad The gamepad to query\n \\param type The type of sensor to query\n \\param data A pointer filled with the current sensor state\n \\param num_values The number of values to write to data\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetGamepadSensorData(
        gamepad: *mut SDL_Gamepad,
        type_: SDL_SensorType,
        data: *mut f32,
        num_values: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Start a rumble effect on a gamepad.\n\n Each call to this function cancels any previous rumble effect, and calling\n it with 0 intensity stops any rumbling.\n\n \\param gamepad The gamepad to vibrate\n \\param low_frequency_rumble The intensity of the low frequency (left)\n                             rumble motor, from 0 to 0xFFFF\n \\param high_frequency_rumble The intensity of the high frequency (right)\n                              rumble motor, from 0 to 0xFFFF\n \\param duration_ms The duration of the rumble effect, in milliseconds\n \\returns 0, or -1 if rumble isn't supported on this gamepad\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GamepadHasRumble"]
    pub fn SDL_RumbleGamepad(
        gamepad: *mut SDL_Gamepad,
        low_frequency_rumble: Uint16,
        high_frequency_rumble: Uint16,
        duration_ms: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Start a rumble effect in the gamepad's triggers.\n\n Each call to this function cancels any previous trigger rumble effect, and\n calling it with 0 intensity stops any rumbling.\n\n Note that this is rumbling of the _triggers_ and not the gamepad as a\n whole. This is currently only supported on Xbox One gamepads. If you want\n the (more common) whole-gamepad rumble, use SDL_RumbleGamepad() instead.\n\n \\param gamepad The gamepad to vibrate\n \\param left_rumble The intensity of the left trigger rumble motor, from 0\n                    to 0xFFFF\n \\param right_rumble The intensity of the right trigger rumble motor, from 0\n                     to 0xFFFF\n \\param duration_ms The duration of the rumble effect, in milliseconds\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GamepadHasRumbleTriggers"]
    pub fn SDL_RumbleGamepadTriggers(
        gamepad: *mut SDL_Gamepad,
        left_rumble: Uint16,
        right_rumble: Uint16,
        duration_ms: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Query whether a gamepad has an LED.\n\n \\param gamepad The gamepad to query\n \\returns SDL_TRUE, or SDL_FALSE if this gamepad does not have a modifiable\n          LED\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GamepadHasLED(gamepad: *mut SDL_Gamepad) -> SDL_bool;
}
extern "C" {
    #[doc = " Query whether a gamepad has rumble support.\n\n \\param gamepad The gamepad to query\n \\returns SDL_TRUE, or SDL_FALSE if this gamepad does not have rumble\n          support\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_RumbleGamepad"]
    pub fn SDL_GamepadHasRumble(gamepad: *mut SDL_Gamepad) -> SDL_bool;
}
extern "C" {
    #[doc = " Query whether a gamepad has rumble support on triggers.\n\n \\param gamepad The gamepad to query\n \\returns SDL_TRUE, or SDL_FALSE if this gamepad does not have trigger\n          rumble support\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_RumbleGamepadTriggers"]
    pub fn SDL_GamepadHasRumbleTriggers(gamepad: *mut SDL_Gamepad) -> SDL_bool;
}
extern "C" {
    #[doc = " Update a gamepad's LED color.\n\n \\param gamepad The gamepad to update\n \\param red The intensity of the red LED\n \\param green The intensity of the green LED\n \\param blue The intensity of the blue LED\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_SetGamepadLED(
        gamepad: *mut SDL_Gamepad,
        red: Uint8,
        green: Uint8,
        blue: Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Send a gamepad specific effect packet\n\n \\param gamepad The gamepad to affect\n \\param data The data to send to the gamepad\n \\param size The size of the data to send to the gamepad\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_SendGamepadEffect(
        gamepad: *mut SDL_Gamepad,
        data: *const libc::c_void,
        size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Close a gamepad previously opened with SDL_OpenGamepad().\n\n \\param gamepad a gamepad identifier previously returned by\n                SDL_OpenGamepad()\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_OpenGamepad"]
    pub fn SDL_CloseGamepad(gamepad: *mut SDL_Gamepad);
}
extern "C" {
    #[doc = " Return the sfSymbolsName for a given button on a gamepad on Apple\n platforms.\n\n \\param gamepad the gamepad to query\n \\param button a button on the gamepad\n \\returns the sfSymbolsName or NULL if the name can't be found\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetGamepadAppleSFSymbolsNameForAxis"]
    pub fn SDL_GetGamepadAppleSFSymbolsNameForButton(
        gamepad: *mut SDL_Gamepad,
        button: SDL_GamepadButton,
    ) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Return the sfSymbolsName for a given axis on a gamepad on Apple platforms.\n\n \\param gamepad the gamepad to query\n \\param axis an axis on the gamepad\n \\returns the sfSymbolsName or NULL if the name can't be found\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetGamepadAppleSFSymbolsNameForButton"]
    pub fn SDL_GetGamepadAppleSFSymbolsNameForAxis(
        gamepad: *mut SDL_Gamepad,
        axis: SDL_GamepadAxis,
    ) -> *const libc::c_char;
}
#[repr(u32)]
#[doc = "  \\brief The SDL keyboard scancode representation.\n\n  Values of this type are used to represent keyboard keys, among other places\n  in the \\link SDL_Keysym::scancode key.keysym.scancode \\endlink field of the\n  SDL_Event structure.\n\n  The values in this enumeration are based on the USB usage page standard:\n  https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_Scancode {
    SDL_SCANCODE_UNKNOWN = 0,
    SDL_SCANCODE_A = 4,
    SDL_SCANCODE_B = 5,
    SDL_SCANCODE_C = 6,
    SDL_SCANCODE_D = 7,
    SDL_SCANCODE_E = 8,
    SDL_SCANCODE_F = 9,
    SDL_SCANCODE_G = 10,
    SDL_SCANCODE_H = 11,
    SDL_SCANCODE_I = 12,
    SDL_SCANCODE_J = 13,
    SDL_SCANCODE_K = 14,
    SDL_SCANCODE_L = 15,
    SDL_SCANCODE_M = 16,
    SDL_SCANCODE_N = 17,
    SDL_SCANCODE_O = 18,
    SDL_SCANCODE_P = 19,
    SDL_SCANCODE_Q = 20,
    SDL_SCANCODE_R = 21,
    SDL_SCANCODE_S = 22,
    SDL_SCANCODE_T = 23,
    SDL_SCANCODE_U = 24,
    SDL_SCANCODE_V = 25,
    SDL_SCANCODE_W = 26,
    SDL_SCANCODE_X = 27,
    SDL_SCANCODE_Y = 28,
    SDL_SCANCODE_Z = 29,
    SDL_SCANCODE_1 = 30,
    SDL_SCANCODE_2 = 31,
    SDL_SCANCODE_3 = 32,
    SDL_SCANCODE_4 = 33,
    SDL_SCANCODE_5 = 34,
    SDL_SCANCODE_6 = 35,
    SDL_SCANCODE_7 = 36,
    SDL_SCANCODE_8 = 37,
    SDL_SCANCODE_9 = 38,
    SDL_SCANCODE_0 = 39,
    SDL_SCANCODE_RETURN = 40,
    SDL_SCANCODE_ESCAPE = 41,
    SDL_SCANCODE_BACKSPACE = 42,
    SDL_SCANCODE_TAB = 43,
    SDL_SCANCODE_SPACE = 44,
    SDL_SCANCODE_MINUS = 45,
    SDL_SCANCODE_EQUALS = 46,
    SDL_SCANCODE_LEFTBRACKET = 47,
    SDL_SCANCODE_RIGHTBRACKET = 48,
    #[doc = "< Located at the lower left of the return\n   key on ISO keyboards and at the right end\n   of the QWERTY row on ANSI keyboards.\n   Produces REVERSE SOLIDUS (backslash) and\n   VERTICAL LINE in a US layout, REVERSE\n   SOLIDUS and VERTICAL LINE in a UK Mac\n   layout, NUMBER SIGN and TILDE in a UK\n   Windows layout, DOLLAR SIGN and POUND SIGN\n   in a Swiss German layout, NUMBER SIGN and\n   APOSTROPHE in a German layout, GRAVE\n   ACCENT and POUND SIGN in a French Mac\n   layout, and ASTERISK and MICRO SIGN in a\n   French Windows layout."]
    SDL_SCANCODE_BACKSLASH = 49,
    #[doc = "< ISO USB keyboards actually use this code\n   instead of 49 for the same key, but all\n   OSes I've seen treat the two codes\n   identically. So, as an implementor, unless\n   your keyboard generates both of those\n   codes and your OS treats them differently,\n   you should generate SDL_SCANCODE_BACKSLASH\n   instead of this code. As a user, you\n   should not rely on this code because SDL\n   will never generate it with most (all?)\n   keyboards."]
    SDL_SCANCODE_NONUSHASH = 50,
    SDL_SCANCODE_SEMICOLON = 51,
    SDL_SCANCODE_APOSTROPHE = 52,
    #[doc = "< Located in the top left corner (on both ANSI\n   and ISO keyboards). Produces GRAVE ACCENT and\n   TILDE in a US Windows layout and in US and UK\n   Mac layouts on ANSI keyboards, GRAVE ACCENT\n   and NOT SIGN in a UK Windows layout, SECTION\n   SIGN and PLUS-MINUS SIGN in US and UK Mac\n   layouts on ISO keyboards, SECTION SIGN and\n   DEGREE SIGN in a Swiss German layout (Mac:\n   only on ISO keyboards), CIRCUMFLEX ACCENT and\n   DEGREE SIGN in a German layout (Mac: only on\n   ISO keyboards), SUPERSCRIPT TWO and TILDE in a\n   French Windows layout, COMMERCIAL AT and\n   NUMBER SIGN in a French Mac layout on ISO\n   keyboards, and LESS-THAN SIGN and GREATER-THAN\n   SIGN in a Swiss German, German, or French Mac\n   layout on ANSI keyboards."]
    SDL_SCANCODE_GRAVE = 53,
    SDL_SCANCODE_COMMA = 54,
    SDL_SCANCODE_PERIOD = 55,
    SDL_SCANCODE_SLASH = 56,
    SDL_SCANCODE_CAPSLOCK = 57,
    SDL_SCANCODE_F1 = 58,
    SDL_SCANCODE_F2 = 59,
    SDL_SCANCODE_F3 = 60,
    SDL_SCANCODE_F4 = 61,
    SDL_SCANCODE_F5 = 62,
    SDL_SCANCODE_F6 = 63,
    SDL_SCANCODE_F7 = 64,
    SDL_SCANCODE_F8 = 65,
    SDL_SCANCODE_F9 = 66,
    SDL_SCANCODE_F10 = 67,
    SDL_SCANCODE_F11 = 68,
    SDL_SCANCODE_F12 = 69,
    SDL_SCANCODE_PRINTSCREEN = 70,
    SDL_SCANCODE_SCROLLLOCK = 71,
    SDL_SCANCODE_PAUSE = 72,
    #[doc = "< insert on PC, help on some Mac keyboards (but\ndoes send code 73, not 117)"]
    SDL_SCANCODE_INSERT = 73,
    SDL_SCANCODE_HOME = 74,
    SDL_SCANCODE_PAGEUP = 75,
    SDL_SCANCODE_DELETE = 76,
    SDL_SCANCODE_END = 77,
    SDL_SCANCODE_PAGEDOWN = 78,
    SDL_SCANCODE_RIGHT = 79,
    SDL_SCANCODE_LEFT = 80,
    SDL_SCANCODE_DOWN = 81,
    SDL_SCANCODE_UP = 82,
    #[doc = "< num lock on PC, clear on Mac keyboards"]
    SDL_SCANCODE_NUMLOCKCLEAR = 83,
    SDL_SCANCODE_KP_DIVIDE = 84,
    SDL_SCANCODE_KP_MULTIPLY = 85,
    SDL_SCANCODE_KP_MINUS = 86,
    SDL_SCANCODE_KP_PLUS = 87,
    SDL_SCANCODE_KP_ENTER = 88,
    SDL_SCANCODE_KP_1 = 89,
    SDL_SCANCODE_KP_2 = 90,
    SDL_SCANCODE_KP_3 = 91,
    SDL_SCANCODE_KP_4 = 92,
    SDL_SCANCODE_KP_5 = 93,
    SDL_SCANCODE_KP_6 = 94,
    SDL_SCANCODE_KP_7 = 95,
    SDL_SCANCODE_KP_8 = 96,
    SDL_SCANCODE_KP_9 = 97,
    SDL_SCANCODE_KP_0 = 98,
    SDL_SCANCODE_KP_PERIOD = 99,
    #[doc = "< This is the additional key that ISO\n   keyboards have over ANSI ones,\n   located between left shift and Y.\n   Produces GRAVE ACCENT and TILDE in a\n   US or UK Mac layout, REVERSE SOLIDUS\n   (backslash) and VERTICAL LINE in a\n   US or UK Windows layout, and\n   LESS-THAN SIGN and GREATER-THAN SIGN\n   in a Swiss German, German, or French\n   layout."]
    SDL_SCANCODE_NONUSBACKSLASH = 100,
    #[doc = "< windows contextual menu, compose"]
    SDL_SCANCODE_APPLICATION = 101,
    #[doc = "< The USB document says this is a status flag,\n   not a physical key - but some Mac keyboards\n   do have a power key."]
    SDL_SCANCODE_POWER = 102,
    SDL_SCANCODE_KP_EQUALS = 103,
    SDL_SCANCODE_F13 = 104,
    SDL_SCANCODE_F14 = 105,
    SDL_SCANCODE_F15 = 106,
    SDL_SCANCODE_F16 = 107,
    SDL_SCANCODE_F17 = 108,
    SDL_SCANCODE_F18 = 109,
    SDL_SCANCODE_F19 = 110,
    SDL_SCANCODE_F20 = 111,
    SDL_SCANCODE_F21 = 112,
    SDL_SCANCODE_F22 = 113,
    SDL_SCANCODE_F23 = 114,
    SDL_SCANCODE_F24 = 115,
    SDL_SCANCODE_EXECUTE = 116,
    #[doc = "< AL Integrated Help Center"]
    SDL_SCANCODE_HELP = 117,
    #[doc = "< Menu (show menu)"]
    SDL_SCANCODE_MENU = 118,
    SDL_SCANCODE_SELECT = 119,
    #[doc = "< AC Stop"]
    SDL_SCANCODE_STOP = 120,
    #[doc = "< AC Redo/Repeat"]
    SDL_SCANCODE_AGAIN = 121,
    #[doc = "< AC Undo"]
    SDL_SCANCODE_UNDO = 122,
    #[doc = "< AC Cut"]
    SDL_SCANCODE_CUT = 123,
    #[doc = "< AC Copy"]
    SDL_SCANCODE_COPY = 124,
    #[doc = "< AC Paste"]
    SDL_SCANCODE_PASTE = 125,
    #[doc = "< AC Find"]
    SDL_SCANCODE_FIND = 126,
    SDL_SCANCODE_MUTE = 127,
    SDL_SCANCODE_VOLUMEUP = 128,
    SDL_SCANCODE_VOLUMEDOWN = 129,
    SDL_SCANCODE_KP_COMMA = 133,
    SDL_SCANCODE_KP_EQUALSAS400 = 134,
    #[doc = "< used on Asian keyboards, see\nfootnotes in USB doc"]
    SDL_SCANCODE_INTERNATIONAL1 = 135,
    SDL_SCANCODE_INTERNATIONAL2 = 136,
    #[doc = "< Yen"]
    SDL_SCANCODE_INTERNATIONAL3 = 137,
    SDL_SCANCODE_INTERNATIONAL4 = 138,
    SDL_SCANCODE_INTERNATIONAL5 = 139,
    SDL_SCANCODE_INTERNATIONAL6 = 140,
    SDL_SCANCODE_INTERNATIONAL7 = 141,
    SDL_SCANCODE_INTERNATIONAL8 = 142,
    SDL_SCANCODE_INTERNATIONAL9 = 143,
    #[doc = "< Hangul/English toggle"]
    SDL_SCANCODE_LANG1 = 144,
    #[doc = "< Hanja conversion"]
    SDL_SCANCODE_LANG2 = 145,
    #[doc = "< Katakana"]
    SDL_SCANCODE_LANG3 = 146,
    #[doc = "< Hiragana"]
    SDL_SCANCODE_LANG4 = 147,
    #[doc = "< Zenkaku/Hankaku"]
    SDL_SCANCODE_LANG5 = 148,
    #[doc = "< reserved"]
    SDL_SCANCODE_LANG6 = 149,
    #[doc = "< reserved"]
    SDL_SCANCODE_LANG7 = 150,
    #[doc = "< reserved"]
    SDL_SCANCODE_LANG8 = 151,
    #[doc = "< reserved"]
    SDL_SCANCODE_LANG9 = 152,
    #[doc = "< Erase-Eaze"]
    SDL_SCANCODE_ALTERASE = 153,
    SDL_SCANCODE_SYSREQ = 154,
    #[doc = "< AC Cancel"]
    SDL_SCANCODE_CANCEL = 155,
    SDL_SCANCODE_CLEAR = 156,
    SDL_SCANCODE_PRIOR = 157,
    SDL_SCANCODE_RETURN2 = 158,
    SDL_SCANCODE_SEPARATOR = 159,
    SDL_SCANCODE_OUT = 160,
    SDL_SCANCODE_OPER = 161,
    SDL_SCANCODE_CLEARAGAIN = 162,
    SDL_SCANCODE_CRSEL = 163,
    SDL_SCANCODE_EXSEL = 164,
    SDL_SCANCODE_KP_00 = 176,
    SDL_SCANCODE_KP_000 = 177,
    SDL_SCANCODE_THOUSANDSSEPARATOR = 178,
    SDL_SCANCODE_DECIMALSEPARATOR = 179,
    SDL_SCANCODE_CURRENCYUNIT = 180,
    SDL_SCANCODE_CURRENCYSUBUNIT = 181,
    SDL_SCANCODE_KP_LEFTPAREN = 182,
    SDL_SCANCODE_KP_RIGHTPAREN = 183,
    SDL_SCANCODE_KP_LEFTBRACE = 184,
    SDL_SCANCODE_KP_RIGHTBRACE = 185,
    SDL_SCANCODE_KP_TAB = 186,
    SDL_SCANCODE_KP_BACKSPACE = 187,
    SDL_SCANCODE_KP_A = 188,
    SDL_SCANCODE_KP_B = 189,
    SDL_SCANCODE_KP_C = 190,
    SDL_SCANCODE_KP_D = 191,
    SDL_SCANCODE_KP_E = 192,
    SDL_SCANCODE_KP_F = 193,
    SDL_SCANCODE_KP_XOR = 194,
    SDL_SCANCODE_KP_POWER = 195,
    SDL_SCANCODE_KP_PERCENT = 196,
    SDL_SCANCODE_KP_LESS = 197,
    SDL_SCANCODE_KP_GREATER = 198,
    SDL_SCANCODE_KP_AMPERSAND = 199,
    SDL_SCANCODE_KP_DBLAMPERSAND = 200,
    SDL_SCANCODE_KP_VERTICALBAR = 201,
    SDL_SCANCODE_KP_DBLVERTICALBAR = 202,
    SDL_SCANCODE_KP_COLON = 203,
    SDL_SCANCODE_KP_HASH = 204,
    SDL_SCANCODE_KP_SPACE = 205,
    SDL_SCANCODE_KP_AT = 206,
    SDL_SCANCODE_KP_EXCLAM = 207,
    SDL_SCANCODE_KP_MEMSTORE = 208,
    SDL_SCANCODE_KP_MEMRECALL = 209,
    SDL_SCANCODE_KP_MEMCLEAR = 210,
    SDL_SCANCODE_KP_MEMADD = 211,
    SDL_SCANCODE_KP_MEMSUBTRACT = 212,
    SDL_SCANCODE_KP_MEMMULTIPLY = 213,
    SDL_SCANCODE_KP_MEMDIVIDE = 214,
    SDL_SCANCODE_KP_PLUSMINUS = 215,
    SDL_SCANCODE_KP_CLEAR = 216,
    SDL_SCANCODE_KP_CLEARENTRY = 217,
    SDL_SCANCODE_KP_BINARY = 218,
    SDL_SCANCODE_KP_OCTAL = 219,
    SDL_SCANCODE_KP_DECIMAL = 220,
    SDL_SCANCODE_KP_HEXADECIMAL = 221,
    SDL_SCANCODE_LCTRL = 224,
    SDL_SCANCODE_LSHIFT = 225,
    #[doc = "< alt, option"]
    SDL_SCANCODE_LALT = 226,
    #[doc = "< windows, command (apple), meta"]
    SDL_SCANCODE_LGUI = 227,
    SDL_SCANCODE_RCTRL = 228,
    SDL_SCANCODE_RSHIFT = 229,
    #[doc = "< alt gr, option"]
    SDL_SCANCODE_RALT = 230,
    #[doc = "< windows, command (apple), meta"]
    SDL_SCANCODE_RGUI = 231,
    #[doc = "< I'm not sure if this is really not covered\n   by any of the above, but since there's a\n   special SDL_KMOD_MODE for it I'm adding it here"]
    SDL_SCANCODE_MODE = 257,
    SDL_SCANCODE_AUDIONEXT = 258,
    SDL_SCANCODE_AUDIOPREV = 259,
    SDL_SCANCODE_AUDIOSTOP = 260,
    SDL_SCANCODE_AUDIOPLAY = 261,
    SDL_SCANCODE_AUDIOMUTE = 262,
    SDL_SCANCODE_MEDIASELECT = 263,
    #[doc = "< AL Internet Browser"]
    SDL_SCANCODE_WWW = 264,
    SDL_SCANCODE_MAIL = 265,
    #[doc = "< AL Calculator"]
    SDL_SCANCODE_CALCULATOR = 266,
    SDL_SCANCODE_COMPUTER = 267,
    #[doc = "< AC Search"]
    SDL_SCANCODE_AC_SEARCH = 268,
    #[doc = "< AC Home"]
    SDL_SCANCODE_AC_HOME = 269,
    #[doc = "< AC Back"]
    SDL_SCANCODE_AC_BACK = 270,
    #[doc = "< AC Forward"]
    SDL_SCANCODE_AC_FORWARD = 271,
    #[doc = "< AC Stop"]
    SDL_SCANCODE_AC_STOP = 272,
    #[doc = "< AC Refresh"]
    SDL_SCANCODE_AC_REFRESH = 273,
    #[doc = "< AC Bookmarks"]
    SDL_SCANCODE_AC_BOOKMARKS = 274,
    SDL_SCANCODE_BRIGHTNESSDOWN = 275,
    SDL_SCANCODE_BRIGHTNESSUP = 276,
    #[doc = "< display mirroring/dual display\nswitch, video mode switch"]
    SDL_SCANCODE_DISPLAYSWITCH = 277,
    SDL_SCANCODE_KBDILLUMTOGGLE = 278,
    SDL_SCANCODE_KBDILLUMDOWN = 279,
    SDL_SCANCODE_KBDILLUMUP = 280,
    SDL_SCANCODE_EJECT = 281,
    #[doc = "< SC System Sleep"]
    SDL_SCANCODE_SLEEP = 282,
    SDL_SCANCODE_APP1 = 283,
    SDL_SCANCODE_APP2 = 284,
    SDL_SCANCODE_AUDIOREWIND = 285,
    SDL_SCANCODE_AUDIOFASTFORWARD = 286,
    #[doc = "< Usually situated below the display on phones and\nused as a multi-function feature key for selecting\na software defined function shown on the bottom left\nof the display."]
    SDL_SCANCODE_SOFTLEFT = 287,
    #[doc = "< Usually situated below the display on phones and\nused as a multi-function feature key for selecting\na software defined function shown on the bottom right\nof the display."]
    SDL_SCANCODE_SOFTRIGHT = 288,
    #[doc = "< Used for accepting phone calls."]
    SDL_SCANCODE_CALL = 289,
    #[doc = "< Used for rejecting phone calls."]
    SDL_SCANCODE_ENDCALL = 290,
    #[doc = "< not a key, just marks the number of scancodes\nfor array bounds"]
    SDL_NUM_SCANCODES = 512,
}
#[doc = "  \\brief The SDL virtual key representation.\n\n  Values of this type are used to represent keyboard keys using the current\n  layout of the keyboard.  These values include Unicode values representing\n  the unmodified character that would be generated by pressing the key, or\n  an SDLK_* constant for those keys that do not generate characters.\n\n  A special exception is the number keys at the top of the keyboard which\n  map to SDLK_0...SDLK_9 on AZERTY layouts."]
pub type SDL_Keycode = Sint32;
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_KeyCode {
    SDLK_UNKNOWN = 0,
    SDLK_RETURN = 13,
    SDLK_ESCAPE = 27,
    SDLK_BACKSPACE = 8,
    SDLK_TAB = 9,
    SDLK_SPACE = 32,
    SDLK_EXCLAIM = 33,
    SDLK_QUOTEDBL = 34,
    SDLK_HASH = 35,
    SDLK_PERCENT = 37,
    SDLK_DOLLAR = 36,
    SDLK_AMPERSAND = 38,
    SDLK_QUOTE = 39,
    SDLK_LEFTPAREN = 40,
    SDLK_RIGHTPAREN = 41,
    SDLK_ASTERISK = 42,
    SDLK_PLUS = 43,
    SDLK_COMMA = 44,
    SDLK_MINUS = 45,
    SDLK_PERIOD = 46,
    SDLK_SLASH = 47,
    SDLK_0 = 48,
    SDLK_1 = 49,
    SDLK_2 = 50,
    SDLK_3 = 51,
    SDLK_4 = 52,
    SDLK_5 = 53,
    SDLK_6 = 54,
    SDLK_7 = 55,
    SDLK_8 = 56,
    SDLK_9 = 57,
    SDLK_COLON = 58,
    SDLK_SEMICOLON = 59,
    SDLK_LESS = 60,
    SDLK_EQUALS = 61,
    SDLK_GREATER = 62,
    SDLK_QUESTION = 63,
    SDLK_AT = 64,
    SDLK_LEFTBRACKET = 91,
    SDLK_BACKSLASH = 92,
    SDLK_RIGHTBRACKET = 93,
    SDLK_CARET = 94,
    SDLK_UNDERSCORE = 95,
    SDLK_BACKQUOTE = 96,
    SDLK_a = 97,
    SDLK_b = 98,
    SDLK_c = 99,
    SDLK_d = 100,
    SDLK_e = 101,
    SDLK_f = 102,
    SDLK_g = 103,
    SDLK_h = 104,
    SDLK_i = 105,
    SDLK_j = 106,
    SDLK_k = 107,
    SDLK_l = 108,
    SDLK_m = 109,
    SDLK_n = 110,
    SDLK_o = 111,
    SDLK_p = 112,
    SDLK_q = 113,
    SDLK_r = 114,
    SDLK_s = 115,
    SDLK_t = 116,
    SDLK_u = 117,
    SDLK_v = 118,
    SDLK_w = 119,
    SDLK_x = 120,
    SDLK_y = 121,
    SDLK_z = 122,
    SDLK_CAPSLOCK = 1073741881,
    SDLK_F1 = 1073741882,
    SDLK_F2 = 1073741883,
    SDLK_F3 = 1073741884,
    SDLK_F4 = 1073741885,
    SDLK_F5 = 1073741886,
    SDLK_F6 = 1073741887,
    SDLK_F7 = 1073741888,
    SDLK_F8 = 1073741889,
    SDLK_F9 = 1073741890,
    SDLK_F10 = 1073741891,
    SDLK_F11 = 1073741892,
    SDLK_F12 = 1073741893,
    SDLK_PRINTSCREEN = 1073741894,
    SDLK_SCROLLLOCK = 1073741895,
    SDLK_PAUSE = 1073741896,
    SDLK_INSERT = 1073741897,
    SDLK_HOME = 1073741898,
    SDLK_PAGEUP = 1073741899,
    SDLK_DELETE = 127,
    SDLK_END = 1073741901,
    SDLK_PAGEDOWN = 1073741902,
    SDLK_RIGHT = 1073741903,
    SDLK_LEFT = 1073741904,
    SDLK_DOWN = 1073741905,
    SDLK_UP = 1073741906,
    SDLK_NUMLOCKCLEAR = 1073741907,
    SDLK_KP_DIVIDE = 1073741908,
    SDLK_KP_MULTIPLY = 1073741909,
    SDLK_KP_MINUS = 1073741910,
    SDLK_KP_PLUS = 1073741911,
    SDLK_KP_ENTER = 1073741912,
    SDLK_KP_1 = 1073741913,
    SDLK_KP_2 = 1073741914,
    SDLK_KP_3 = 1073741915,
    SDLK_KP_4 = 1073741916,
    SDLK_KP_5 = 1073741917,
    SDLK_KP_6 = 1073741918,
    SDLK_KP_7 = 1073741919,
    SDLK_KP_8 = 1073741920,
    SDLK_KP_9 = 1073741921,
    SDLK_KP_0 = 1073741922,
    SDLK_KP_PERIOD = 1073741923,
    SDLK_APPLICATION = 1073741925,
    SDLK_POWER = 1073741926,
    SDLK_KP_EQUALS = 1073741927,
    SDLK_F13 = 1073741928,
    SDLK_F14 = 1073741929,
    SDLK_F15 = 1073741930,
    SDLK_F16 = 1073741931,
    SDLK_F17 = 1073741932,
    SDLK_F18 = 1073741933,
    SDLK_F19 = 1073741934,
    SDLK_F20 = 1073741935,
    SDLK_F21 = 1073741936,
    SDLK_F22 = 1073741937,
    SDLK_F23 = 1073741938,
    SDLK_F24 = 1073741939,
    SDLK_EXECUTE = 1073741940,
    SDLK_HELP = 1073741941,
    SDLK_MENU = 1073741942,
    SDLK_SELECT = 1073741943,
    SDLK_STOP = 1073741944,
    SDLK_AGAIN = 1073741945,
    SDLK_UNDO = 1073741946,
    SDLK_CUT = 1073741947,
    SDLK_COPY = 1073741948,
    SDLK_PASTE = 1073741949,
    SDLK_FIND = 1073741950,
    SDLK_MUTE = 1073741951,
    SDLK_VOLUMEUP = 1073741952,
    SDLK_VOLUMEDOWN = 1073741953,
    SDLK_KP_COMMA = 1073741957,
    SDLK_KP_EQUALSAS400 = 1073741958,
    SDLK_ALTERASE = 1073741977,
    SDLK_SYSREQ = 1073741978,
    SDLK_CANCEL = 1073741979,
    SDLK_CLEAR = 1073741980,
    SDLK_PRIOR = 1073741981,
    SDLK_RETURN2 = 1073741982,
    SDLK_SEPARATOR = 1073741983,
    SDLK_OUT = 1073741984,
    SDLK_OPER = 1073741985,
    SDLK_CLEARAGAIN = 1073741986,
    SDLK_CRSEL = 1073741987,
    SDLK_EXSEL = 1073741988,
    SDLK_KP_00 = 1073742000,
    SDLK_KP_000 = 1073742001,
    SDLK_THOUSANDSSEPARATOR = 1073742002,
    SDLK_DECIMALSEPARATOR = 1073742003,
    SDLK_CURRENCYUNIT = 1073742004,
    SDLK_CURRENCYSUBUNIT = 1073742005,
    SDLK_KP_LEFTPAREN = 1073742006,
    SDLK_KP_RIGHTPAREN = 1073742007,
    SDLK_KP_LEFTBRACE = 1073742008,
    SDLK_KP_RIGHTBRACE = 1073742009,
    SDLK_KP_TAB = 1073742010,
    SDLK_KP_BACKSPACE = 1073742011,
    SDLK_KP_A = 1073742012,
    SDLK_KP_B = 1073742013,
    SDLK_KP_C = 1073742014,
    SDLK_KP_D = 1073742015,
    SDLK_KP_E = 1073742016,
    SDLK_KP_F = 1073742017,
    SDLK_KP_XOR = 1073742018,
    SDLK_KP_POWER = 1073742019,
    SDLK_KP_PERCENT = 1073742020,
    SDLK_KP_LESS = 1073742021,
    SDLK_KP_GREATER = 1073742022,
    SDLK_KP_AMPERSAND = 1073742023,
    SDLK_KP_DBLAMPERSAND = 1073742024,
    SDLK_KP_VERTICALBAR = 1073742025,
    SDLK_KP_DBLVERTICALBAR = 1073742026,
    SDLK_KP_COLON = 1073742027,
    SDLK_KP_HASH = 1073742028,
    SDLK_KP_SPACE = 1073742029,
    SDLK_KP_AT = 1073742030,
    SDLK_KP_EXCLAM = 1073742031,
    SDLK_KP_MEMSTORE = 1073742032,
    SDLK_KP_MEMRECALL = 1073742033,
    SDLK_KP_MEMCLEAR = 1073742034,
    SDLK_KP_MEMADD = 1073742035,
    SDLK_KP_MEMSUBTRACT = 1073742036,
    SDLK_KP_MEMMULTIPLY = 1073742037,
    SDLK_KP_MEMDIVIDE = 1073742038,
    SDLK_KP_PLUSMINUS = 1073742039,
    SDLK_KP_CLEAR = 1073742040,
    SDLK_KP_CLEARENTRY = 1073742041,
    SDLK_KP_BINARY = 1073742042,
    SDLK_KP_OCTAL = 1073742043,
    SDLK_KP_DECIMAL = 1073742044,
    SDLK_KP_HEXADECIMAL = 1073742045,
    SDLK_LCTRL = 1073742048,
    SDLK_LSHIFT = 1073742049,
    SDLK_LALT = 1073742050,
    SDLK_LGUI = 1073742051,
    SDLK_RCTRL = 1073742052,
    SDLK_RSHIFT = 1073742053,
    SDLK_RALT = 1073742054,
    SDLK_RGUI = 1073742055,
    SDLK_MODE = 1073742081,
    SDLK_AUDIONEXT = 1073742082,
    SDLK_AUDIOPREV = 1073742083,
    SDLK_AUDIOSTOP = 1073742084,
    SDLK_AUDIOPLAY = 1073742085,
    SDLK_AUDIOMUTE = 1073742086,
    SDLK_MEDIASELECT = 1073742087,
    SDLK_WWW = 1073742088,
    SDLK_MAIL = 1073742089,
    SDLK_CALCULATOR = 1073742090,
    SDLK_COMPUTER = 1073742091,
    SDLK_AC_SEARCH = 1073742092,
    SDLK_AC_HOME = 1073742093,
    SDLK_AC_BACK = 1073742094,
    SDLK_AC_FORWARD = 1073742095,
    SDLK_AC_STOP = 1073742096,
    SDLK_AC_REFRESH = 1073742097,
    SDLK_AC_BOOKMARKS = 1073742098,
    SDLK_BRIGHTNESSDOWN = 1073742099,
    SDLK_BRIGHTNESSUP = 1073742100,
    SDLK_DISPLAYSWITCH = 1073742101,
    SDLK_KBDILLUMTOGGLE = 1073742102,
    SDLK_KBDILLUMDOWN = 1073742103,
    SDLK_KBDILLUMUP = 1073742104,
    SDLK_EJECT = 1073742105,
    SDLK_SLEEP = 1073742106,
    SDLK_APP1 = 1073742107,
    SDLK_APP2 = 1073742108,
    SDLK_AUDIOREWIND = 1073742109,
    SDLK_AUDIOFASTFORWARD = 1073742110,
    SDLK_SOFTLEFT = 1073742111,
    SDLK_SOFTRIGHT = 1073742112,
    SDLK_CALL = 1073742113,
    SDLK_ENDCALL = 1073742114,
}
impl SDL_Keymod {
    pub const SDL_KMOD_RESERVED: SDL_Keymod = SDL_Keymod::SDL_KMOD_SCROLL;
}
#[repr(u32)]
#[doc = " \\brief Enumeration of valid key mods (possibly OR'd together)."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_Keymod {
    SDL_KMOD_NONE = 0,
    SDL_KMOD_LSHIFT = 1,
    SDL_KMOD_RSHIFT = 2,
    SDL_KMOD_LCTRL = 64,
    SDL_KMOD_RCTRL = 128,
    SDL_KMOD_LALT = 256,
    SDL_KMOD_RALT = 512,
    SDL_KMOD_LGUI = 1024,
    SDL_KMOD_RGUI = 2048,
    SDL_KMOD_NUM = 4096,
    SDL_KMOD_CAPS = 8192,
    SDL_KMOD_MODE = 16384,
    SDL_KMOD_SCROLL = 32768,
    SDL_KMOD_CTRL = 192,
    SDL_KMOD_SHIFT = 3,
    SDL_KMOD_ALT = 768,
    SDL_KMOD_GUI = 3072,
}
#[repr(u32)]
#[doc = " Pixel type."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_PixelType {
    SDL_PIXELTYPE_UNKNOWN = 0,
    SDL_PIXELTYPE_INDEX1 = 1,
    SDL_PIXELTYPE_INDEX4 = 2,
    SDL_PIXELTYPE_INDEX8 = 3,
    SDL_PIXELTYPE_PACKED8 = 4,
    SDL_PIXELTYPE_PACKED16 = 5,
    SDL_PIXELTYPE_PACKED32 = 6,
    SDL_PIXELTYPE_ARRAYU8 = 7,
    SDL_PIXELTYPE_ARRAYU16 = 8,
    SDL_PIXELTYPE_ARRAYU32 = 9,
    SDL_PIXELTYPE_ARRAYF16 = 10,
    SDL_PIXELTYPE_ARRAYF32 = 11,
}
#[repr(u32)]
#[doc = " Bitmap pixel order, high bit -> low bit."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_BitmapOrder {
    SDL_BITMAPORDER_NONE = 0,
    SDL_BITMAPORDER_4321 = 1,
    SDL_BITMAPORDER_1234 = 2,
}
#[repr(u32)]
#[doc = " Packed component order, high bit -> low bit."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_PackedOrder {
    SDL_PACKEDORDER_NONE = 0,
    SDL_PACKEDORDER_XRGB = 1,
    SDL_PACKEDORDER_RGBX = 2,
    SDL_PACKEDORDER_ARGB = 3,
    SDL_PACKEDORDER_RGBA = 4,
    SDL_PACKEDORDER_XBGR = 5,
    SDL_PACKEDORDER_BGRX = 6,
    SDL_PACKEDORDER_ABGR = 7,
    SDL_PACKEDORDER_BGRA = 8,
}
#[repr(u32)]
#[doc = " Array component order, low byte -> high byte."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_ArrayOrder {
    SDL_ARRAYORDER_NONE = 0,
    SDL_ARRAYORDER_RGB = 1,
    SDL_ARRAYORDER_BGR = 2,
}
#[repr(u32)]
#[doc = " Packed component layout."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_PackedLayout {
    SDL_PACKEDLAYOUT_NONE = 0,
    SDL_PACKEDLAYOUT_332 = 1,
    SDL_PACKEDLAYOUT_4444 = 2,
    SDL_PACKEDLAYOUT_1555 = 3,
    SDL_PACKEDLAYOUT_5551 = 4,
    SDL_PACKEDLAYOUT_565 = 5,
    SDL_PACKEDLAYOUT_8888 = 6,
    SDL_PACKEDLAYOUT_2101010 = 7,
    SDL_PACKEDLAYOUT_1010102 = 8,
}
impl SDL_PixelFormatEnum {
    pub const SDL_PIXELFORMAT_RGB444: SDL_PixelFormatEnum =
        SDL_PixelFormatEnum::SDL_PIXELFORMAT_XRGB4444;
}
impl SDL_PixelFormatEnum {
    pub const SDL_PIXELFORMAT_BGR444: SDL_PixelFormatEnum =
        SDL_PixelFormatEnum::SDL_PIXELFORMAT_XBGR4444;
}
impl SDL_PixelFormatEnum {
    pub const SDL_PIXELFORMAT_RGB555: SDL_PixelFormatEnum =
        SDL_PixelFormatEnum::SDL_PIXELFORMAT_XRGB1555;
}
impl SDL_PixelFormatEnum {
    pub const SDL_PIXELFORMAT_BGR555: SDL_PixelFormatEnum =
        SDL_PixelFormatEnum::SDL_PIXELFORMAT_XBGR1555;
}
impl SDL_PixelFormatEnum {
    pub const SDL_PIXELFORMAT_RGBA32: SDL_PixelFormatEnum =
        SDL_PixelFormatEnum::SDL_PIXELFORMAT_ABGR8888;
}
impl SDL_PixelFormatEnum {
    pub const SDL_PIXELFORMAT_ARGB32: SDL_PixelFormatEnum =
        SDL_PixelFormatEnum::SDL_PIXELFORMAT_BGRA8888;
}
impl SDL_PixelFormatEnum {
    pub const SDL_PIXELFORMAT_BGRA32: SDL_PixelFormatEnum =
        SDL_PixelFormatEnum::SDL_PIXELFORMAT_ARGB8888;
}
impl SDL_PixelFormatEnum {
    pub const SDL_PIXELFORMAT_ABGR32: SDL_PixelFormatEnum =
        SDL_PixelFormatEnum::SDL_PIXELFORMAT_RGBA8888;
}
impl SDL_PixelFormatEnum {
    pub const SDL_PIXELFORMAT_RGBX32: SDL_PixelFormatEnum =
        SDL_PixelFormatEnum::SDL_PIXELFORMAT_XBGR8888;
}
impl SDL_PixelFormatEnum {
    pub const SDL_PIXELFORMAT_XRGB32: SDL_PixelFormatEnum =
        SDL_PixelFormatEnum::SDL_PIXELFORMAT_BGRX8888;
}
impl SDL_PixelFormatEnum {
    pub const SDL_PIXELFORMAT_BGRX32: SDL_PixelFormatEnum =
        SDL_PixelFormatEnum::SDL_PIXELFORMAT_XRGB8888;
}
impl SDL_PixelFormatEnum {
    pub const SDL_PIXELFORMAT_XBGR32: SDL_PixelFormatEnum =
        SDL_PixelFormatEnum::SDL_PIXELFORMAT_RGBX8888;
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_PixelFormatEnum {
    SDL_PIXELFORMAT_UNKNOWN = 0,
    SDL_PIXELFORMAT_INDEX1LSB = 286261504,
    SDL_PIXELFORMAT_INDEX1MSB = 287310080,
    SDL_PIXELFORMAT_INDEX4LSB = 303039488,
    SDL_PIXELFORMAT_INDEX4MSB = 304088064,
    SDL_PIXELFORMAT_INDEX8 = 318769153,
    SDL_PIXELFORMAT_RGB332 = 336660481,
    SDL_PIXELFORMAT_XRGB4444 = 353504258,
    SDL_PIXELFORMAT_XBGR4444 = 357698562,
    SDL_PIXELFORMAT_XRGB1555 = 353570562,
    SDL_PIXELFORMAT_XBGR1555 = 357764866,
    SDL_PIXELFORMAT_ARGB4444 = 355602434,
    SDL_PIXELFORMAT_RGBA4444 = 356651010,
    SDL_PIXELFORMAT_ABGR4444 = 359796738,
    SDL_PIXELFORMAT_BGRA4444 = 360845314,
    SDL_PIXELFORMAT_ARGB1555 = 355667970,
    SDL_PIXELFORMAT_RGBA5551 = 356782082,
    SDL_PIXELFORMAT_ABGR1555 = 359862274,
    SDL_PIXELFORMAT_BGRA5551 = 360976386,
    SDL_PIXELFORMAT_RGB565 = 353701890,
    SDL_PIXELFORMAT_BGR565 = 357896194,
    SDL_PIXELFORMAT_RGB24 = 386930691,
    SDL_PIXELFORMAT_BGR24 = 387979267,
    SDL_PIXELFORMAT_XRGB8888 = 370546692,
    SDL_PIXELFORMAT_RGBX8888 = 371595268,
    SDL_PIXELFORMAT_XBGR8888 = 374740996,
    SDL_PIXELFORMAT_BGRX8888 = 375789572,
    SDL_PIXELFORMAT_ARGB8888 = 372645892,
    SDL_PIXELFORMAT_RGBA8888 = 373694468,
    SDL_PIXELFORMAT_ABGR8888 = 376840196,
    SDL_PIXELFORMAT_BGRA8888 = 377888772,
    SDL_PIXELFORMAT_ARGB2101010 = 372711428,
    #[doc = "< Planar mode: Y + V + U  (3 planes)"]
    SDL_PIXELFORMAT_YV12 = 842094169,
    #[doc = "< Planar mode: Y + U + V  (3 planes)"]
    SDL_PIXELFORMAT_IYUV = 1448433993,
    #[doc = "< Packed mode: Y0+U0+Y1+V0 (1 plane)"]
    SDL_PIXELFORMAT_YUY2 = 844715353,
    #[doc = "< Packed mode: U0+Y0+V0+Y1 (1 plane)"]
    SDL_PIXELFORMAT_UYVY = 1498831189,
    #[doc = "< Packed mode: Y0+V0+Y1+U0 (1 plane)"]
    SDL_PIXELFORMAT_YVYU = 1431918169,
    #[doc = "< Planar mode: Y + U/V interleaved  (2 planes)"]
    SDL_PIXELFORMAT_NV12 = 842094158,
    #[doc = "< Planar mode: Y + V/U interleaved  (2 planes)"]
    SDL_PIXELFORMAT_NV21 = 825382478,
    #[doc = "< Android video texture format"]
    SDL_PIXELFORMAT_EXTERNAL_OES = 542328143,
}
#[doc = " The bits of this structure can be directly reinterpreted as an integer-packed\n color which uses the SDL_PIXELFORMAT_RGBA32 format (SDL_PIXELFORMAT_ABGR8888\n on little-endian systems and SDL_PIXELFORMAT_RGBA8888 on big-endian systems)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Color {
    pub r: Uint8,
    pub g: Uint8,
    pub b: Uint8,
    pub a: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_Color() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_Color> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_Color>(),
        4usize,
        concat!("Size of: ", stringify!(SDL_Color))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Color>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_Color))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Color),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).g) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Color),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Color),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Color),
            "::",
            stringify!(a)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Palette {
    pub ncolors: libc::c_int,
    pub colors: *mut SDL_Color,
    pub version: Uint32,
    pub refcount: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Palette() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_Palette> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_Palette>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_Palette))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Palette>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_Palette))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ncolors) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Palette),
            "::",
            stringify!(ncolors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).colors) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Palette),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Palette),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).refcount) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Palette),
            "::",
            stringify!(refcount)
        )
    );
}
#[doc = "  \\note Everything in the pixel format structure is read-only."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_PixelFormat {
    pub format: Uint32,
    pub palette: *mut SDL_Palette,
    pub BitsPerPixel: Uint8,
    pub BytesPerPixel: Uint8,
    pub padding: [Uint8; 2usize],
    pub Rmask: Uint32,
    pub Gmask: Uint32,
    pub Bmask: Uint32,
    pub Amask: Uint32,
    pub Rloss: Uint8,
    pub Gloss: Uint8,
    pub Bloss: Uint8,
    pub Aloss: Uint8,
    pub Rshift: Uint8,
    pub Gshift: Uint8,
    pub Bshift: Uint8,
    pub Ashift: Uint8,
    pub refcount: libc::c_int,
    pub next: *mut SDL_PixelFormat,
}
#[test]
fn bindgen_test_layout_SDL_PixelFormat() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_PixelFormat> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_PixelFormat>(),
        56usize,
        concat!("Size of: ", stringify!(SDL_PixelFormat))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_PixelFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_PixelFormat))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).palette) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(palette)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BitsPerPixel) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(BitsPerPixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BytesPerPixel) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(BytesPerPixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Rmask) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Rmask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gmask) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Gmask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Bmask) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Bmask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Amask) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Amask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Rloss) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Rloss)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gloss) as usize - ptr as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Gloss)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Bloss) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Bloss)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Aloss) as usize - ptr as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Aloss)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Rshift) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Rshift)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gshift) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Gshift)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Bshift) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Bshift)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Ashift) as usize - ptr as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Ashift)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).refcount) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    #[doc = " Get the human readable name of a pixel format.\n\n \\param format the pixel format to query\n \\returns the human readable name of the specified pixel format or\n          `SDL_PIXELFORMAT_UNKNOWN` if the format isn't recognized.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetPixelFormatName(format: Uint32) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Convert one of the enumerated pixel formats to a bpp value and RGBA masks.\n\n \\param format one of the SDL_PixelFormatEnum values\n \\param bpp a bits per pixel value; usually 15, 16, or 32\n \\param Rmask a pointer filled in with the red mask for the format\n \\param Gmask a pointer filled in with the green mask for the format\n \\param Bmask a pointer filled in with the blue mask for the format\n \\param Amask a pointer filled in with the alpha mask for the format\n \\returns SDL_TRUE on success or SDL_FALSE if the conversion wasn't\n          possible; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetPixelFormatEnumForMasks"]
    pub fn SDL_GetMasksForPixelFormatEnum(
        format: Uint32,
        bpp: *mut libc::c_int,
        Rmask: *mut Uint32,
        Gmask: *mut Uint32,
        Bmask: *mut Uint32,
        Amask: *mut Uint32,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Convert a bpp value and RGBA masks to an enumerated pixel format.\n\n This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't\n possible.\n\n \\param bpp a bits per pixel value; usually 15, 16, or 32\n \\param Rmask the red mask for the format\n \\param Gmask the green mask for the format\n \\param Bmask the blue mask for the format\n \\param Amask the alpha mask for the format\n \\returns one of the SDL_PixelFormatEnum values\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetMasksForPixelFormatEnum"]
    pub fn SDL_GetPixelFormatEnumForMasks(
        bpp: libc::c_int,
        Rmask: Uint32,
        Gmask: Uint32,
        Bmask: Uint32,
        Amask: Uint32,
    ) -> Uint32;
}
extern "C" {
    #[doc = " Create an SDL_PixelFormat structure corresponding to a pixel format.\n\n Returned structure may come from a shared global cache (i.e. not newly\n allocated), and hence should not be modified, especially the palette. Weird\n errors such as `Blit combination not supported` may occur.\n\n \\param pixel_format one of the SDL_PixelFormatEnum values\n \\returns the new SDL_PixelFormat structure or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_DestroyPixelFormat"]
    pub fn SDL_CreatePixelFormat(pixel_format: Uint32) -> *mut SDL_PixelFormat;
}
extern "C" {
    #[doc = " Free an SDL_PixelFormat structure allocated by SDL_CreatePixelFormat().\n\n \\param format the SDL_PixelFormat structure to free\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreatePixelFormat"]
    pub fn SDL_DestroyPixelFormat(format: *mut SDL_PixelFormat);
}
extern "C" {
    #[doc = " Create a palette structure with the specified number of color entries.\n\n The palette entries are initialized to white.\n\n \\param ncolors represents the number of color entries in the color palette\n \\returns a new SDL_Palette structure on success or NULL on failure (e.g. if\n          there wasn't enough memory); call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_DestroyPalette"]
    pub fn SDL_CreatePalette(ncolors: libc::c_int) -> *mut SDL_Palette;
}
extern "C" {
    #[doc = " Set the palette for a pixel format structure.\n\n \\param format the SDL_PixelFormat structure that will use the palette\n \\param palette the SDL_Palette structure that will be used\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreatePalette\n \\sa SDL_DestroyPalette"]
    pub fn SDL_SetPixelFormatPalette(
        format: *mut SDL_PixelFormat,
        palette: *mut SDL_Palette,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set a range of colors in a palette.\n\n \\param palette the SDL_Palette structure to modify\n \\param colors an array of SDL_Color structures to copy into the palette\n \\param firstcolor the index of the first palette entry to modify\n \\param ncolors the number of entries to modify\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreatePalette\n \\sa SDL_CreateSurface"]
    pub fn SDL_SetPaletteColors(
        palette: *mut SDL_Palette,
        colors: *const SDL_Color,
        firstcolor: libc::c_int,
        ncolors: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Free a palette created with SDL_CreatePalette().\n\n \\param palette the SDL_Palette structure to be freed\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreatePalette"]
    pub fn SDL_DestroyPalette(palette: *mut SDL_Palette);
}
extern "C" {
    #[doc = " Map an RGB triple to an opaque pixel value for a given pixel format.\n\n This function maps the RGB color value to the specified pixel format and\n returns the pixel value best approximating the given RGB color value for\n the given pixel format.\n\n If the format has a palette (8-bit) the index of the closest matching color\n in the palette will be returned.\n\n If the specified pixel format has an alpha component it will be returned as\n all 1 bits (fully opaque).\n\n If the pixel format bpp (color depth) is less than 32-bpp then the unused\n upper bits of the return value can safely be ignored (e.g., with a 16-bpp\n format the return value can be assigned to a Uint16, and similarly a Uint8\n for an 8-bpp format).\n\n \\param format an SDL_PixelFormat structure describing the pixel format\n \\param r the red component of the pixel in the range 0-255\n \\param g the green component of the pixel in the range 0-255\n \\param b the blue component of the pixel in the range 0-255\n \\returns a pixel value\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetRGB\n \\sa SDL_GetRGBA\n \\sa SDL_MapRGBA"]
    pub fn SDL_MapRGB(format: *const SDL_PixelFormat, r: Uint8, g: Uint8, b: Uint8) -> Uint32;
}
extern "C" {
    #[doc = " Map an RGBA quadruple to a pixel value for a given pixel format.\n\n This function maps the RGBA color value to the specified pixel format and\n returns the pixel value best approximating the given RGBA color value for\n the given pixel format.\n\n If the specified pixel format has no alpha component the alpha value will\n be ignored (as it will be in formats with a palette).\n\n If the format has a palette (8-bit) the index of the closest matching color\n in the palette will be returned.\n\n If the pixel format bpp (color depth) is less than 32-bpp then the unused\n upper bits of the return value can safely be ignored (e.g., with a 16-bpp\n format the return value can be assigned to a Uint16, and similarly a Uint8\n for an 8-bpp format).\n\n \\param format an SDL_PixelFormat structure describing the format of the\n               pixel\n \\param r the red component of the pixel in the range 0-255\n \\param g the green component of the pixel in the range 0-255\n \\param b the blue component of the pixel in the range 0-255\n \\param a the alpha component of the pixel in the range 0-255\n \\returns a pixel value\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetRGB\n \\sa SDL_GetRGBA\n \\sa SDL_MapRGB"]
    pub fn SDL_MapRGBA(
        format: *const SDL_PixelFormat,
        r: Uint8,
        g: Uint8,
        b: Uint8,
        a: Uint8,
    ) -> Uint32;
}
extern "C" {
    #[doc = " Get RGB values from a pixel in the specified format.\n\n This function uses the entire 8-bit [0..255] range when converting color\n components from pixel formats with less than 8-bits per RGB component\n (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,\n 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).\n\n \\param pixel a pixel value\n \\param format an SDL_PixelFormat structure describing the format of the\n               pixel\n \\param r a pointer filled in with the red component\n \\param g a pointer filled in with the green component\n \\param b a pointer filled in with the blue component\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetRGBA\n \\sa SDL_MapRGB\n \\sa SDL_MapRGBA"]
    pub fn SDL_GetRGB(
        pixel: Uint32,
        format: *const SDL_PixelFormat,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
    );
}
extern "C" {
    #[doc = " Get RGBA values from a pixel in the specified format.\n\n This function uses the entire 8-bit [0..255] range when converting color\n components from pixel formats with less than 8-bits per RGB component\n (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,\n 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).\n\n If the surface has no alpha component, the alpha will be returned as 0xff\n (100% opaque).\n\n \\param pixel a pixel value\n \\param format an SDL_PixelFormat structure describing the format of the\n               pixel\n \\param r a pointer filled in with the red component\n \\param g a pointer filled in with the green component\n \\param b a pointer filled in with the blue component\n \\param a a pointer filled in with the alpha component\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetRGB\n \\sa SDL_MapRGB\n \\sa SDL_MapRGBA"]
    pub fn SDL_GetRGBA(
        pixel: Uint32,
        format: *const SDL_PixelFormat,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
        a: *mut Uint8,
    );
}
#[doc = " The structure that defines a point (integer)\n\n \\sa SDL_GetRectEnclosingPoints\n \\sa SDL_PointInRect"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Point {
    pub x: libc::c_int,
    pub y: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Point() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_Point> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_Point>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_Point))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Point>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_Point))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Point),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Point),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " The structure that defines a point (floating point)\n\n \\sa SDL_GetRectEnclosingPointsFloat\n \\sa SDL_PointInRectFloat"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_FPoint {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_SDL_FPoint() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_FPoint> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_FPoint>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_FPoint))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_FPoint>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_FPoint))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_FPoint),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_FPoint),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " A rectangle, with the origin at the upper left (integer).\n\n \\sa SDL_RectEmpty\n \\sa SDL_RectsEqual\n \\sa SDL_HasRectIntersection\n \\sa SDL_GetRectIntersection\n \\sa SDL_GetRectAndLineIntersection\n \\sa SDL_GetRectUnion\n \\sa SDL_GetRectEnclosingPoints"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Rect {
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub w: libc::c_int,
    pub h: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Rect() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_Rect> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_Rect>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_Rect))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Rect>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_Rect))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Rect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Rect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Rect),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Rect),
            "::",
            stringify!(h)
        )
    );
}
#[doc = " A rectangle, with the origin at the upper left (floating point).\n\n \\sa SDL_RectEmptyFloat\n \\sa SDL_RectsEqualFloat\n \\sa SDL_RectsEqualEpsilon\n \\sa SDL_HasRectIntersectionFloat\n \\sa SDL_GetRectIntersectionFloat\n \\sa SDL_GetRectAndLineIntersectionFloat\n \\sa SDL_GetRectUnionFloat\n \\sa SDL_GetRectEnclosingPointsFloat\n \\sa SDL_PointInRectFloat"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_FRect {
    pub x: f32,
    pub y: f32,
    pub w: f32,
    pub h: f32,
}
#[test]
fn bindgen_test_layout_SDL_FRect() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_FRect> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_FRect>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_FRect))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_FRect>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_FRect))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_FRect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_FRect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_FRect),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_FRect),
            "::",
            stringify!(h)
        )
    );
}
extern "C" {
    #[doc = " Determine whether two rectangles intersect.\n\n If either pointer is NULL the function will return SDL_FALSE.\n\n \\param A an SDL_Rect structure representing the first rectangle\n \\param B an SDL_Rect structure representing the second rectangle\n \\returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetRectIntersection"]
    pub fn SDL_HasRectIntersection(A: *const SDL_Rect, B: *const SDL_Rect) -> SDL_bool;
}
extern "C" {
    #[doc = " Calculate the intersection of two rectangles.\n\n If `result` is NULL then this function will return SDL_FALSE.\n\n \\param A an SDL_Rect structure representing the first rectangle\n \\param B an SDL_Rect structure representing the second rectangle\n \\param result an SDL_Rect structure filled in with the intersection of\n               rectangles `A` and `B`\n \\returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HasRectIntersection"]
    pub fn SDL_GetRectIntersection(
        A: *const SDL_Rect,
        B: *const SDL_Rect,
        result: *mut SDL_Rect,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Calculate the union of two rectangles.\n\n \\param A an SDL_Rect structure representing the first rectangle\n \\param B an SDL_Rect structure representing the second rectangle\n \\param result an SDL_Rect structure filled in with the union of rectangles\n               `A` and `B`\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetRectUnion(
        A: *const SDL_Rect,
        B: *const SDL_Rect,
        result: *mut SDL_Rect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Calculate a minimal rectangle enclosing a set of points.\n\n If `clip` is not NULL then only points inside of the clipping rectangle are\n considered.\n\n \\param points an array of SDL_Point structures representing points to be\n               enclosed\n \\param count the number of structures in the `points` array\n \\param clip an SDL_Rect used for clipping or NULL to enclose all points\n \\param result an SDL_Rect structure filled in with the minimal enclosing\n               rectangle\n \\returns SDL_TRUE if any points were enclosed or SDL_FALSE if all the\n          points were outside of the clipping rectangle.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetRectEnclosingPoints(
        points: *const SDL_Point,
        count: libc::c_int,
        clip: *const SDL_Rect,
        result: *mut SDL_Rect,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Calculate the intersection of a rectangle and line segment.\n\n This function is used to clip a line segment to a rectangle. A line segment\n contained entirely within the rectangle or that does not intersect will\n remain unchanged. A line segment that crosses the rectangle at either or\n both ends will be clipped to the boundary of the rectangle and the new\n coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.\n\n \\param rect an SDL_Rect structure representing the rectangle to intersect\n \\param X1 a pointer to the starting X-coordinate of the line\n \\param Y1 a pointer to the starting Y-coordinate of the line\n \\param X2 a pointer to the ending X-coordinate of the line\n \\param Y2 a pointer to the ending Y-coordinate of the line\n \\returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetRectAndLineIntersection(
        rect: *const SDL_Rect,
        X1: *mut libc::c_int,
        Y1: *mut libc::c_int,
        X2: *mut libc::c_int,
        Y2: *mut libc::c_int,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Determine whether two rectangles intersect with float precision.\n\n If either pointer is NULL the function will return SDL_FALSE.\n\n \\param A an SDL_FRect structure representing the first rectangle\n \\param B an SDL_FRect structure representing the second rectangle\n \\returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetRectIntersection"]
    pub fn SDL_HasRectIntersectionFloat(A: *const SDL_FRect, B: *const SDL_FRect) -> SDL_bool;
}
extern "C" {
    #[doc = " Calculate the intersection of two rectangles with float precision.\n\n If `result` is NULL then this function will return SDL_FALSE.\n\n \\param A an SDL_FRect structure representing the first rectangle\n \\param B an SDL_FRect structure representing the second rectangle\n \\param result an SDL_FRect structure filled in with the intersection of\n               rectangles `A` and `B`\n \\returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HasRectIntersectionFloat"]
    pub fn SDL_GetRectIntersectionFloat(
        A: *const SDL_FRect,
        B: *const SDL_FRect,
        result: *mut SDL_FRect,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Calculate the union of two rectangles with float precision.\n\n \\param A an SDL_FRect structure representing the first rectangle\n \\param B an SDL_FRect structure representing the second rectangle\n \\param result an SDL_FRect structure filled in with the union of rectangles\n               `A` and `B`\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetRectUnionFloat(
        A: *const SDL_FRect,
        B: *const SDL_FRect,
        result: *mut SDL_FRect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Calculate a minimal rectangle enclosing a set of points with float\n precision.\n\n If `clip` is not NULL then only points inside of the clipping rectangle are\n considered.\n\n \\param points an array of SDL_FPoint structures representing points to be\n               enclosed\n \\param count the number of structures in the `points` array\n \\param clip an SDL_FRect used for clipping or NULL to enclose all points\n \\param result an SDL_FRect structure filled in with the minimal enclosing\n               rectangle\n \\returns SDL_TRUE if any points were enclosed or SDL_FALSE if all the\n          points were outside of the clipping rectangle.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetRectEnclosingPointsFloat(
        points: *const SDL_FPoint,
        count: libc::c_int,
        clip: *const SDL_FRect,
        result: *mut SDL_FRect,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Calculate the intersection of a rectangle and line segment with float\n precision.\n\n This function is used to clip a line segment to a rectangle. A line segment\n contained entirely within the rectangle or that does not intersect will\n remain unchanged. A line segment that crosses the rectangle at either or\n both ends will be clipped to the boundary of the rectangle and the new\n coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.\n\n \\param rect an SDL_FRect structure representing the rectangle to intersect\n \\param X1 a pointer to the starting X-coordinate of the line\n \\param Y1 a pointer to the starting Y-coordinate of the line\n \\param X2 a pointer to the ending X-coordinate of the line\n \\param Y2 a pointer to the ending Y-coordinate of the line\n \\returns SDL_TRUE if there is an intersection, SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetRectAndLineIntersectionFloat(
        rect: *const SDL_FRect,
        X1: *mut f32,
        Y1: *mut f32,
        X2: *mut f32,
        Y2: *mut f32,
    ) -> SDL_bool;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_BlitMap {
    _unused: [u8; 0],
}
#[doc = " \\brief A collection of pixels used in software blitting.\n\n \\note  This structure should be treated as read-only, except for \\c pixels,\n        which, if not NULL, contains the raw pixel data for the surface."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Surface {
    #[doc = "< Read-only"]
    pub flags: Uint32,
    #[doc = "< Read-only"]
    pub format: *mut SDL_PixelFormat,
    #[doc = "< Read-only"]
    pub w: libc::c_int,
    #[doc = "< Read-only"]
    pub h: libc::c_int,
    #[doc = "< Read-only"]
    pub pitch: libc::c_int,
    #[doc = "< Read-write"]
    pub pixels: *mut libc::c_void,
    #[doc = "< Read-write"]
    pub userdata: *mut libc::c_void,
    #[doc = "< Read-only"]
    pub locked: libc::c_int,
    #[doc = "< Private"]
    pub list_blitmap: *mut libc::c_void,
    #[doc = "< Read-only"]
    pub clip_rect: SDL_Rect,
    #[doc = "< Private"]
    pub map: *mut SDL_BlitMap,
    #[doc = "< Read-mostly"]
    pub refcount: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Surface() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_Surface> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_Surface>(),
        96usize,
        concat!("Size of: ", stringify!(SDL_Surface))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Surface>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_Surface))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pixels) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(pixels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).userdata) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).locked) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(locked)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).list_blitmap) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(list_blitmap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clip_rect) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(clip_rect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).map) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).refcount) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(refcount)
        )
    );
}
#[doc = " \\brief The type of function used for surface blitting functions."]
pub type SDL_blit = ::core::option::Option<
    unsafe extern "C" fn(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
    ) -> libc::c_int,
>;
#[repr(u32)]
#[doc = " \\brief The formula used for converting between YUV and RGB"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_YUV_CONVERSION_MODE {
    #[doc = "< Full range JPEG"]
    SDL_YUV_CONVERSION_JPEG = 0,
    #[doc = "< BT.601 (the default)"]
    SDL_YUV_CONVERSION_BT601 = 1,
    #[doc = "< BT.709"]
    SDL_YUV_CONVERSION_BT709 = 2,
    #[doc = "< BT.601 for SD content, BT.709 for HD content"]
    SDL_YUV_CONVERSION_AUTOMATIC = 3,
}
extern "C" {
    #[doc = " Allocate a new RGB surface with a specific pixel format.\n\n \\param width the width of the surface\n \\param height the height of the surface\n \\param format the SDL_PixelFormatEnum for the new surface's pixel format.\n \\returns the new SDL_Surface structure that is created or NULL if it fails;\n          call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateSurfaceFrom\n \\sa SDL_DestroySurface"]
    pub fn SDL_CreateSurface(
        width: libc::c_int,
        height: libc::c_int,
        format: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = " Allocate a new RGB surface with a specific pixel format and existing pixel\n data.\n\n No copy is made of the pixel data. Pixel data is not managed automatically;\n you must free the surface before you free the pixel data.\n\n Pitch is the offset in bytes from one row of pixels to the next, e.g.\n `width*4` for `SDL_PIXELFORMAT_RGBA8888`.\n\n You may pass NULL for pixels and 0 for pitch to create a surface that you\n will fill in with valid values later.\n\n \\param pixels a pointer to existing pixel data\n \\param width the width of the surface\n \\param height the height of the surface\n \\param pitch the pitch of the surface in bytes\n \\param format the SDL_PixelFormatEnum for the new surface's pixel format.\n \\returns the new SDL_Surface structure that is created or NULL if it fails;\n          call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateSurface\n \\sa SDL_DestroySurface"]
    pub fn SDL_CreateSurfaceFrom(
        pixels: *mut libc::c_void,
        width: libc::c_int,
        height: libc::c_int,
        pitch: libc::c_int,
        format: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = " Free an RGB surface.\n\n It is safe to pass NULL to this function.\n\n \\param surface the SDL_Surface to free.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateSurface\n \\sa SDL_CreateSurfaceFrom\n \\sa SDL_LoadBMP\n \\sa SDL_LoadBMP_RW"]
    pub fn SDL_DestroySurface(surface: *mut SDL_Surface);
}
extern "C" {
    #[doc = " Set the palette used by a surface.\n\n A single palette can be shared with many surfaces.\n\n \\param surface the SDL_Surface structure to update\n \\param palette the SDL_Palette structure to use\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_SetSurfacePalette(
        surface: *mut SDL_Surface,
        palette: *mut SDL_Palette,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set up a surface for directly accessing the pixels.\n\n Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to\n and read from `surface->pixels`, using the pixel format stored in\n `surface->format`. Once you are done accessing the surface, you should use\n SDL_UnlockSurface() to release it.\n\n Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to\n 0, then you can read and write to the surface at any time, and the pixel\n format of the surface will not change.\n\n \\param surface the SDL_Surface structure to be locked\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_MUSTLOCK\n \\sa SDL_UnlockSurface"]
    pub fn SDL_LockSurface(surface: *mut SDL_Surface) -> libc::c_int;
}
extern "C" {
    #[doc = " Release a surface after directly accessing the pixels.\n\n \\param surface the SDL_Surface structure to be unlocked\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_LockSurface"]
    pub fn SDL_UnlockSurface(surface: *mut SDL_Surface);
}
extern "C" {
    #[doc = " Load a BMP image from a seekable SDL data stream.\n\n The new surface should be freed with SDL_DestroySurface(). Not doing so\n will result in a memory leak.\n\n \\param src the data stream for the surface\n \\param freesrc if SDL_TRUE, calls SDL_RWclose() on `src` before returning,\n                even in the case of an error\n \\returns a pointer to a new SDL_Surface structure or NULL if there was an\n          error; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_DestroySurface\n \\sa SDL_LoadBMP\n \\sa SDL_SaveBMP_RW"]
    pub fn SDL_LoadBMP_RW(src: *mut SDL_RWops, freesrc: SDL_bool) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = " Load a BMP image from a file.\n\n The new surface should be freed with SDL_DestroySurface(). Not doing so\n will result in a memory leak.\n\n \\param file the BMP file to load\n \\returns a pointer to a new SDL_Surface structure or NULL if there was an\n          error; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_DestroySurface\n \\sa SDL_LoadBMP_RW\n \\sa SDL_SaveBMP"]
    pub fn SDL_LoadBMP(file: *const libc::c_char) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = " Save a surface to a seekable SDL data stream in BMP format.\n\n Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the\n BMP directly. Other RGB formats with 8-bit or higher get converted to a\n 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit\n surface before they are saved. YUV and paletted 1-bit and 4-bit formats are\n not supported.\n\n \\param surface the SDL_Surface structure containing the image to be saved\n \\param dst a data stream to save to\n \\param freedst non-zero to close the stream after being written\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_LoadBMP_RW\n \\sa SDL_SaveBMP"]
    pub fn SDL_SaveBMP_RW(
        surface: *mut SDL_Surface,
        dst: *mut SDL_RWops,
        freedst: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Save a surface to a file.\n\n Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the\n BMP directly. Other RGB formats with 8-bit or higher get converted to a\n 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit\n surface before they are saved. YUV and paletted 1-bit and 4-bit formats are\n not supported.\n\n \\param surface the SDL_Surface structure containing the image to be saved\n \\param file a file to save to\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_LoadBMP\n \\sa SDL_SaveBMP_RW"]
    pub fn SDL_SaveBMP(surface: *mut SDL_Surface, file: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the RLE acceleration hint for a surface.\n\n If RLE is enabled, color key and alpha blending blits are much faster, but\n the surface must be locked before directly accessing the pixels.\n\n \\param surface the SDL_Surface structure to optimize\n \\param flag 0 to disable, non-zero to enable RLE acceleration\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_BlitSurface\n \\sa SDL_LockSurface\n \\sa SDL_UnlockSurface"]
    pub fn SDL_SetSurfaceRLE(surface: *mut SDL_Surface, flag: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Returns whether the surface is RLE enabled\n\n It is safe to pass a NULL `surface` here; it will return SDL_FALSE.\n\n \\param surface the SDL_Surface structure to query\n \\returns SDL_TRUE if the surface is RLE enabled, SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetSurfaceRLE"]
    pub fn SDL_SurfaceHasRLE(surface: *mut SDL_Surface) -> SDL_bool;
}
extern "C" {
    #[doc = " Set the color key (transparent pixel) in a surface.\n\n The color key defines a pixel value that will be treated as transparent in\n a blit. For example, one can use this to specify that cyan pixels should be\n considered transparent, and therefore not rendered.\n\n It is a pixel of the format used by the surface, as generated by\n SDL_MapRGB().\n\n RLE acceleration can substantially speed up blitting of images with large\n horizontal runs of transparent pixels. See SDL_SetSurfaceRLE() for details.\n\n \\param surface the SDL_Surface structure to update\n \\param flag SDL_TRUE to enable color key, SDL_FALSE to disable color key\n \\param key the transparent pixel\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_BlitSurface\n \\sa SDL_GetSurfaceColorKey"]
    pub fn SDL_SetSurfaceColorKey(
        surface: *mut SDL_Surface,
        flag: libc::c_int,
        key: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Returns whether the surface has a color key\n\n It is safe to pass a NULL `surface` here; it will return SDL_FALSE.\n\n \\param surface the SDL_Surface structure to query\n \\returns SDL_TRUE if the surface has a color key, SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetSurfaceColorKey\n \\sa SDL_GetSurfaceColorKey"]
    pub fn SDL_SurfaceHasColorKey(surface: *mut SDL_Surface) -> SDL_bool;
}
extern "C" {
    #[doc = " Get the color key (transparent pixel) for a surface.\n\n The color key is a pixel of the format used by the surface, as generated by\n SDL_MapRGB().\n\n If the surface doesn't have color key enabled this function returns -1.\n\n \\param surface the SDL_Surface structure to query\n \\param key a pointer filled in with the transparent pixel\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_BlitSurface\n \\sa SDL_SetSurfaceColorKey"]
    pub fn SDL_GetSurfaceColorKey(surface: *mut SDL_Surface, key: *mut Uint32) -> libc::c_int;
}
extern "C" {
    #[doc = " Set an additional color value multiplied into blit operations.\n\n When this surface is blitted, during the blit operation each source color\n channel is modulated by the appropriate color value according to the\n following formula:\n\n `srcC = srcC * (color / 255)`\n\n \\param surface the SDL_Surface structure to update\n \\param r the red color value multiplied into blit operations\n \\param g the green color value multiplied into blit operations\n \\param b the blue color value multiplied into blit operations\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetSurfaceColorMod\n \\sa SDL_SetSurfaceAlphaMod"]
    pub fn SDL_SetSurfaceColorMod(
        surface: *mut SDL_Surface,
        r: Uint8,
        g: Uint8,
        b: Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the additional color value multiplied into blit operations.\n\n \\param surface the SDL_Surface structure to query\n \\param r a pointer filled in with the current red color value\n \\param g a pointer filled in with the current green color value\n \\param b a pointer filled in with the current blue color value\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetSurfaceAlphaMod\n \\sa SDL_SetSurfaceColorMod"]
    pub fn SDL_GetSurfaceColorMod(
        surface: *mut SDL_Surface,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set an additional alpha value used in blit operations.\n\n When this surface is blitted, during the blit operation the source alpha\n value is modulated by this alpha value according to the following formula:\n\n `srcA = srcA * (alpha / 255)`\n\n \\param surface the SDL_Surface structure to update\n \\param alpha the alpha value multiplied into blit operations\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetSurfaceAlphaMod\n \\sa SDL_SetSurfaceColorMod"]
    pub fn SDL_SetSurfaceAlphaMod(surface: *mut SDL_Surface, alpha: Uint8) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the additional alpha value used in blit operations.\n\n \\param surface the SDL_Surface structure to query\n \\param alpha a pointer filled in with the current alpha value\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetSurfaceColorMod\n \\sa SDL_SetSurfaceAlphaMod"]
    pub fn SDL_GetSurfaceAlphaMod(surface: *mut SDL_Surface, alpha: *mut Uint8) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the blend mode used for blit operations.\n\n To copy a surface to another surface (or texture) without blending with the\n existing data, the blendmode of the SOURCE surface should be set to\n `SDL_BLENDMODE_NONE`.\n\n \\param surface the SDL_Surface structure to update\n \\param blendMode the SDL_BlendMode to use for blit blending\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetSurfaceBlendMode"]
    pub fn SDL_SetSurfaceBlendMode(
        surface: *mut SDL_Surface,
        blendMode: SDL_BlendMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the blend mode used for blit operations.\n\n \\param surface the SDL_Surface structure to query\n \\param blendMode a pointer filled in with the current SDL_BlendMode\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetSurfaceBlendMode"]
    pub fn SDL_GetSurfaceBlendMode(
        surface: *mut SDL_Surface,
        blendMode: *mut SDL_BlendMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the clipping rectangle for a surface.\n\n When `surface` is the destination of a blit, only the area within the clip\n rectangle is drawn into.\n\n Note that blits are automatically clipped to the edges of the source and\n destination surfaces.\n\n \\param surface the SDL_Surface structure to be clipped\n \\param rect the SDL_Rect structure representing the clipping rectangle, or\n             NULL to disable clipping\n \\returns SDL_TRUE if the rectangle intersects the surface, otherwise\n          SDL_FALSE and blits will be completely clipped.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_BlitSurface\n \\sa SDL_GetSurfaceClipRect"]
    pub fn SDL_SetSurfaceClipRect(surface: *mut SDL_Surface, rect: *const SDL_Rect) -> SDL_bool;
}
extern "C" {
    #[doc = " Get the clipping rectangle for a surface.\n\n When `surface` is the destination of a blit, only the area within the clip\n rectangle is drawn into.\n\n \\param surface the SDL_Surface structure representing the surface to be\n                clipped\n \\param rect an SDL_Rect structure filled in with the clipping rectangle for\n             the surface\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_BlitSurface\n \\sa SDL_SetSurfaceClipRect"]
    pub fn SDL_GetSurfaceClipRect(surface: *mut SDL_Surface, rect: *mut SDL_Rect) -> libc::c_int;
}
extern "C" {
    pub fn SDL_DuplicateSurface(surface: *mut SDL_Surface) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = " Copy an existing surface to a new surface of the specified format.\n\n This function is used to optimize images for faster *repeat* blitting. This\n is accomplished by converting the original and storing the result as a new\n surface. The new, optimized surface can then be used as the source for\n future blits, making them faster.\n\n \\param surface the existing SDL_Surface structure to convert\n \\param format the SDL_PixelFormat structure that the new surface is\n               optimized for\n \\returns the new SDL_Surface structure that is created or NULL if it fails;\n          call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreatePixelFormat\n \\sa SDL_ConvertSurfaceFormat\n \\sa SDL_CreateSurface"]
    pub fn SDL_ConvertSurface(
        surface: *mut SDL_Surface,
        format: *const SDL_PixelFormat,
    ) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = " Copy an existing surface to a new surface of the specified format enum.\n\n This function operates just like SDL_ConvertSurface(), but accepts an\n SDL_PixelFormatEnum value instead of an SDL_PixelFormat structure. As such,\n it might be easier to call but it doesn't have access to palette\n information for the destination surface, in case that would be important.\n\n \\param surface the existing SDL_Surface structure to convert\n \\param pixel_format the SDL_PixelFormatEnum that the new surface is\n                     optimized for\n \\returns the new SDL_Surface structure that is created or NULL if it fails;\n          call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreatePixelFormat\n \\sa SDL_ConvertSurface\n \\sa SDL_CreateSurface"]
    pub fn SDL_ConvertSurfaceFormat(
        surface: *mut SDL_Surface,
        pixel_format: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = " Copy a block of pixels of one format to another format.\n\n \\param width the width of the block to copy, in pixels\n \\param height the height of the block to copy, in pixels\n \\param src_format an SDL_PixelFormatEnum value of the `src` pixels format\n \\param src a pointer to the source pixels\n \\param src_pitch the pitch of the source pixels, in bytes\n \\param dst_format an SDL_PixelFormatEnum value of the `dst` pixels format\n \\param dst a pointer to be filled in with new pixel data\n \\param dst_pitch the pitch of the destination pixels, in bytes\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_ConvertPixels(
        width: libc::c_int,
        height: libc::c_int,
        src_format: Uint32,
        src: *const libc::c_void,
        src_pitch: libc::c_int,
        dst_format: Uint32,
        dst: *mut libc::c_void,
        dst_pitch: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Premultiply the alpha on a block of pixels.\n\n This is safe to use with src == dst, but not for other overlapping areas.\n\n This function is currently only implemented for SDL_PIXELFORMAT_ARGB8888.\n\n \\param width the width of the block to convert, in pixels\n \\param height the height of the block to convert, in pixels\n \\param src_format an SDL_PixelFormatEnum value of the `src` pixels format\n \\param src a pointer to the source pixels\n \\param src_pitch the pitch of the source pixels, in bytes\n \\param dst_format an SDL_PixelFormatEnum value of the `dst` pixels format\n \\param dst a pointer to be filled in with premultiplied pixel data\n \\param dst_pitch the pitch of the destination pixels, in bytes\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_PremultiplyAlpha(
        width: libc::c_int,
        height: libc::c_int,
        src_format: Uint32,
        src: *const libc::c_void,
        src_pitch: libc::c_int,
        dst_format: Uint32,
        dst: *mut libc::c_void,
        dst_pitch: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Perform a fast fill of a rectangle with a specific color.\n\n `color` should be a pixel of the format used by the surface, and can be\n generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an\n alpha component then the destination is simply filled with that alpha\n information, no blending takes place.\n\n If there is a clip rectangle set on the destination (set via\n SDL_SetSurfaceClipRect()), then this function will fill based on the\n intersection of the clip rectangle and `rect`.\n\n \\param dst the SDL_Surface structure that is the drawing target\n \\param rect the SDL_Rect structure representing the rectangle to fill, or\n             NULL to fill the entire surface\n \\param color the color to fill with\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_FillSurfaceRects"]
    pub fn SDL_FillSurfaceRect(
        dst: *mut SDL_Surface,
        rect: *const SDL_Rect,
        color: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Perform a fast fill of a set of rectangles with a specific color.\n\n `color` should be a pixel of the format used by the surface, and can be\n generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an\n alpha component then the destination is simply filled with that alpha\n information, no blending takes place.\n\n If there is a clip rectangle set on the destination (set via\n SDL_SetSurfaceClipRect()), then this function will fill based on the\n intersection of the clip rectangle and `rect`.\n\n \\param dst the SDL_Surface structure that is the drawing target\n \\param rects an array of SDL_Rects representing the rectangles to fill.\n \\param count the number of rectangles in the array\n \\param color the color to fill with\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_FillSurfaceRect"]
    pub fn SDL_FillSurfaceRects(
        dst: *mut SDL_Surface,
        rects: *const SDL_Rect,
        count: libc::c_int,
        color: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Performs a fast blit from the source surface to the destination surface.\n\n This assumes that the source and destination rectangles are the same size.\n If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or\n `dst`) is copied. The final blit rectangles are saved in `srcrect` and\n `dstrect` after all clipping is performed.\n\n The blit function should not be called on a locked surface.\n\n The blit semantics for surfaces with and without blending and colorkey are\n defined as follows:\n\n ```c\n    RGBA->RGB:\n      Source surface blend mode set to SDL_BLENDMODE_BLEND:\n       alpha-blend (using the source alpha-channel and per-surface alpha)\n       SDL_SRCCOLORKEY ignored.\n     Source surface blend mode set to SDL_BLENDMODE_NONE:\n       copy RGB.\n       if SDL_SRCCOLORKEY set, only copy the pixels matching the\n       RGB values of the source color key, ignoring alpha in the\n       comparison.\n\n   RGB->RGBA:\n     Source surface blend mode set to SDL_BLENDMODE_BLEND:\n       alpha-blend (using the source per-surface alpha)\n     Source surface blend mode set to SDL_BLENDMODE_NONE:\n       copy RGB, set destination alpha to source per-surface alpha value.\n     both:\n       if SDL_SRCCOLORKEY set, only copy the pixels matching the\n       source color key.\n\n   RGBA->RGBA:\n     Source surface blend mode set to SDL_BLENDMODE_BLEND:\n       alpha-blend (using the source alpha-channel and per-surface alpha)\n       SDL_SRCCOLORKEY ignored.\n     Source surface blend mode set to SDL_BLENDMODE_NONE:\n       copy all of RGBA to the destination.\n       if SDL_SRCCOLORKEY set, only copy the pixels matching the\n       RGB values of the source color key, ignoring alpha in the\n       comparison.\n\n   RGB->RGB:\n     Source surface blend mode set to SDL_BLENDMODE_BLEND:\n       alpha-blend (using the source per-surface alpha)\n     Source surface blend mode set to SDL_BLENDMODE_NONE:\n       copy RGB.\n     both:\n       if SDL_SRCCOLORKEY set, only copy the pixels matching the\n       source color key.\n ```\n\n \\param src the SDL_Surface structure to be copied from\n \\param srcrect the SDL_Rect structure representing the rectangle to be\n                copied, or NULL to copy the entire surface\n \\param dst the SDL_Surface structure that is the blit target\n \\param dstrect the SDL_Rect structure representing the target rectangle in\n                the destination surface, filled with the actual rectangle\n                used after clipping\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_BlitSurface"]
    pub fn SDL_BlitSurface(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Perform low-level surface blitting only.\n\n This is a semi-private blit function and it performs low-level surface\n blitting, assuming the input rectangles have already been clipped.\n\n \\param src the SDL_Surface structure to be copied from\n \\param srcrect the SDL_Rect structure representing the rectangle to be\n                copied, or NULL to copy the entire surface\n \\param dst the SDL_Surface structure that is the blit target\n \\param dstrect the SDL_Rect structure representing the target rectangle in\n                the destination surface\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_BlitSurface"]
    pub fn SDL_BlitSurfaceUnchecked(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Perform a fast, low quality, stretch blit between two surfaces of the same\n format.\n\n **WARNING**: Please use SDL_BlitSurfaceScaled() instead.\n\n \\param src the SDL_Surface structure to be copied from\n \\param srcrect the SDL_Rect structure representing the rectangle to be\n                copied\n \\param dst the SDL_Surface structure that is the blit target\n \\param dstrect the SDL_Rect structure representing the target rectangle in\n                the destination surface\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_SoftStretch(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Perform bilinear scaling between two surfaces of the same format, 32BPP.\n\n \\param src the SDL_Surface structure to be copied from\n \\param srcrect the SDL_Rect structure representing the rectangle to be\n                copied\n \\param dst the SDL_Surface structure that is the blit target\n \\param dstrect the SDL_Rect structure representing the target rectangle in\n                the destination surface\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_SoftStretchLinear(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Perform a scaled surface copy to a destination surface.\n\n \\param src the SDL_Surface structure to be copied from\n \\param srcrect the SDL_Rect structure representing the rectangle to be\n                copied\n \\param dst the SDL_Surface structure that is the blit target\n \\param dstrect the SDL_Rect structure representing the target rectangle in\n                the destination surface, filled with the actual rectangle\n                used after clipping\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_BlitSurfaceScaled(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Perform low-level surface scaled blitting only.\n\n This is a semi-private function and it performs low-level surface blitting,\n assuming the input rectangles have already been clipped.\n\n \\param src the SDL_Surface structure to be copied from\n \\param srcrect the SDL_Rect structure representing the rectangle to be\n                copied\n \\param dst the SDL_Surface structure that is the blit target\n \\param dstrect the SDL_Rect structure representing the target rectangle in\n                the destination surface\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_BlitSurfaceScaled"]
    pub fn SDL_BlitSurfaceUncheckedScaled(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the YUV conversion mode\n\n \\param mode YUV conversion mode\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_SetYUVConversionMode(mode: SDL_YUV_CONVERSION_MODE);
}
extern "C" {
    #[doc = " Get the YUV conversion mode\n\n \\returns YUV conversion mode\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetYUVConversionMode() -> SDL_YUV_CONVERSION_MODE;
}
extern "C" {
    #[doc = " Get the YUV conversion mode, returning the correct mode for the resolution\n when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC\n\n \\param width width\n \\param height height\n \\returns YUV conversion mode\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetYUVConversionModeForResolution(
        width: libc::c_int,
        height: libc::c_int,
    ) -> SDL_YUV_CONVERSION_MODE;
}
pub type SDL_DisplayID = Uint32;
pub type SDL_WindowID = Uint32;
#[repr(u32)]
#[doc = "  \\brief System theme"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_SystemTheme {
    #[doc = "< Unknown system theme"]
    SDL_SYSTEM_THEME_UNKNOWN = 0,
    #[doc = "< Light colored system theme"]
    SDL_SYSTEM_THEME_LIGHT = 1,
    #[doc = "< Dark colored system theme"]
    SDL_SYSTEM_THEME_DARK = 2,
}
#[doc = "  \\brief  The structure that defines a display mode\n\n  \\sa SDL_GetFullscreenDisplayModes()\n  \\sa SDL_GetDesktopDisplayMode()\n  \\sa SDL_GetCurrentDisplayMode()\n  \\sa SDL_SetWindowFullscreenMode()\n  \\sa SDL_GetWindowFullscreenMode()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_DisplayMode {
    #[doc = "< the display this mode is associated with"]
    pub displayID: SDL_DisplayID,
    #[doc = "< pixel format"]
    pub format: Uint32,
    #[doc = "< width"]
    pub w: libc::c_int,
    #[doc = "< height"]
    pub h: libc::c_int,
    #[doc = "< scale converting size to pixels (e.g. a 1920x1080 mode with 2.0 scale would have 3840x2160 pixels)"]
    pub pixel_density: f32,
    #[doc = "< refresh rate (or zero for unspecified)"]
    pub refresh_rate: f32,
    #[doc = "< driver-specific data, initialize to 0"]
    pub driverdata: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_DisplayMode() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_DisplayMode> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_DisplayMode>(),
        32usize,
        concat!("Size of: ", stringify!(SDL_DisplayMode))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_DisplayMode>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_DisplayMode))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).displayID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayMode),
            "::",
            stringify!(displayID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayMode),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayMode),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayMode),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pixel_density) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayMode),
            "::",
            stringify!(pixel_density)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).refresh_rate) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayMode),
            "::",
            stringify!(refresh_rate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).driverdata) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayMode),
            "::",
            stringify!(driverdata)
        )
    );
}
#[repr(u32)]
#[doc = "  \\brief Display orientation"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_DisplayOrientation {
    #[doc = "< The display orientation can't be determined"]
    SDL_ORIENTATION_UNKNOWN = 0,
    #[doc = "< The display is in landscape mode, with the right side up, relative to portrait mode"]
    SDL_ORIENTATION_LANDSCAPE = 1,
    #[doc = "< The display is in landscape mode, with the left side up, relative to portrait mode"]
    SDL_ORIENTATION_LANDSCAPE_FLIPPED = 2,
    #[doc = "< The display is in portrait mode"]
    SDL_ORIENTATION_PORTRAIT = 3,
    #[doc = "< The display is in portrait mode, upside down"]
    SDL_ORIENTATION_PORTRAIT_FLIPPED = 4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Window {
    _unused: [u8; 0],
}
#[repr(u32)]
#[doc = "  \\brief The flags on a window\n\n  \\sa SDL_GetWindowFlags()"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_WindowFlags {
    #[doc = "< window is in fullscreen mode"]
    SDL_WINDOW_FULLSCREEN = 1,
    #[doc = "< window usable with OpenGL context"]
    SDL_WINDOW_OPENGL = 2,
    #[doc = "< window is occluded"]
    SDL_WINDOW_OCCLUDED = 4,
    #[doc = "< window is not visible"]
    SDL_WINDOW_HIDDEN = 8,
    #[doc = "< no window decoration"]
    SDL_WINDOW_BORDERLESS = 16,
    #[doc = "< window can be resized"]
    SDL_WINDOW_RESIZABLE = 32,
    #[doc = "< window is minimized"]
    SDL_WINDOW_MINIMIZED = 64,
    #[doc = "< window is maximized"]
    SDL_WINDOW_MAXIMIZED = 128,
    #[doc = "< window has grabbed mouse input"]
    SDL_WINDOW_MOUSE_GRABBED = 256,
    #[doc = "< window has input focus"]
    SDL_WINDOW_INPUT_FOCUS = 512,
    #[doc = "< window has mouse focus"]
    SDL_WINDOW_MOUSE_FOCUS = 1024,
    #[doc = "< window not created by SDL"]
    SDL_WINDOW_FOREIGN = 2048,
    #[doc = "< window uses high pixel density back buffer if possible"]
    SDL_WINDOW_HIGH_PIXEL_DENSITY = 8192,
    #[doc = "< window has mouse captured (unrelated to MOUSE_GRABBED)"]
    SDL_WINDOW_MOUSE_CAPTURE = 16384,
    #[doc = "< window should always be above others"]
    SDL_WINDOW_ALWAYS_ON_TOP = 32768,
    #[doc = "< window should be treated as a utility window, not showing in the task bar and window list"]
    SDL_WINDOW_UTILITY = 131072,
    #[doc = "< window should be treated as a tooltip and must be created using SDL_CreatePopupWindow()"]
    SDL_WINDOW_TOOLTIP = 262144,
    #[doc = "< window should be treated as a popup menu and must be created using SDL_CreatePopupWindow()"]
    SDL_WINDOW_POPUP_MENU = 524288,
    #[doc = "< window has grabbed keyboard input"]
    SDL_WINDOW_KEYBOARD_GRABBED = 1048576,
    #[doc = "< window usable for Vulkan surface"]
    SDL_WINDOW_VULKAN = 268435456,
    #[doc = "< window usable for Metal view"]
    SDL_WINDOW_METAL = 536870912,
    #[doc = "< window with transparent buffer"]
    SDL_WINDOW_TRANSPARENT = 1073741824,
}
#[repr(u32)]
#[doc = "  \\brief Window flash operation"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_FlashOperation {
    #[doc = "< Cancel any window flash state"]
    SDL_FLASH_CANCEL = 0,
    #[doc = "< Flash the window briefly to get attention"]
    SDL_FLASH_BRIEFLY = 1,
    #[doc = "< Flash the window until it gets focus"]
    SDL_FLASH_UNTIL_FOCUSED = 2,
}
#[doc = "  \\brief An opaque handle to an OpenGL context."]
pub type SDL_GLContext = *mut libc::c_void;
#[doc = "  \\brief Opaque EGL types."]
pub type SDL_EGLDisplay = *mut libc::c_void;
pub type SDL_EGLConfig = *mut libc::c_void;
pub type SDL_EGLSurface = *mut libc::c_void;
pub type SDL_EGLAttrib = isize;
pub type SDL_EGLint = libc::c_int;
#[doc = "  \\brief EGL attribute initialization callback types."]
pub type SDL_EGLAttribArrayCallback =
    ::core::option::Option<unsafe extern "C" fn() -> *mut SDL_EGLAttrib>;
pub type SDL_EGLIntArrayCallback =
    ::core::option::Option<unsafe extern "C" fn() -> *mut SDL_EGLint>;
#[repr(u32)]
#[doc = "  \\brief OpenGL configuration attributes"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_GLattr {
    SDL_GL_RED_SIZE = 0,
    SDL_GL_GREEN_SIZE = 1,
    SDL_GL_BLUE_SIZE = 2,
    SDL_GL_ALPHA_SIZE = 3,
    SDL_GL_BUFFER_SIZE = 4,
    SDL_GL_DOUBLEBUFFER = 5,
    SDL_GL_DEPTH_SIZE = 6,
    SDL_GL_STENCIL_SIZE = 7,
    SDL_GL_ACCUM_RED_SIZE = 8,
    SDL_GL_ACCUM_GREEN_SIZE = 9,
    SDL_GL_ACCUM_BLUE_SIZE = 10,
    SDL_GL_ACCUM_ALPHA_SIZE = 11,
    SDL_GL_STEREO = 12,
    SDL_GL_MULTISAMPLEBUFFERS = 13,
    SDL_GL_MULTISAMPLESAMPLES = 14,
    SDL_GL_ACCELERATED_VISUAL = 15,
    SDL_GL_RETAINED_BACKING = 16,
    SDL_GL_CONTEXT_MAJOR_VERSION = 17,
    SDL_GL_CONTEXT_MINOR_VERSION = 18,
    SDL_GL_CONTEXT_FLAGS = 19,
    SDL_GL_CONTEXT_PROFILE_MASK = 20,
    SDL_GL_SHARE_WITH_CURRENT_CONTEXT = 21,
    SDL_GL_FRAMEBUFFER_SRGB_CAPABLE = 22,
    SDL_GL_CONTEXT_RELEASE_BEHAVIOR = 23,
    SDL_GL_CONTEXT_RESET_NOTIFICATION = 24,
    SDL_GL_CONTEXT_NO_ERROR = 25,
    SDL_GL_FLOATBUFFERS = 26,
    SDL_GL_EGL_PLATFORM = 27,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_GLprofile {
    SDL_GL_CONTEXT_PROFILE_CORE = 1,
    SDL_GL_CONTEXT_PROFILE_COMPATIBILITY = 2,
    #[doc = "< GLX_CONTEXT_ES2_PROFILE_BIT_EXT"]
    SDL_GL_CONTEXT_PROFILE_ES = 4,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_GLcontextFlag {
    SDL_GL_CONTEXT_DEBUG_FLAG = 1,
    SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG = 2,
    SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG = 4,
    SDL_GL_CONTEXT_RESET_ISOLATION_FLAG = 8,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_GLcontextReleaseFlag {
    SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE = 0,
    SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = 1,
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_GLContextResetNotification {
    SDL_GL_CONTEXT_RESET_NO_NOTIFICATION = 0,
    SDL_GL_CONTEXT_RESET_LOSE_CONTEXT = 1,
}
extern "C" {
    #[doc = " Get the number of video drivers compiled into SDL.\n\n \\returns a number >= 1 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetVideoDriver"]
    pub fn SDL_GetNumVideoDrivers() -> libc::c_int;
}
extern "C" {
    #[doc = " Get the name of a built in video driver.\n\n The video drivers are presented in the order in which they are normally\n checked during initialization.\n\n \\param index the index of a video driver\n \\returns the name of the video driver with the given **index**.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetNumVideoDrivers"]
    pub fn SDL_GetVideoDriver(index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the name of the currently initialized video driver.\n\n \\returns the name of the current video driver or NULL if no driver has been\n          initialized.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetNumVideoDrivers\n \\sa SDL_GetVideoDriver"]
    pub fn SDL_GetCurrentVideoDriver() -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the current system theme\n\n \\returns the current system theme, light, dark, or unknown\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetSystemTheme() -> SDL_SystemTheme;
}
extern "C" {
    #[doc = " Get a list of currently connected displays.\n\n \\param count a pointer filled in with the number of displays returned\n \\returns a 0 terminated array of display instance IDs which should be freed\n          with SDL_free(), or NULL on error; call SDL_GetError() for more\n          details.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetDisplays(count: *mut libc::c_int) -> *mut SDL_DisplayID;
}
extern "C" {
    #[doc = " Return the primary display.\n\n \\returns the instance ID of the primary display on success or 0 on failure;\n          call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetPrimaryDisplay() -> SDL_DisplayID;
}
extern "C" {
    #[doc = " Get the name of a display in UTF-8 encoding.\n\n \\param displayID the instance ID of the display to query\n \\returns the name of a display or NULL on failure; call SDL_GetError() for\n          more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetDisplayName(displayID: SDL_DisplayID) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the desktop area represented by a display.\n\n The primary display is always located at (0,0).\n\n \\param displayID the instance ID of the display to query\n \\param rect the SDL_Rect structure filled in with the display bounds\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetDisplayUsableBounds\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetDisplayBounds(displayID: SDL_DisplayID, rect: *mut SDL_Rect) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the usable desktop area represented by a display, in screen\n coordinates.\n\n This is the same area as SDL_GetDisplayBounds() reports, but with portions\n reserved by the system removed. For example, on Apple's macOS, this\n subtracts the area occupied by the menu bar and dock.\n\n Setting a window to be fullscreen generally bypasses these unusable areas,\n so these are good guidelines for the maximum space available to a\n non-fullscreen window.\n\n \\param displayID the instance ID of the display to query\n \\param rect the SDL_Rect structure filled in with the display bounds\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetDisplayBounds\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetDisplayUsableBounds(displayID: SDL_DisplayID, rect: *mut SDL_Rect)
        -> libc::c_int;
}
extern "C" {
    #[doc = " Get the orientation of a display when it is unrotated.\n\n \\param displayID the instance ID of the display to query\n \\returns The SDL_DisplayOrientation enum value of the display, or\n          `SDL_ORIENTATION_UNKNOWN` if it isn't available.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetNaturalDisplayOrientation(displayID: SDL_DisplayID) -> SDL_DisplayOrientation;
}
extern "C" {
    #[doc = " Get the orientation of a display.\n\n \\param displayID the instance ID of the display to query\n \\returns The SDL_DisplayOrientation enum value of the display, or\n          `SDL_ORIENTATION_UNKNOWN` if it isn't available.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetCurrentDisplayOrientation(displayID: SDL_DisplayID) -> SDL_DisplayOrientation;
}
extern "C" {
    #[doc = " Get the content scale of a display.\n\n The content scale is the expected scale for content based on the DPI\n settings of the display. For example, a 4K display might have a 2.0 (200%)\n display scale, which means that the user expects UI elements to be twice as\n big on this display, to aid in readability.\n\n \\param displayID the instance ID of the display to query\n \\returns The content scale of the display, or 0.0f on error; call\n          SDL_GetError() for more details.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetDisplayContentScale(displayID: SDL_DisplayID) -> f32;
}
extern "C" {
    #[doc = " Get a list of fullscreen display modes available on a display.\n\n The display modes are sorted in this priority:\n\n - w -> largest to smallest\n - h -> largest to smallest\n - bits per pixel -> more colors to fewer colors\n - packed pixel layout -> largest to smallest\n - refresh rate -> highest to lowest\n - pixel density -> lowest to highest\n\n \\param displayID the instance ID of the display to query\n \\param count a pointer filled in with the number of displays returned\n \\returns a NULL terminated array of display mode pointers which should be\n          freed with SDL_free(), or NULL on error; call SDL_GetError() for\n          more details.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetFullscreenDisplayModes(
        displayID: SDL_DisplayID,
        count: *mut libc::c_int,
    ) -> *mut *const SDL_DisplayMode;
}
extern "C" {
    #[doc = " Get the closest match to the requested display mode.\n\n The available display modes are scanned and `closest` is filled in with the\n closest mode matching the requested mode and returned. The mode format and\n refresh rate default to the desktop mode if they are set to 0. The modes\n are scanned with size being first priority, format being second priority,\n and finally checking the refresh rate. If all the available modes are too\n small, then NULL is returned.\n\n \\param displayID the instance ID of the display to query\n \\param w the width in pixels of the desired display mode\n \\param h the height in pixels of the desired display mode\n \\param refresh_rate the refresh rate of the desired display mode, or 0.0f\n                     for the desktop refresh rate\n \\param include_high_density_modes Boolean to include high density modes in\n                                   the search\n \\returns a pointer to the closest display mode equal to or larger than the\n          desired mode, or NULL on error; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetDisplays\n \\sa SDL_GetFullscreenDisplayModes"]
    pub fn SDL_GetClosestFullscreenDisplayMode(
        displayID: SDL_DisplayID,
        w: libc::c_int,
        h: libc::c_int,
        refresh_rate: f32,
        include_high_density_modes: SDL_bool,
    ) -> *const SDL_DisplayMode;
}
extern "C" {
    #[doc = " Get information about the desktop's display mode.\n\n There's a difference between this function and SDL_GetCurrentDisplayMode()\n when SDL runs fullscreen and has changed the resolution. In that case this\n function will return the previous native display mode, and not the current\n display mode.\n\n \\param displayID the instance ID of the display to query\n \\returns a pointer to the desktop display mode or NULL on error; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetCurrentDisplayMode\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetDesktopDisplayMode(displayID: SDL_DisplayID) -> *const SDL_DisplayMode;
}
extern "C" {
    #[doc = " Get information about the current display mode.\n\n There's a difference between this function and SDL_GetDesktopDisplayMode()\n when SDL runs fullscreen and has changed the resolution. In that case this\n function will return the current display mode, and not the previous native\n display mode.\n\n \\param displayID the instance ID of the display to query\n \\returns a pointer to the desktop display mode or NULL on error; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetDesktopDisplayMode\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetCurrentDisplayMode(displayID: SDL_DisplayID) -> *const SDL_DisplayMode;
}
extern "C" {
    #[doc = " Get the display containing a point.\n\n \\param point the point to query\n \\returns the instance ID of the display containing the point or 0 on\n          failure; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetDisplayBounds\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetDisplayForPoint(point: *const SDL_Point) -> SDL_DisplayID;
}
extern "C" {
    #[doc = " Get the display primarily containing a rect.\n\n \\param rect the rect to query\n \\returns the instance ID of the display entirely containing the rect or\n          closest to the center of the rect on success or 0 on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetDisplayBounds\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetDisplayForRect(rect: *const SDL_Rect) -> SDL_DisplayID;
}
extern "C" {
    #[doc = " Get the display associated with a window.\n\n \\param window the window to query\n \\returns the instance ID of the display containing the center of the window\n          on success or 0 on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetDisplayBounds\n \\sa SDL_GetDisplays"]
    pub fn SDL_GetDisplayForWindow(window: *mut SDL_Window) -> SDL_DisplayID;
}
extern "C" {
    #[doc = " Get the pixel density of a window.\n\n This is a ratio of pixel size to window size. For example, if the window is\n 1920x1080 and it has a high density back buffer of 3840x2160 pixels, it\n would have a pixel density of 2.0.\n\n \\param window the window to query\n \\returns the pixel density or 0.0f on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowDisplayScale"]
    pub fn SDL_GetWindowPixelDensity(window: *mut SDL_Window) -> f32;
}
extern "C" {
    #[doc = " Get the content display scale relative to a window's pixel size.\n\n This is a combination of the window pixel density and the display content\n scale, and is the expected scale for displaying content in this window. For\n example, if a 3840x2160 window had a display scale of 2.0, the user expects\n the content to take twice as many pixels and be the same physical size as\n if it were being displayed in a 1920x1080 window with a display scale of\n 1.0.\n\n Conceptually this value corresponds to the scale display setting, and is\n updated when that setting is changed, or the window moves to a display with\n a different scale setting.\n\n \\param window the window to query\n \\returns the display scale, or 0.0f on failure; call SDL_GetError() for\n          more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetWindowDisplayScale(window: *mut SDL_Window) -> f32;
}
extern "C" {
    #[doc = " Set the display mode to use when a window is visible and fullscreen.\n\n This only affects the display mode used when the window is fullscreen. To\n change the window size when the window is not fullscreen, use\n SDL_SetWindowSize().\n\n \\param window the window to affect\n \\param mode a pointer to the display mode to use, which can be NULL for\n             desktop mode, or one of the fullscreen modes returned by\n             SDL_GetFullscreenDisplayModes().\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowFullscreenMode\n \\sa SDL_SetWindowFullscreen"]
    pub fn SDL_SetWindowFullscreenMode(
        window: *mut SDL_Window,
        mode: *const SDL_DisplayMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Query the display mode to use when a window is visible at fullscreen.\n\n \\param window the window to query\n \\returns a pointer to the fullscreen mode to use or NULL for desktop mode\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetWindowFullscreenMode\n \\sa SDL_SetWindowFullscreen"]
    pub fn SDL_GetWindowFullscreenMode(window: *mut SDL_Window) -> *const SDL_DisplayMode;
}
extern "C" {
    #[doc = " Get the raw ICC profile data for the screen the window is currently on.\n\n Data returned should be freed with SDL_free.\n\n \\param window the window to query\n \\param size the size of the ICC profile\n \\returns the raw ICC profile data on success or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetWindowICCProfile(window: *mut SDL_Window, size: *mut usize) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Get the pixel format associated with the window.\n\n \\param window the window to query\n \\returns the pixel format of the window on success or\n          SDL_PIXELFORMAT_UNKNOWN on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetWindowPixelFormat(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
    #[doc = " Create a window with the specified dimensions and flags.\n\n `flags` may be any of the following OR'd together:\n\n - `SDL_WINDOW_FULLSCREEN`: fullscreen window at desktop resolution\n - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context\n - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance\n - `SDL_WINDOW_METAL`: window usable with a Metal instance\n - `SDL_WINDOW_HIDDEN`: window is not visible\n - `SDL_WINDOW_BORDERLESS`: no window decoration\n - `SDL_WINDOW_RESIZABLE`: window can be resized\n - `SDL_WINDOW_MINIMIZED`: window is minimized\n - `SDL_WINDOW_MAXIMIZED`: window is maximized\n - `SDL_WINDOW_MOUSE_GRABBED`: window has grabbed mouse focus\n\n The SDL_Window is implicitly shown if SDL_WINDOW_HIDDEN is not set.\n\n On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist\n property to YES, otherwise you will not receive a High-DPI OpenGL canvas.\n\n The window pixel size may differ from its window coordinate size if the\n window is on a high pixel density display. Use SDL_GetWindowSize() to query\n the client area's size in window coordinates, and\n SDL_GetWindowSizeInPixels() or SDL_GetRenderOutputSize() to query the\n drawable size in pixels. Note that the drawable size can vary after the\n window is created and should be queried again if you get an\n SDL_EVENT_WINDOW_PIXEL_SIZE_CHANGED event.\n\n If the window is set fullscreen, the width and height parameters `w` and\n `h` will not be used. However, invalid size parameters (e.g. too large) may\n still fail. Window size is actually limited to 16384 x 16384 for all\n platforms at window creation.\n\n If the window is created with any of the SDL_WINDOW_OPENGL or\n SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function\n (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the\n corresponding UnloadLibrary function is called by SDL_DestroyWindow().\n\n If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,\n SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.\n\n If SDL_WINDOW_METAL is specified on an OS that does not support Metal,\n SDL_CreateWindow() will fail.\n\n On non-Apple devices, SDL requires you to either not link to the Vulkan\n loader or link to a dynamic library version. This limitation may be removed\n in a future version of SDL.\n\n \\param title the title of the window, in UTF-8 encoding\n \\param w the width of the window\n \\param h the height of the window\n \\param flags 0, or one or more SDL_WindowFlags OR'd together\n \\returns the window that was created or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreatePopupWindow\n \\sa SDL_CreateWindowFrom\n \\sa SDL_CreateWindowWithPosition\n \\sa SDL_DestroyWindow"]
    pub fn SDL_CreateWindow(
        title: *const libc::c_char,
        w: libc::c_int,
        h: libc::c_int,
        flags: Uint32,
    ) -> *mut SDL_Window;
}
extern "C" {
    #[doc = " Create a window with the specified position, dimensions, and flags.\n\n `flags` may be any of the following OR'd together:\n\n - `SDL_WINDOW_FULLSCREEN`: fullscreen window at desktop resolution\n - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context\n - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance\n - `SDL_WINDOW_METAL`: window usable with a Metal instance\n - `SDL_WINDOW_HIDDEN`: window is not visible\n - `SDL_WINDOW_BORDERLESS`: no window decoration\n - `SDL_WINDOW_RESIZABLE`: window can be resized\n - `SDL_WINDOW_MINIMIZED`: window is minimized\n - `SDL_WINDOW_MAXIMIZED`: window is maximized\n - `SDL_WINDOW_MOUSE_GRABBED`: window has grabbed mouse focus\n\n The SDL_Window is implicitly shown if SDL_WINDOW_HIDDEN is not set.\n\n On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist\n property to YES, otherwise you will not receive a High-DPI OpenGL canvas.\n\n The window pixel size may differ from its window coordinate size if the\n window is on a high pixel density display. Use SDL_GetWindowSize() to query\n the client area's size in window coordinates, and\n SDL_GetWindowSizeInPixels() or SDL_GetRenderOutputSize() to query the\n drawable size in pixels. Note that the drawable size can vary after the\n window is created and should be queried again if you get an\n SDL_EVENT_WINDOW_PIXEL_SIZE_CHANGED event.\n\n If the window is set fullscreen, the width and height parameters `w` and\n `h` will not be used. However, invalid size parameters (e.g. too large) may\n still fail. Window size is actually limited to 16384 x 16384 for all\n platforms at window creation.\n\n If the window is created with any of the SDL_WINDOW_OPENGL or\n SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function\n (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the\n corresponding UnloadLibrary function is called by SDL_DestroyWindow().\n\n If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,\n SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.\n\n If SDL_WINDOW_METAL is specified on an OS that does not support Metal,\n SDL_CreateWindow() will fail.\n\n On non-Apple devices, SDL requires you to either not link to the Vulkan\n loader or link to a dynamic library version. This limitation may be removed\n in a future version of SDL.\n\n \\param title the title of the window, in UTF-8 encoding\n \\param x the x position of the window, or `SDL_WINDOWPOS_CENTERED`\n \\param y the y position of the window, or `SDL_WINDOWPOS_CENTERED`\n \\param w the width of the window\n \\param h the height of the window\n \\param flags 0, or one or more SDL_WindowFlags OR'd together\n \\returns the window that was created or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreatePopupWindow\n \\sa SDL_CreateWindow\n \\sa SDL_CreateWindowFrom\n \\sa SDL_DestroyWindow"]
    pub fn SDL_CreateWindowWithPosition(
        title: *const libc::c_char,
        x: libc::c_int,
        y: libc::c_int,
        w: libc::c_int,
        h: libc::c_int,
        flags: Uint32,
    ) -> *mut SDL_Window;
}
extern "C" {
    #[doc = " Create a child popup window of the specified parent window.\n\n 'flags' **must** contain exactly one of the following: -\n 'SDL_WINDOW_TOOLTIP': The popup window is a tooltip and will not pass any\n input events. - 'SDL_WINDOW_POPUP_MENU': The popup window is a popup menu.\n The topmost popup menu will implicitly gain the keyboard focus.\n\n The following flags are not relevant to popup window creation and will be\n ignored: - 'SDL_WINDOW_MINIMIZED' - 'SDL_WINDOW_MAXIMIZED' -\n 'SDL_WINDOW_FULLSCREEN' - 'SDL_WINDOW_BORDERLESS' -\n 'SDL_WINDOW_SKIP_TASKBAR'\n\n The parent parameter **must** be non-null and a valid window. The parent of\n a popup window can be either a regular, toplevel window, or another popup\n window.\n\n Popup windows cannot be minimized, maximized, made fullscreen, raised,\n flash, be made a modal window, be the parent of a modal window, or grab the\n mouse and/or keyboard. Attempts to do so will fail.\n\n Popup windows implicitly do not have a border/decorations and do not appear\n on the taskbar/dock or in lists of windows such as alt-tab menus.\n\n If a parent window is hidden, any child popup windows will be recursively\n hidden as well. Child popup windows not explicitly hidden will be restored\n when the parent is shown.\n\n If the parent window is destroyed, any child popup windows will be\n recursively destroyed as well.\n\n \\param parent the parent of the window, must not be NULL\n \\param offset_x the x position of the popup window relative to the origin\n                 of the parent\n \\param offset_y the y position of the popup window relative to the origin\n                 of the parent window\n \\param w the width of the window\n \\param h the height of the window\n \\param flags SDL_WINDOW_TOOLTIP or SDL_WINDOW_POPUP MENU, and zero or more\n              additional SDL_WindowFlags OR'd together.\n \\returns the window that was created or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateWindow\n \\sa SDL_DestroyWindow\n \\sa SDL_GetWindowParent"]
    pub fn SDL_CreatePopupWindow(
        parent: *mut SDL_Window,
        offset_x: libc::c_int,
        offset_y: libc::c_int,
        w: libc::c_int,
        h: libc::c_int,
        flags: Uint32,
    ) -> *mut SDL_Window;
}
extern "C" {
    #[doc = " Create an SDL window from an existing native window.\n\n In some cases (e.g. OpenGL) and on some platforms (e.g. Microsoft Windows)\n the hint `SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT` needs to be configured\n before using SDL_CreateWindowFrom().\n\n \\param data a pointer to driver-dependent window creation data, typically\n             your native window cast to a void*\n \\returns the window that was created or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateWindow\n \\sa SDL_DestroyWindow"]
    pub fn SDL_CreateWindowFrom(data: *const libc::c_void) -> *mut SDL_Window;
}
extern "C" {
    #[doc = " Get the numeric ID of a window.\n\n The numeric ID is what SDL_WindowEvent references, and is necessary to map\n these events to specific SDL_Window objects.\n\n \\param window the window to query\n \\returns the ID of the window on success or 0 on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowFromID"]
    pub fn SDL_GetWindowID(window: *mut SDL_Window) -> SDL_WindowID;
}
extern "C" {
    #[doc = " Get a window from a stored ID.\n\n The numeric ID is what SDL_WindowEvent references, and is necessary to map\n these events to specific SDL_Window objects.\n\n \\param id the ID of the window\n \\returns the window associated with `id` or NULL if it doesn't exist; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowID"]
    pub fn SDL_GetWindowFromID(id: SDL_WindowID) -> *mut SDL_Window;
}
extern "C" {
    #[doc = " Get parent of a window.\n\n \\param window the window to query\n \\returns the parent of the window on success or NULL if the window has no\n          parent.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreatePopupWindow"]
    pub fn SDL_GetWindowParent(window: *mut SDL_Window) -> *mut SDL_Window;
}
extern "C" {
    #[doc = " Get the window flags.\n\n \\param window the window to query\n \\returns a mask of the SDL_WindowFlags associated with `window`\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateWindow\n \\sa SDL_HideWindow\n \\sa SDL_MaximizeWindow\n \\sa SDL_MinimizeWindow\n \\sa SDL_SetWindowFullscreen\n \\sa SDL_SetWindowGrab\n \\sa SDL_ShowWindow"]
    pub fn SDL_GetWindowFlags(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
    #[doc = " Set the title of a window.\n\n This string is expected to be in UTF-8 encoding.\n\n \\param window the window to change\n \\param title the desired window title in UTF-8 format\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowTitle"]
    pub fn SDL_SetWindowTitle(window: *mut SDL_Window, title: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the title of a window.\n\n \\param window the window to query\n \\returns the title of the window in UTF-8 format or \"\" if there is no\n          title.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetWindowTitle"]
    pub fn SDL_GetWindowTitle(window: *mut SDL_Window) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Set the icon for a window.\n\n \\param window the window to change\n \\param icon an SDL_Surface structure containing the icon for the window\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_SetWindowIcon(window: *mut SDL_Window, icon: *mut SDL_Surface) -> libc::c_int;
}
extern "C" {
    #[doc = " Associate an arbitrary named pointer with a window.\n\n `name` is case-sensitive.\n\n \\param window the window to associate with the pointer\n \\param name the name of the pointer\n \\param userdata the associated pointer\n \\returns the previous value associated with `name`.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowData"]
    pub fn SDL_SetWindowData(
        window: *mut SDL_Window,
        name: *const libc::c_char,
        userdata: *mut libc::c_void,
    ) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Retrieve the data pointer associated with a window.\n\n \\param window the window to query\n \\param name the name of the pointer\n \\returns the value associated with `name`.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetWindowData"]
    pub fn SDL_GetWindowData(
        window: *mut SDL_Window,
        name: *const libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Set the position of a window.\n\n \\param window the window to reposition\n \\param x the x coordinate of the window, or `SDL_WINDOWPOS_CENTERED` or\n          `SDL_WINDOWPOS_UNDEFINED`\n \\param y the y coordinate of the window, or `SDL_WINDOWPOS_CENTERED` or\n          `SDL_WINDOWPOS_UNDEFINED`\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowPosition"]
    pub fn SDL_SetWindowPosition(
        window: *mut SDL_Window,
        x: libc::c_int,
        y: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the position of a window.\n\n If you do not need the value for one of the positions a NULL may be passed\n in the `x` or `y` parameter.\n\n \\param window the window to query\n \\param x a pointer filled in with the x position of the window, may be NULL\n \\param y a pointer filled in with the y position of the window, may be NULL\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetWindowPosition"]
    pub fn SDL_GetWindowPosition(
        window: *mut SDL_Window,
        x: *mut libc::c_int,
        y: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the size of a window's client area.\n\n This only affects the size of the window when not in fullscreen mode. To\n change the fullscreen mode of a window, use SDL_SetWindowFullscreenMode()\n\n \\param window the window to change\n \\param w the width of the window, must be > 0\n \\param h the height of the window, must be > 0\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowSize\n \\sa SDL_SetWindowFullscreenMode"]
    pub fn SDL_SetWindowSize(
        window: *mut SDL_Window,
        w: libc::c_int,
        h: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the size of a window's client area.\n\n NULL can safely be passed as the `w` or `h` parameter if the width or\n height value is not desired.\n\n The window pixel size may differ from its window coordinate size if the\n window is on a high pixel density display. Use SDL_GetWindowSizeInPixels()\n or SDL_GetRenderOutputSize() to get the real client area size in pixels.\n\n \\param window the window to query the width and height from\n \\param w a pointer filled in with the width of the window, may be NULL\n \\param h a pointer filled in with the height of the window, may be NULL\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetRenderOutputSize\n \\sa SDL_GetWindowSizeInPixels\n \\sa SDL_SetWindowSize"]
    pub fn SDL_GetWindowSize(
        window: *mut SDL_Window,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the size of a window's borders (decorations) around the client area.\n\n Note: If this function fails (returns -1), the size values will be\n initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the\n window in question was borderless.\n\n Note: This function may fail on systems where the window has not yet been\n decorated by the display server (for example, immediately after calling\n SDL_CreateWindow). It is recommended that you wait at least until the\n window has been presented and composited, so that the window system has a\n chance to decorate the window and provide the border dimensions to SDL.\n\n This function also returns -1 if getting the information is not supported.\n\n \\param window the window to query the size values of the border\n               (decorations) from\n \\param top pointer to variable for storing the size of the top border; NULL\n            is permitted\n \\param left pointer to variable for storing the size of the left border;\n             NULL is permitted\n \\param bottom pointer to variable for storing the size of the bottom\n               border; NULL is permitted\n \\param right pointer to variable for storing the size of the right border;\n              NULL is permitted\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowSize"]
    pub fn SDL_GetWindowBordersSize(
        window: *mut SDL_Window,
        top: *mut libc::c_int,
        left: *mut libc::c_int,
        bottom: *mut libc::c_int,
        right: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the size of a window's client area, in pixels.\n\n \\param window the window from which the drawable size should be queried\n \\param w a pointer to variable for storing the width in pixels, may be NULL\n \\param h a pointer to variable for storing the height in pixels, may be\n          NULL\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateWindow\n \\sa SDL_GetWindowSize"]
    pub fn SDL_GetWindowSizeInPixels(
        window: *mut SDL_Window,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the minimum size of a window's client area.\n\n \\param window the window to change\n \\param min_w the minimum width of the window, or 0 for no limit\n \\param min_h the minimum height of the window, or 0 for no limit\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowMinimumSize\n \\sa SDL_SetWindowMaximumSize"]
    pub fn SDL_SetWindowMinimumSize(
        window: *mut SDL_Window,
        min_w: libc::c_int,
        min_h: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the minimum size of a window's client area.\n\n \\param window the window to query\n \\param w a pointer filled in with the minimum width of the window, may be\n          NULL\n \\param h a pointer filled in with the minimum height of the window, may be\n          NULL\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowMaximumSize\n \\sa SDL_SetWindowMinimumSize"]
    pub fn SDL_GetWindowMinimumSize(
        window: *mut SDL_Window,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the maximum size of a window's client area.\n\n \\param window the window to change\n \\param max_w the maximum width of the window, or 0 for no limit\n \\param max_h the maximum height of the window, or 0 for no limit\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowMaximumSize\n \\sa SDL_SetWindowMinimumSize"]
    pub fn SDL_SetWindowMaximumSize(
        window: *mut SDL_Window,
        max_w: libc::c_int,
        max_h: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the maximum size of a window's client area.\n\n \\param window the window to query\n \\param w a pointer filled in with the maximum width of the window, may be\n          NULL\n \\param h a pointer filled in with the maximum height of the window, may be\n          NULL\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowMinimumSize\n \\sa SDL_SetWindowMaximumSize"]
    pub fn SDL_GetWindowMaximumSize(
        window: *mut SDL_Window,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the border state of a window.\n\n This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add\n or remove the border from the actual window. This is a no-op if the\n window's border already matches the requested state.\n\n You can't change the border state of a fullscreen window.\n\n \\param window the window of which to change the border state\n \\param bordered SDL_FALSE to remove border, SDL_TRUE to add border\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowFlags"]
    pub fn SDL_SetWindowBordered(window: *mut SDL_Window, bordered: SDL_bool) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the user-resizable state of a window.\n\n This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and\n allow/disallow user resizing of the window. This is a no-op if the window's\n resizable state already matches the requested state.\n\n You can't change the resizable state of a fullscreen window.\n\n \\param window the window of which to change the resizable state\n \\param resizable SDL_TRUE to allow resizing, SDL_FALSE to disallow\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowFlags"]
    pub fn SDL_SetWindowResizable(window: *mut SDL_Window, resizable: SDL_bool) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the window to always be above the others.\n\n This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This\n will bring the window to the front and keep the window above the rest.\n\n \\param window The window of which to change the always on top state\n \\param on_top SDL_TRUE to set the window always on top, SDL_FALSE to\n               disable\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowFlags"]
    pub fn SDL_SetWindowAlwaysOnTop(window: *mut SDL_Window, on_top: SDL_bool) -> libc::c_int;
}
extern "C" {
    #[doc = " Show a window.\n\n \\param window the window to show\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HideWindow\n \\sa SDL_RaiseWindow"]
    pub fn SDL_ShowWindow(window: *mut SDL_Window) -> libc::c_int;
}
extern "C" {
    #[doc = " Hide a window.\n\n \\param window the window to hide\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_ShowWindow"]
    pub fn SDL_HideWindow(window: *mut SDL_Window) -> libc::c_int;
}
extern "C" {
    #[doc = " Raise a window above other windows and set the input focus.\n\n \\param window the window to raise\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_RaiseWindow(window: *mut SDL_Window) -> libc::c_int;
}
extern "C" {
    #[doc = " Make a window as large as possible.\n\n \\param window the window to maximize\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_MinimizeWindow\n \\sa SDL_RestoreWindow"]
    pub fn SDL_MaximizeWindow(window: *mut SDL_Window) -> libc::c_int;
}
extern "C" {
    #[doc = " Minimize a window to an iconic representation.\n\n \\param window the window to minimize\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_MaximizeWindow\n \\sa SDL_RestoreWindow"]
    pub fn SDL_MinimizeWindow(window: *mut SDL_Window) -> libc::c_int;
}
extern "C" {
    #[doc = " Restore the size and position of a minimized or maximized window.\n\n \\param window the window to restore\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_MaximizeWindow\n \\sa SDL_MinimizeWindow"]
    pub fn SDL_RestoreWindow(window: *mut SDL_Window) -> libc::c_int;
}
extern "C" {
    #[doc = " Set a window's fullscreen state.\n\n By default a window in fullscreen state uses fullscreen desktop mode, but a\n specific display mode can be set using SDL_SetWindowFullscreenMode().\n\n \\param window the window to change\n \\param fullscreen SDL_TRUE for fullscreen mode, SDL_FALSE for windowed mode\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowFullscreenMode\n \\sa SDL_SetWindowFullscreenMode"]
    pub fn SDL_SetWindowFullscreen(window: *mut SDL_Window, fullscreen: SDL_bool) -> libc::c_int;
}
extern "C" {
    #[doc = " Return whether the window has a surface associated with it.\n\n \\param window the window to query\n \\returns SDL_TRUE if there is a surface associated with the window, or\n          SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowSurface"]
    pub fn SDL_HasWindowSurface(window: *mut SDL_Window) -> SDL_bool;
}
extern "C" {
    #[doc = " Get the SDL surface associated with the window.\n\n A new surface will be created with the optimal format for the window, if\n necessary. This surface will be freed when the window is destroyed. Do not\n free this surface.\n\n This surface will be invalidated if the window is resized. After resizing a\n window this function must be called again to return a valid surface.\n\n You may not combine this with 3D or the rendering API on this window.\n\n This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.\n\n \\param window the window to query\n \\returns the surface associated with the window, or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_DestroyWindowSurface\n \\sa SDL_HasWindowSurface\n \\sa SDL_UpdateWindowSurface\n \\sa SDL_UpdateWindowSurfaceRects"]
    pub fn SDL_GetWindowSurface(window: *mut SDL_Window) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = " Copy the window surface to the screen.\n\n This is the function you use to reflect any changes to the surface on the\n screen.\n\n This function is equivalent to the SDL 1.2 API SDL_Flip().\n\n \\param window the window to update\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowSurface\n \\sa SDL_UpdateWindowSurfaceRects"]
    pub fn SDL_UpdateWindowSurface(window: *mut SDL_Window) -> libc::c_int;
}
extern "C" {
    #[doc = " Copy areas of the window surface to the screen.\n\n This is the function you use to reflect changes to portions of the surface\n on the screen.\n\n This function is equivalent to the SDL 1.2 API SDL_UpdateRects().\n\n \\param window the window to update\n \\param rects an array of SDL_Rect structures representing areas of the\n              surface to copy, in pixels\n \\param numrects the number of rectangles\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowSurface\n \\sa SDL_UpdateWindowSurface"]
    pub fn SDL_UpdateWindowSurfaceRects(
        window: *mut SDL_Window,
        rects: *const SDL_Rect,
        numrects: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Destroy the surface associated with the window.\n\n \\param window the window to update\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowSurface\n \\sa SDL_HasWindowSurface"]
    pub fn SDL_DestroyWindowSurface(window: *mut SDL_Window) -> libc::c_int;
}
extern "C" {
    #[doc = " Set a window's input grab mode.\n\n When input is grabbed, the mouse is confined to the window. This function\n will also grab the keyboard if `SDL_HINT_GRAB_KEYBOARD` is set. To grab the\n keyboard without also grabbing the mouse, use SDL_SetWindowKeyboardGrab().\n\n If the caller enables a grab while another window is currently grabbed, the\n other window loses its grab in favor of the caller's window.\n\n \\param window the window for which the input grab mode should be set\n \\param grabbed SDL_TRUE to grab input or SDL_FALSE to release input\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetGrabbedWindow\n \\sa SDL_GetWindowGrab"]
    pub fn SDL_SetWindowGrab(window: *mut SDL_Window, grabbed: SDL_bool) -> libc::c_int;
}
extern "C" {
    #[doc = " Set a window's keyboard grab mode.\n\n Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or\n the Meta/Super key. Note that not all system keyboard shortcuts can be\n captured by applications (one example is Ctrl+Alt+Del on Windows).\n\n This is primarily intended for specialized applications such as VNC clients\n or VM frontends. Normal games should not use keyboard grab.\n\n When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the\n window is full-screen to ensure the user is not trapped in your\n application. If you have a custom keyboard shortcut to exit fullscreen\n mode, you may suppress this behavior with\n `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.\n\n If the caller enables a grab while another window is currently grabbed, the\n other window loses its grab in favor of the caller's window.\n\n \\param window The window for which the keyboard grab mode should be set.\n \\param grabbed This is SDL_TRUE to grab keyboard, and SDL_FALSE to release.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowKeyboardGrab\n \\sa SDL_SetWindowMouseGrab\n \\sa SDL_SetWindowGrab"]
    pub fn SDL_SetWindowKeyboardGrab(window: *mut SDL_Window, grabbed: SDL_bool) -> libc::c_int;
}
extern "C" {
    #[doc = " Set a window's mouse grab mode.\n\n Mouse grab confines the mouse cursor to the window.\n\n \\param window The window for which the mouse grab mode should be set.\n \\param grabbed This is SDL_TRUE to grab mouse, and SDL_FALSE to release.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowMouseGrab\n \\sa SDL_SetWindowKeyboardGrab\n \\sa SDL_SetWindowGrab"]
    pub fn SDL_SetWindowMouseGrab(window: *mut SDL_Window, grabbed: SDL_bool) -> libc::c_int;
}
extern "C" {
    #[doc = " Get a window's input grab mode.\n\n \\param window the window to query\n \\returns SDL_TRUE if input is grabbed, SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetWindowGrab"]
    pub fn SDL_GetWindowGrab(window: *mut SDL_Window) -> SDL_bool;
}
extern "C" {
    #[doc = " Get a window's keyboard grab mode.\n\n \\param window the window to query\n \\returns SDL_TRUE if keyboard is grabbed, and SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetWindowKeyboardGrab\n \\sa SDL_GetWindowGrab"]
    pub fn SDL_GetWindowKeyboardGrab(window: *mut SDL_Window) -> SDL_bool;
}
extern "C" {
    #[doc = " Get a window's mouse grab mode.\n\n \\param window the window to query\n \\returns SDL_TRUE if mouse is grabbed, and SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetWindowKeyboardGrab\n \\sa SDL_GetWindowGrab"]
    pub fn SDL_GetWindowMouseGrab(window: *mut SDL_Window) -> SDL_bool;
}
extern "C" {
    #[doc = " Get the window that currently has an input grab enabled.\n\n \\returns the window if input is grabbed or NULL otherwise.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowGrab\n \\sa SDL_SetWindowGrab"]
    pub fn SDL_GetGrabbedWindow() -> *mut SDL_Window;
}
extern "C" {
    #[doc = " Confines the cursor to the specified area of a window.\n\n Note that this does NOT grab the cursor, it only defines the area a cursor\n is restricted to when the window has mouse focus.\n\n \\param window The window that will be associated with the barrier.\n \\param rect A rectangle area in window-relative coordinates. If NULL the\n             barrier for the specified window will be destroyed.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowMouseRect\n \\sa SDL_SetWindowMouseGrab"]
    pub fn SDL_SetWindowMouseRect(window: *mut SDL_Window, rect: *const SDL_Rect) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the mouse confinement rectangle of a window.\n\n \\param window The window to query\n \\returns A pointer to the mouse confinement rectangle of a window, or NULL\n          if there isn't one.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetWindowMouseRect"]
    pub fn SDL_GetWindowMouseRect(window: *mut SDL_Window) -> *const SDL_Rect;
}
extern "C" {
    #[doc = " Set the opacity for a window.\n\n The parameter `opacity` will be clamped internally between 0.0f\n (transparent) and 1.0f (opaque).\n\n This function also returns -1 if setting the opacity isn't supported.\n\n \\param window the window which will be made transparent or opaque\n \\param opacity the opacity value (0.0f - transparent, 1.0f - opaque)\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetWindowOpacity"]
    pub fn SDL_SetWindowOpacity(window: *mut SDL_Window, opacity: f32) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the opacity of a window.\n\n If transparency isn't supported on this platform, opacity will be reported\n as 1.0f without error.\n\n The parameter `opacity` is ignored if it is NULL.\n\n This function also returns -1 if an invalid window was provided.\n\n \\param window the window to get the current opacity value from\n \\param out_opacity the float filled in (0.0f - transparent, 1.0f - opaque)\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetWindowOpacity"]
    pub fn SDL_GetWindowOpacity(window: *mut SDL_Window, out_opacity: *mut f32) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the window as a modal for another window.\n\n \\param modal_window the window that should be set modal\n \\param parent_window the parent window for the modal window\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_SetWindowModalFor(
        modal_window: *mut SDL_Window,
        parent_window: *mut SDL_Window,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Explicitly set input focus to the window.\n\n You almost certainly want SDL_RaiseWindow() instead of this function. Use\n this with caution, as you might give focus to a window that is completely\n obscured by other windows.\n\n \\param window the window that should get the input focus\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_RaiseWindow"]
    pub fn SDL_SetWindowInputFocus(window: *mut SDL_Window) -> libc::c_int;
}
#[repr(u32)]
#[doc = " Possible return values from the SDL_HitTest callback.\n\n \\sa SDL_HitTest"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_HitTestResult {
    #[doc = "< Region is normal. No special properties."]
    SDL_HITTEST_NORMAL = 0,
    #[doc = "< Region can drag entire window."]
    SDL_HITTEST_DRAGGABLE = 1,
    SDL_HITTEST_RESIZE_TOPLEFT = 2,
    SDL_HITTEST_RESIZE_TOP = 3,
    SDL_HITTEST_RESIZE_TOPRIGHT = 4,
    SDL_HITTEST_RESIZE_RIGHT = 5,
    SDL_HITTEST_RESIZE_BOTTOMRIGHT = 6,
    SDL_HITTEST_RESIZE_BOTTOM = 7,
    SDL_HITTEST_RESIZE_BOTTOMLEFT = 8,
    SDL_HITTEST_RESIZE_LEFT = 9,
}
#[doc = " Callback used for hit-testing.\n\n \\param win the SDL_Window where hit-testing was set on\n \\param area an SDL_Point which should be hit-tested\n \\param data what was passed as `callback_data` to SDL_SetWindowHitTest()\n \\returns an SDL_HitTestResult value.\n\n \\sa SDL_SetWindowHitTest"]
pub type SDL_HitTest = ::core::option::Option<
    unsafe extern "C" fn(
        win: *mut SDL_Window,
        area: *const SDL_Point,
        data: *mut libc::c_void,
    ) -> SDL_HitTestResult,
>;
extern "C" {
    #[doc = " Provide a callback that decides if a window region has special properties.\n\n Normally windows are dragged and resized by decorations provided by the\n system window manager (a title bar, borders, etc), but for some apps, it\n makes sense to drag them from somewhere else inside the window itself; for\n example, one might have a borderless window that wants to be draggable from\n any part, or simulate its own title bar, etc.\n\n This function lets the app provide a callback that designates pieces of a\n given window as special. This callback is run during event processing if we\n need to tell the OS to treat a region of the window specially; the use of\n this callback is known as \"hit testing.\"\n\n Mouse input may not be delivered to your application if it is within a\n special area; the OS will often apply that input to moving the window or\n resizing the window and not deliver it to the application.\n\n Specifying NULL for a callback disables hit-testing. Hit-testing is\n disabled by default.\n\n Platforms that don't support this functionality will return -1\n unconditionally, even if you're attempting to disable hit-testing.\n\n Your callback may fire at any time, and its firing does not indicate any\n specific behavior (for example, on Windows, this certainly might fire when\n the OS is deciding whether to drag your window, but it fires for lots of\n other reasons, too, some unrelated to anything you probably care about _and\n when the mouse isn't actually at the location it is testing_). Since this\n can fire at any time, you should try to keep your callback efficient,\n devoid of allocations, etc.\n\n \\param window the window to set hit-testing on\n \\param callback the function to call when doing a hit-test\n \\param callback_data an app-defined void pointer passed to **callback**\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_SetWindowHitTest(
        window: *mut SDL_Window,
        callback: SDL_HitTest,
        callback_data: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Request a window to demand attention from the user.\n\n \\param window the window to be flashed\n \\param operation the flash operation\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_FlashWindow(window: *mut SDL_Window, operation: SDL_FlashOperation) -> libc::c_int;
}
extern "C" {
    #[doc = " Destroy a window.\n\n If `window` is NULL, this function will return immediately after setting\n the SDL error message to \"Invalid window\". See SDL_GetError().\n\n \\param window the window to destroy\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateWindow\n \\sa SDL_CreateWindowFrom"]
    pub fn SDL_DestroyWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = " Check whether the screensaver is currently enabled.\n\n The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2\n the screensaver was enabled by default.\n\n The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.\n\n \\returns SDL_TRUE if the screensaver is enabled, SDL_FALSE if it is\n          disabled.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_DisableScreenSaver\n \\sa SDL_EnableScreenSaver"]
    pub fn SDL_ScreenSaverEnabled() -> SDL_bool;
}
extern "C" {
    #[doc = " Allow the screen to be blanked by a screen saver.\n\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_DisableScreenSaver\n \\sa SDL_ScreenSaverEnabled"]
    pub fn SDL_EnableScreenSaver() -> libc::c_int;
}
extern "C" {
    #[doc = " Prevent the screen from being blanked by a screen saver.\n\n If you disable the screensaver, it is automatically re-enabled when SDL\n quits.\n\n The screensaver is disabled by default since SDL 2.0.2. Before SDL 2.0.2\n the screensaver was enabled by default.\n\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_EnableScreenSaver\n \\sa SDL_ScreenSaverEnabled"]
    pub fn SDL_DisableScreenSaver() -> libc::c_int;
}
extern "C" {
    #[doc = " Dynamically load an OpenGL library.\n\n This should be done after initializing the video driver, but before\n creating any OpenGL windows. If no OpenGL library is loaded, the default\n library will be loaded upon creation of the first OpenGL window.\n\n If you do this, you need to retrieve all of the GL functions used in your\n program from the dynamic library using SDL_GL_GetProcAddress().\n\n \\param path the platform dependent OpenGL library name, or NULL to open the\n             default OpenGL library\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GL_GetProcAddress\n \\sa SDL_GL_UnloadLibrary"]
    pub fn SDL_GL_LoadLibrary(path: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Get an OpenGL function by name.\n\n If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all\n GL functions must be retrieved this way. Usually this is used to retrieve\n function pointers to OpenGL extensions.\n\n There are some quirks to looking up OpenGL functions that require some\n extra care from the application. If you code carefully, you can handle\n these quirks without any platform-specific code, though:\n\n - On Windows, function pointers are specific to the current GL context;\n   this means you need to have created a GL context and made it current\n   before calling SDL_GL_GetProcAddress(). If you recreate your context or\n   create a second context, you should assume that any existing function\n   pointers aren't valid to use with it. This is (currently) a\n   Windows-specific limitation, and in practice lots of drivers don't suffer\n   this limitation, but it is still the way the wgl API is documented to\n   work and you should expect crashes if you don't respect it. Store a copy\n   of the function pointers that comes and goes with context lifespan.\n - On X11, function pointers returned by this function are valid for any\n   context, and can even be looked up before a context is created at all.\n   This means that, for at least some common OpenGL implementations, if you\n   look up a function that doesn't exist, you'll get a non-NULL result that\n   is _NOT_ safe to call. You must always make sure the function is actually\n   available for a given GL context before calling it, by checking for the\n   existence of the appropriate extension with SDL_GL_ExtensionSupported(),\n   or verifying that the version of OpenGL you're using offers the function\n   as core functionality.\n - Some OpenGL drivers, on all platforms, *will* return NULL if a function\n   isn't supported, but you can't count on this behavior. Check for\n   extensions you use, and if you get a NULL anyway, act as if that\n   extension wasn't available. This is probably a bug in the driver, but you\n   can code defensively for this scenario anyhow.\n - Just because you're on Linux/Unix, don't assume you'll be using X11.\n   Next-gen display servers are waiting to replace it, and may or may not\n   make the same promises about function pointers.\n - OpenGL function pointers must be declared `APIENTRY` as in the example\n   code. This will ensure the proper calling convention is followed on\n   platforms where this matters (Win32) thereby avoiding stack corruption.\n\n \\param proc the name of an OpenGL function\n \\returns a pointer to the named OpenGL function. The returned pointer\n          should be cast to the appropriate function signature.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GL_ExtensionSupported\n \\sa SDL_GL_LoadLibrary\n \\sa SDL_GL_UnloadLibrary"]
    pub fn SDL_GL_GetProcAddress(proc_: *const libc::c_char) -> SDL_FunctionPointer;
}
extern "C" {
    #[doc = " Get an EGL library function by name.\n\n If an EGL library is loaded, this function allows applications to get entry\n points for EGL functions. This is useful to provide to an EGL API and\n extension loader.\n\n \\param proc the name of an EGL function\n \\returns a pointer to the named EGL function. The returned pointer should\n          be cast to the appropriate function signature.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GL_GetCurrentEGLDisplay"]
    pub fn SDL_EGL_GetProcAddress(proc_: *const libc::c_char) -> SDL_FunctionPointer;
}
extern "C" {
    #[doc = " Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GL_LoadLibrary"]
    pub fn SDL_GL_UnloadLibrary();
}
extern "C" {
    #[doc = " Check if an OpenGL extension is supported for the current context.\n\n This function operates on the current GL context; you must have created a\n context and it must be current before calling this function. Do not assume\n that all contexts you create will have the same set of extensions\n available, or that recreating an existing context will offer the same\n extensions again.\n\n While it's probably not a massive overhead, this function is not an O(1)\n operation. Check the extensions you care about after creating the GL\n context and save that information somewhere instead of calling the function\n every time you need to know.\n\n \\param extension the name of the extension to check\n \\returns SDL_TRUE if the extension is supported, SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GL_ExtensionSupported(extension: *const libc::c_char) -> SDL_bool;
}
extern "C" {
    #[doc = " Reset all previously set OpenGL context attributes to their default values.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GL_GetAttribute\n \\sa SDL_GL_SetAttribute"]
    pub fn SDL_GL_ResetAttributes();
}
extern "C" {
    #[doc = " Set an OpenGL window attribute before window creation.\n\n This function sets the OpenGL attribute `attr` to `value`. The requested\n attributes should be set before creating an OpenGL window. You should use\n SDL_GL_GetAttribute() to check the values after creating the OpenGL\n context, since the values obtained can differ from the requested ones.\n\n \\param attr an SDL_GLattr enum value specifying the OpenGL attribute to set\n \\param value the desired value for the attribute\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GL_GetAttribute\n \\sa SDL_GL_ResetAttributes"]
    pub fn SDL_GL_SetAttribute(attr: SDL_GLattr, value: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the actual value for an attribute from the current context.\n\n \\param attr an SDL_GLattr enum value specifying the OpenGL attribute to get\n \\param value a pointer filled in with the current value of `attr`\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GL_ResetAttributes\n \\sa SDL_GL_SetAttribute"]
    pub fn SDL_GL_GetAttribute(attr: SDL_GLattr, value: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Create an OpenGL context for an OpenGL window, and make it current.\n\n Windows users new to OpenGL should note that, for historical reasons, GL\n functions added after OpenGL version 1.1 are not available by default.\n Those functions must be loaded at run-time, either with an OpenGL\n extension-handling library or with SDL_GL_GetProcAddress() and its related\n functions.\n\n SDL_GLContext is an alias for `void *`. It's opaque to the application.\n\n \\param window the window to associate with the context\n \\returns the OpenGL context associated with `window` or NULL on error; call\n          SDL_GetError() for more details.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GL_DeleteContext\n \\sa SDL_GL_MakeCurrent"]
    pub fn SDL_GL_CreateContext(window: *mut SDL_Window) -> SDL_GLContext;
}
extern "C" {
    #[doc = " Set up an OpenGL context for rendering into an OpenGL window.\n\n The context must have been created with a compatible window.\n\n \\param window the window to associate with the context\n \\param context the OpenGL context to associate with the window\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GL_CreateContext"]
    pub fn SDL_GL_MakeCurrent(window: *mut SDL_Window, context: SDL_GLContext) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the currently active OpenGL window.\n\n \\returns the currently active OpenGL window on success or NULL on failure;\n          call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GL_GetCurrentWindow() -> *mut SDL_Window;
}
extern "C" {
    #[doc = " Get the currently active OpenGL context.\n\n \\returns the currently active OpenGL context or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GL_MakeCurrent"]
    pub fn SDL_GL_GetCurrentContext() -> SDL_GLContext;
}
extern "C" {
    #[doc = " Get the currently active EGL display.\n\n \\returns the currently active EGL display or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_EGL_GetCurrentEGLDisplay() -> SDL_EGLDisplay;
}
extern "C" {
    #[doc = " Get the currently active EGL config.\n\n \\returns the currently active EGL config or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_EGL_GetCurrentEGLConfig() -> SDL_EGLConfig;
}
extern "C" {
    #[doc = " Get the EGL surface associated with the window.\n\n \\param window the window to query\n \\returns the EGLSurface pointer associated with the window, or NULL on\n          failure.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_EGL_GetWindowEGLSurface(window: *mut SDL_Window) -> SDL_EGLSurface;
}
extern "C" {
    #[doc = " Sets the callbacks for defining custom EGLAttrib arrays for EGL\n initialization.\n\n Each callback should return a pointer to an EGL attribute array terminated\n with EGL_NONE. Callbacks may return NULL pointers to signal an error, which\n will cause the SDL_CreateWindow process to fail gracefully.\n\n The arrays returned by each callback will be appended to the existing\n attribute arrays defined by SDL.\n\n NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.\n\n \\param platformAttribCallback Callback for attributes to pass to\n                               eglGetPlatformDisplay.\n \\param surfaceAttribCallback Callback for attributes to pass to\n                              eglCreateSurface.\n \\param contextAttribCallback Callback for attributes to pass to\n                              eglCreateContext.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_EGL_SetEGLAttributeCallbacks(
        platformAttribCallback: SDL_EGLAttribArrayCallback,
        surfaceAttribCallback: SDL_EGLIntArrayCallback,
        contextAttribCallback: SDL_EGLIntArrayCallback,
    );
}
extern "C" {
    #[doc = " Set the swap interval for the current OpenGL context.\n\n Some systems allow specifying -1 for the interval, to enable adaptive\n vsync. Adaptive vsync works the same as vsync, but if you've already missed\n the vertical retrace for a given frame, it swaps buffers immediately, which\n might be less jarring for the user during occasional framerate drops. If an\n application requests adaptive vsync and the system does not support it,\n this function will fail and return -1. In such a case, you should probably\n retry the call with 1 for the interval.\n\n Adaptive vsync is implemented for some glX drivers with\n GLX_EXT_swap_control_tear, and for some Windows drivers with\n WGL_EXT_swap_control_tear.\n\n Read more on the Khronos wiki:\n https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync\n\n \\param interval 0 for immediate updates, 1 for updates synchronized with\n                 the vertical retrace, -1 for adaptive vsync\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GL_GetSwapInterval"]
    pub fn SDL_GL_SetSwapInterval(interval: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the swap interval for the current OpenGL context.\n\n If the system can't determine the swap interval, or there isn't a valid\n current context, this function will set *interval to 0 as a safe default.\n\n \\param interval Output interval value. 0 if there is no vertical retrace\n                 synchronization, 1 if the buffer swap is synchronized with\n                 the vertical retrace, and -1 if late swaps happen\n                 immediately instead of waiting for the next retrace\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GL_SetSwapInterval"]
    pub fn SDL_GL_GetSwapInterval(interval: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Update a window with OpenGL rendering.\n\n This is used with double-buffered OpenGL contexts, which are the default.\n\n On macOS, make sure you bind 0 to the draw framebuffer before swapping the\n window, otherwise nothing will happen. If you aren't using\n glBindFramebuffer(), this is the default and you won't have to do anything\n extra.\n\n \\param window the window to change\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GL_SwapWindow(window: *mut SDL_Window) -> libc::c_int;
}
extern "C" {
    #[doc = " Delete an OpenGL context.\n\n \\param context the OpenGL context to be deleted\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GL_CreateContext"]
    pub fn SDL_GL_DeleteContext(context: SDL_GLContext) -> libc::c_int;
}
#[doc = "  \\brief The SDL keysym structure, used in key events.\n\n  \\note  If you are looking for translated character input, see the ::SDL_EVENT_TEXT_INPUT event."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Keysym {
    #[doc = "< SDL physical key code - see ::SDL_Scancode for details"]
    pub scancode: SDL_Scancode,
    #[doc = "< SDL virtual key code - see ::SDL_Keycode for details"]
    pub sym: SDL_Keycode,
    #[doc = "< current key modifiers"]
    pub mod_: Uint16,
    pub unused: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_Keysym() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_Keysym> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_Keysym>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_Keysym))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Keysym>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_Keysym))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scancode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Keysym),
            "::",
            stringify!(scancode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sym) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Keysym),
            "::",
            stringify!(sym)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mod_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Keysym),
            "::",
            stringify!(mod_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Keysym),
            "::",
            stringify!(unused)
        )
    );
}
extern "C" {
    #[doc = " Query the window which currently has keyboard focus.\n\n \\returns the window with keyboard focus.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetKeyboardFocus() -> *mut SDL_Window;
}
extern "C" {
    #[doc = " Get a snapshot of the current state of the keyboard.\n\n The pointer returned is a pointer to an internal SDL array. It will be\n valid for the whole lifetime of the application and should not be freed by\n the caller.\n\n A array element with a value of 1 means that the key is pressed and a value\n of 0 means that it is not. Indexes into this array are obtained by using\n SDL_Scancode values.\n\n Use SDL_PumpEvents() to update the state array.\n\n This function gives you the current state after all events have been\n processed, so if a key or button has been pressed and released before you\n process events, then the pressed state will never show up in the\n SDL_GetKeyboardState() calls.\n\n Note: This function doesn't take into account whether shift has been\n pressed or not.\n\n \\param numkeys if non-NULL, receives the length of the returned array\n \\returns a pointer to an array of key states.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_PumpEvents\n \\sa SDL_ResetKeyboard"]
    pub fn SDL_GetKeyboardState(numkeys: *mut libc::c_int) -> *const Uint8;
}
extern "C" {
    #[doc = " Clear the state of the keyboard\n\n This function will generate key up events for all pressed keys.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetKeyboardState"]
    pub fn SDL_ResetKeyboard();
}
extern "C" {
    #[doc = " Get the current key modifier state for the keyboard.\n\n \\returns an OR'd combination of the modifier keys for the keyboard. See\n          SDL_Keymod for details.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetKeyboardState\n \\sa SDL_SetModState"]
    pub fn SDL_GetModState() -> SDL_Keymod;
}
extern "C" {
    #[doc = " Set the current key modifier state for the keyboard.\n\n The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose\n modifier key states on your application. Simply pass your desired modifier\n states into `modstate`. This value may be a bitwise, OR'd combination of\n SDL_Keymod values.\n\n This does not change the keyboard state, only the key modifier flags that\n SDL reports.\n\n \\param modstate the desired SDL_Keymod for the keyboard\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetModState"]
    pub fn SDL_SetModState(modstate: SDL_Keymod);
}
extern "C" {
    #[doc = " Get the key code corresponding to the given scancode according to the\n current keyboard layout.\n\n See SDL_Keycode for details.\n\n \\param scancode the desired SDL_Scancode to query\n \\returns the SDL_Keycode that corresponds to the given SDL_Scancode.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetKeyName\n \\sa SDL_GetScancodeFromKey"]
    pub fn SDL_GetKeyFromScancode(scancode: SDL_Scancode) -> SDL_Keycode;
}
extern "C" {
    #[doc = " Get the scancode corresponding to the given key code according to the\n current keyboard layout.\n\n See SDL_Scancode for details.\n\n \\param key the desired SDL_Keycode to query\n \\returns the SDL_Scancode that corresponds to the given SDL_Keycode.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetKeyFromScancode\n \\sa SDL_GetScancodeName"]
    pub fn SDL_GetScancodeFromKey(key: SDL_Keycode) -> SDL_Scancode;
}
extern "C" {
    #[doc = " Get a human-readable name for a scancode.\n\n See SDL_Scancode for details.\n\n **Warning**: The returned name is by design not stable across platforms,\n e.g. the name for `SDL_SCANCODE_LGUI` is \"Left GUI\" under Linux but \"Left\n Windows\" under Microsoft Windows, and some scancodes like\n `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even\n scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and\n `SDL_SCANCODE_RETURN2` (both called \"Return\"). This function is therefore\n unsuitable for creating a stable cross-platform two-way mapping between\n strings and scancodes.\n\n \\param scancode the desired SDL_Scancode to query\n \\returns a pointer to the name for the scancode. If the scancode doesn't\n          have a name this function returns an empty string (\"\").\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetScancodeFromKey\n \\sa SDL_GetScancodeFromName"]
    pub fn SDL_GetScancodeName(scancode: SDL_Scancode) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get a scancode from a human-readable name.\n\n \\param name the human-readable scancode name\n \\returns the SDL_Scancode, or `SDL_SCANCODE_UNKNOWN` if the name wasn't\n          recognized; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetKeyFromName\n \\sa SDL_GetScancodeFromKey\n \\sa SDL_GetScancodeName"]
    pub fn SDL_GetScancodeFromName(name: *const libc::c_char) -> SDL_Scancode;
}
extern "C" {
    #[doc = " Get a human-readable name for a key.\n\n See SDL_Scancode and SDL_Keycode for details.\n\n \\param key the desired SDL_Keycode to query\n \\returns a pointer to a UTF-8 string that stays valid at least until the\n          next call to this function. If you need it around any longer, you\n          must copy it. If the key doesn't have a name, this function\n          returns an empty string (\"\").\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetKeyFromName\n \\sa SDL_GetKeyFromScancode\n \\sa SDL_GetScancodeFromKey"]
    pub fn SDL_GetKeyName(key: SDL_Keycode) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get a key code from a human-readable name.\n\n \\param name the human-readable key name\n \\returns key code, or `SDLK_UNKNOWN` if the name wasn't recognized; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetKeyFromScancode\n \\sa SDL_GetKeyName\n \\sa SDL_GetScancodeFromName"]
    pub fn SDL_GetKeyFromName(name: *const libc::c_char) -> SDL_Keycode;
}
extern "C" {
    #[doc = " Start accepting Unicode text input events.\n\n This function will start accepting Unicode text input events in the focused\n SDL window, and start emitting SDL_TextInputEvent (SDL_EVENT_TEXT_INPUT)\n and SDL_TextEditingEvent (SDL_EVENT_TEXT_EDITING) events. Please use this\n function in pair with SDL_StopTextInput().\n\n On some platforms using this function activates the screen keyboard.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetTextInputRect\n \\sa SDL_StopTextInput"]
    pub fn SDL_StartTextInput();
}
extern "C" {
    #[doc = " Check whether or not Unicode text input events are enabled.\n\n \\returns SDL_TRUE if text input events are enabled else SDL_FALSE.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_StartTextInput"]
    pub fn SDL_TextInputActive() -> SDL_bool;
}
extern "C" {
    #[doc = " Stop receiving any text input events.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_StartTextInput"]
    pub fn SDL_StopTextInput();
}
extern "C" {
    #[doc = " Dismiss the composition window/IME without disabling the subsystem.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_StartTextInput\n \\sa SDL_StopTextInput"]
    pub fn SDL_ClearComposition();
}
extern "C" {
    #[doc = " Returns if an IME Composite or Candidate window is currently shown.\n\n \\returns SDL_TRUE if shown, else SDL_FALSE\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_TextInputShown() -> SDL_bool;
}
extern "C" {
    #[doc = " Set the rectangle used to type Unicode text inputs.\n\n To start text input in a given location, this function is intended to be\n called before SDL_StartTextInput, although some platforms support moving\n the rectangle even while text input (and a composition) is active.\n\n Note: If you want to use the system native IME window, try setting hint\n **SDL_HINT_IME_SHOW_UI** to **1**, otherwise this function won't give you\n any feedback.\n\n \\param rect the SDL_Rect structure representing the rectangle to receive\n             text (ignored if NULL)\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_StartTextInput"]
    pub fn SDL_SetTextInputRect(rect: *const SDL_Rect) -> libc::c_int;
}
extern "C" {
    #[doc = " Check whether the platform has screen keyboard support.\n\n \\returns SDL_TRUE if the platform has some screen keyboard support or\n          SDL_FALSE if not.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_StartTextInput\n \\sa SDL_ScreenKeyboardShown"]
    pub fn SDL_HasScreenKeyboardSupport() -> SDL_bool;
}
extern "C" {
    #[doc = " Check whether the screen keyboard is shown for given window.\n\n \\param window the window for which screen keyboard should be queried\n \\returns SDL_TRUE if screen keyboard is shown or SDL_FALSE if not.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HasScreenKeyboardSupport"]
    pub fn SDL_ScreenKeyboardShown(window: *mut SDL_Window) -> SDL_bool;
}
pub type SDL_MouseID = Uint32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Cursor {
    _unused: [u8; 0],
}
#[repr(u32)]
#[doc = " \\brief Cursor types for SDL_CreateSystemCursor()."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_SystemCursor {
    #[doc = "< Arrow"]
    SDL_SYSTEM_CURSOR_ARROW = 0,
    #[doc = "< I-beam"]
    SDL_SYSTEM_CURSOR_IBEAM = 1,
    #[doc = "< Wait"]
    SDL_SYSTEM_CURSOR_WAIT = 2,
    #[doc = "< Crosshair"]
    SDL_SYSTEM_CURSOR_CROSSHAIR = 3,
    #[doc = "< Small wait cursor (or Wait if not available)"]
    SDL_SYSTEM_CURSOR_WAITARROW = 4,
    #[doc = "< Double arrow pointing northwest and southeast"]
    SDL_SYSTEM_CURSOR_SIZENWSE = 5,
    #[doc = "< Double arrow pointing northeast and southwest"]
    SDL_SYSTEM_CURSOR_SIZENESW = 6,
    #[doc = "< Double arrow pointing west and east"]
    SDL_SYSTEM_CURSOR_SIZEWE = 7,
    #[doc = "< Double arrow pointing north and south"]
    SDL_SYSTEM_CURSOR_SIZENS = 8,
    #[doc = "< Four pointed arrow pointing north, south, east, and west"]
    SDL_SYSTEM_CURSOR_SIZEALL = 9,
    #[doc = "< Slashed circle or crossbones"]
    SDL_SYSTEM_CURSOR_NO = 10,
    #[doc = "< Hand"]
    SDL_SYSTEM_CURSOR_HAND = 11,
    SDL_NUM_SYSTEM_CURSORS = 12,
}
#[repr(u32)]
#[doc = " \\brief Scroll direction types for the Scroll event"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_MouseWheelDirection {
    #[doc = "< The scroll direction is normal"]
    SDL_MOUSEWHEEL_NORMAL = 0,
    #[doc = "< The scroll direction is flipped / natural"]
    SDL_MOUSEWHEEL_FLIPPED = 1,
}
extern "C" {
    #[doc = " Get the window which currently has mouse focus.\n\n \\returns the window with mouse focus.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetMouseFocus() -> *mut SDL_Window;
}
extern "C" {
    #[doc = " Retrieve the current state of the mouse.\n\n The current button state is returned as a button bitmask, which can be\n tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the\n left, 2 for middle, 3 for the right button), and `x` and `y` are set to the\n mouse cursor position relative to the focus window. You can pass NULL for\n either `x` or `y`.\n\n \\param x the x coordinate of the mouse cursor position relative to the\n          focus window\n \\param y the y coordinate of the mouse cursor position relative to the\n          focus window\n \\returns a 32-bit button bitmask of the current button state.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetGlobalMouseState\n \\sa SDL_GetRelativeMouseState\n \\sa SDL_PumpEvents"]
    pub fn SDL_GetMouseState(x: *mut f32, y: *mut f32) -> Uint32;
}
extern "C" {
    #[doc = " Get the current state of the mouse in relation to the desktop.\n\n This works similarly to SDL_GetMouseState(), but the coordinates will be\n reported relative to the top-left of the desktop. This can be useful if you\n need to track the mouse outside of a specific window and SDL_CaptureMouse()\n doesn't fit your needs. For example, it could be useful if you need to\n track the mouse while dragging a window, where coordinates relative to a\n window might not be in sync at all times.\n\n Note: SDL_GetMouseState() returns the mouse position as SDL understands it\n from the last pump of the event queue. This function, however, queries the\n OS for the current mouse position, and as such, might be a slightly less\n efficient function. Unless you know what you're doing and have a good\n reason to use this function, you probably want SDL_GetMouseState() instead.\n\n \\param x filled in with the current X coord relative to the desktop; can be\n          NULL\n \\param y filled in with the current Y coord relative to the desktop; can be\n          NULL\n \\returns the current button state as a bitmask which can be tested using\n          the SDL_BUTTON(X) macros.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CaptureMouse"]
    pub fn SDL_GetGlobalMouseState(x: *mut f32, y: *mut f32) -> Uint32;
}
extern "C" {
    #[doc = " Retrieve the relative state of the mouse.\n\n The current button state is returned as a button bitmask, which can be\n tested using the `SDL_BUTTON(X)` macros (where `X` is generally 1 for the\n left, 2 for middle, 3 for the right button), and `x` and `y` are set to the\n mouse deltas since the last call to SDL_GetRelativeMouseState() or since\n event initialization. You can pass NULL for either `x` or `y`.\n\n \\param x a pointer filled with the last recorded x coordinate of the mouse\n \\param y a pointer filled with the last recorded y coordinate of the mouse\n \\returns a 32-bit button bitmask of the relative button state.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetMouseState"]
    pub fn SDL_GetRelativeMouseState(x: *mut f32, y: *mut f32) -> Uint32;
}
extern "C" {
    #[doc = " Move the mouse cursor to the given position within the window.\n\n This function generates a mouse motion event if relative mode is not\n enabled. If relative mode is enabled, you can force mouse events for the\n warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.\n\n Note that this function will appear to succeed, but not actually move the\n mouse when used over Microsoft Remote Desktop.\n\n \\param window the window to move the mouse into, or NULL for the current\n               mouse focus\n \\param x the x coordinate within the window\n \\param y the y coordinate within the window\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_WarpMouseGlobal"]
    pub fn SDL_WarpMouseInWindow(window: *mut SDL_Window, x: f32, y: f32);
}
extern "C" {
    #[doc = " Move the mouse to the given position in global screen space.\n\n This function generates a mouse motion event.\n\n A failure of this function usually means that it is unsupported by a\n platform.\n\n Note that this function will appear to succeed, but not actually move the\n mouse when used over Microsoft Remote Desktop.\n\n \\param x the x coordinate\n \\param y the y coordinate\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_WarpMouseInWindow"]
    pub fn SDL_WarpMouseGlobal(x: f32, y: f32) -> libc::c_int;
}
extern "C" {
    #[doc = " Set relative mouse mode.\n\n While the mouse is in relative mode, the cursor is hidden, the mouse\n position is constrained to the window, and SDL will report continuous\n relative mouse motion even if the mouse is at the edge of the window.\n\n This function will flush any pending mouse motion.\n\n \\param enabled SDL_TRUE to enable relative mode, SDL_FALSE to disable.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetRelativeMouseMode"]
    pub fn SDL_SetRelativeMouseMode(enabled: SDL_bool) -> libc::c_int;
}
extern "C" {
    #[doc = " Capture the mouse and to track input outside an SDL window.\n\n Capturing enables your app to obtain mouse events globally, instead of just\n within your window. Not all video targets support this function. When\n capturing is enabled, the current window will get all mouse events, but\n unlike relative mode, no change is made to the cursor and it is not\n restrained to your window.\n\n This function may also deny mouse input to other windows--both those in\n your application and others on the system--so you should use this function\n sparingly, and in small bursts. For example, you might want to track the\n mouse while the user is dragging something, until the user releases a mouse\n button. It is not recommended that you capture the mouse for long periods\n of time, such as the entire time your app is running. For that, you should\n probably use SDL_SetRelativeMouseMode() or SDL_SetWindowGrab(), depending\n on your goals.\n\n While captured, mouse events still report coordinates relative to the\n current (foreground) window, but those coordinates may be outside the\n bounds of the window (including negative values). Capturing is only allowed\n for the foreground window. If the window loses focus while capturing, the\n capture will be disabled automatically.\n\n While capturing is enabled, the current window will have the\n `SDL_WINDOW_MOUSE_CAPTURE` flag set.\n\n Please note that as of SDL 2.0.22, SDL will attempt to \"auto capture\" the\n mouse while the user is pressing a button; this is to try and make mouse\n behavior more consistent between platforms, and deal with the common case\n of a user dragging the mouse outside of the window. This means that if you\n are calling SDL_CaptureMouse() only to deal with this situation, you no\n longer have to (although it is safe to do so). If this causes problems for\n your app, you can disable auto capture by setting the\n `SDL_HINT_MOUSE_AUTO_CAPTURE` hint to zero.\n\n \\param enabled SDL_TRUE to enable capturing, SDL_FALSE to disable.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetGlobalMouseState"]
    pub fn SDL_CaptureMouse(enabled: SDL_bool) -> libc::c_int;
}
extern "C" {
    #[doc = " Query whether relative mouse mode is enabled.\n\n \\returns SDL_TRUE if relative mode is enabled or SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetRelativeMouseMode"]
    pub fn SDL_GetRelativeMouseMode() -> SDL_bool;
}
extern "C" {
    #[doc = " Create a cursor using the specified bitmap data and mask (in MSB format).\n\n `mask` has to be in MSB (Most Significant Bit) format.\n\n The cursor width (`w`) must be a multiple of 8 bits.\n\n The cursor is created in black and white according to the following:\n\n - data=0, mask=1: white\n - data=1, mask=1: black\n - data=0, mask=0: transparent\n - data=1, mask=0: inverted color if possible, black if not.\n\n Cursors created with this function must be freed with SDL_DestroyCursor().\n\n If you want to have a color cursor, or create your cursor from an\n SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can\n hide the cursor and draw your own as part of your game's rendering, but it\n will be bound to the framerate.\n\n Also, since SDL 2.0.0, SDL_CreateSystemCursor() is available, which\n provides twelve readily available system cursors to pick from.\n\n \\param data the color value for each pixel of the cursor\n \\param mask the mask value for each pixel of the cursor\n \\param w the width of the cursor\n \\param h the height of the cursor\n \\param hot_x the X-axis location of the upper left corner of the cursor\n              relative to the actual mouse position\n \\param hot_y the Y-axis location of the upper left corner of the cursor\n              relative to the actual mouse position\n \\returns a new cursor with the specified parameters on success or NULL on\n          failure; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_DestroyCursor\n \\sa SDL_SetCursor"]
    pub fn SDL_CreateCursor(
        data: *const Uint8,
        mask: *const Uint8,
        w: libc::c_int,
        h: libc::c_int,
        hot_x: libc::c_int,
        hot_y: libc::c_int,
    ) -> *mut SDL_Cursor;
}
extern "C" {
    #[doc = " Create a color cursor.\n\n \\param surface an SDL_Surface structure representing the cursor image\n \\param hot_x the x position of the cursor hot spot\n \\param hot_y the y position of the cursor hot spot\n \\returns the new cursor on success or NULL on failure; call SDL_GetError()\n          for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateCursor\n \\sa SDL_DestroyCursor"]
    pub fn SDL_CreateColorCursor(
        surface: *mut SDL_Surface,
        hot_x: libc::c_int,
        hot_y: libc::c_int,
    ) -> *mut SDL_Cursor;
}
extern "C" {
    #[doc = " Create a system cursor.\n\n \\param id an SDL_SystemCursor enum value\n \\returns a cursor on success or NULL on failure; call SDL_GetError() for\n          more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_DestroyCursor"]
    pub fn SDL_CreateSystemCursor(id: SDL_SystemCursor) -> *mut SDL_Cursor;
}
extern "C" {
    #[doc = " Set the active cursor.\n\n This function sets the currently active cursor to the specified one. If the\n cursor is currently visible, the change will be immediately represented on\n the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if\n this is desired for any reason.\n\n \\param cursor a cursor to make active\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateCursor\n \\sa SDL_GetCursor"]
    pub fn SDL_SetCursor(cursor: *mut SDL_Cursor) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the active cursor.\n\n This function returns a pointer to the current cursor which is owned by the\n library. It is not necessary to free the cursor with SDL_DestroyCursor().\n\n \\returns the active cursor or NULL if there is no mouse.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetCursor"]
    pub fn SDL_GetCursor() -> *mut SDL_Cursor;
}
extern "C" {
    #[doc = " Get the default cursor.\n\n You do not have to call SDL_DestroyCursor() on the return value, but it is\n safe to do so.\n\n \\returns the default cursor on success or NULL on failure.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateSystemCursor"]
    pub fn SDL_GetDefaultCursor() -> *mut SDL_Cursor;
}
extern "C" {
    #[doc = " Free a previously-created cursor.\n\n Use this function to free cursor resources created with SDL_CreateCursor(),\n SDL_CreateColorCursor() or SDL_CreateSystemCursor().\n\n \\param cursor the cursor to free\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateColorCursor\n \\sa SDL_CreateCursor\n \\sa SDL_CreateSystemCursor"]
    pub fn SDL_DestroyCursor(cursor: *mut SDL_Cursor);
}
extern "C" {
    #[doc = " Show the cursor.\n\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CursorVisible\n \\sa SDL_HideCursor"]
    pub fn SDL_ShowCursor() -> libc::c_int;
}
extern "C" {
    #[doc = " Hide the cursor.\n\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CursorVisible\n \\sa SDL_ShowCursor"]
    pub fn SDL_HideCursor() -> libc::c_int;
}
extern "C" {
    #[doc = " Return whether the cursor is currently being shown.\n\n \\returns `SDL_TRUE` if the cursor is being shown, or `SDL_FALSE` if the\n          cursor is hidden.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HideCursor\n \\sa SDL_ShowCursor"]
    pub fn SDL_CursorVisible() -> SDL_bool;
}
pub type SDL_PenID = Uint32;
impl SDL_PenAxis {
    pub const SDL_PEN_AXIS_LAST: SDL_PenAxis = SDL_PenAxis::SDL_PEN_AXIS_SLIDER;
}
#[repr(u32)]
#[doc = " Pen axis indices\n\n Below are the valid indices to the \"axis\" array from ::SDL_PenMotionEvent and ::SDL_PenButtonEvent.\n The axis indices form a contiguous range of ints from 0 to ::SDL_PEN_AXIS_LAST, inclusive.\n All \"axis[]\" entries are normalised to either 0..1 (unidirectional axes) or between -1..1 (bidirectional axes).\n Unsupported entries are always \"0.0f\".\n"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_PenAxis {
    #[doc = "< Pen pressure.  Unidirectional: 0..1.0"]
    SDL_PEN_AXIS_PRESSURE = 0,
    #[doc = "< Pen horizontal tilt fraction.  Bidirectional: -1.0..1.0 (left-to-right).  This is NOT the angle, but the tilt vector x component.  The physical max/min tilt may be smaller than -1.0 / 1.0, cf. \\link SDL_PenCapabilityInfo \\endlink ."]
    SDL_PEN_AXIS_XTILT = 1,
    #[doc = "< Pen vertical tilt fraction.  Bidirectional: -1.0..1.0 (top-to-bottom).  This is NOT the angle, but the tilt vector y component."]
    SDL_PEN_AXIS_YTILT = 2,
    #[doc = "< Pen distance to drawing surface.  Unidirectional: 0.0..1.0"]
    SDL_PEN_AXIS_DISTANCE = 3,
    #[doc = "< Pen barrel rotation.  Bidirectional: -1.0..1.0 (clockwise, 0 is facing up).  Multiply with \"2.0 * M_PI\" to get radians, or \"360.0\" for degrees."]
    SDL_PEN_AXIS_ROTATION = 4,
    #[doc = "< Pen finger wheel or slider (e.g., Airbrush Pen).  Unidirectional: 0..1.0"]
    SDL_PEN_AXIS_SLIDER = 5,
    #[doc = "< Last valid axis index"]
    SDL_PEN_NUM_AXES = 6,
}
impl SDL_PenSubtype {
    pub const SDL_PEN_TYPE_LAST: SDL_PenSubtype = SDL_PenSubtype::SDL_PEN_TYPE_AIRBRUSH;
}
#[repr(u32)]
#[doc = " Pen types\n\n Some pens identify as a particular type of drawing device (e.g., an airbrush or a pencil).\n Clients can use this information e.g. to select default behaviour.\n"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_PenSubtype {
    #[doc = "< Eraser"]
    SDL_PEN_TYPE_ERASER = 1,
    #[doc = "< Generic pen; this is the default."]
    SDL_PEN_TYPE_PEN = 2,
    #[doc = "< Pencil"]
    SDL_PEN_TYPE_PENCIL = 3,
    #[doc = "< Brush-like device"]
    SDL_PEN_TYPE_BRUSH = 4,
    #[doc = "< Airbrush device that \"sprays\" ink"]
    SDL_PEN_TYPE_AIRBRUSH = 5,
}
extern "C" {
    #[doc = " Retrieves all pens that are connected to the system.\n\n Yields an array of ::SDL_PenID values.  These identify and track pens throughout a session.\n To track pens across sessions (program restart), use ::SDL_GUID .\n\n \\param[out] count The number of pens in the array (number of array elements minus 1, i.e., not\n     counting the terminator 0).\n\n \\returns A 0 terminated array of ::SDL_PenID values, or NULL on error.\n     The array must be freed with ::SDL_free().\n     On a NULL return, ::SDL_GetError() is set.\n\n \\since This function is available since SDL 3.TBD"]
    pub fn SDL_GetPens(count: *mut libc::c_int) -> *mut SDL_PenID;
}
extern "C" {
    #[doc = " Retrieves the pen's current status.\n\n If the pen is detached (cf. ::SDL_PenConnected), this operation may return\n default values.\n\n \\param instance_id The pen to query.\n \\param[out] x Out-mode parameter for pen x coordinate.  May be NULL.\n \\param[out] y Out-mode parameter for pen y coordinate.  May be NULL.\n \\param[out] axes Out-mode parameter for axis information.  May be null.  The axes are in the same order as for\n     ::SDL_PenAxis .\n \\param num_axes Maximum number of axes to write to \"axes\".\n\n \\returns a bit mask with the current pen button states (::SDL_BUTTON_LMASK etc.) and exactly one of\n     ::SDL_PEN_INK_MASK or ::SDL_PEN_ERASER_MASK , or 0 on error (see ::SDL_GetError()).\n\n \\since This function is available since SDL 3.TBD"]
    pub fn SDL_GetPenStatus(
        instance_id: SDL_PenID,
        x: *mut f32,
        y: *mut f32,
        axes: *mut f32,
        num_axes: usize,
    ) -> Uint32;
}
extern "C" {
    #[doc = " Retrieves an ::SDL_PenID for the given ::SDL_GUID.\n\n \\param guid A pen GUID.\n\n \\returns A valid ::SDL_PenID, or ::SDL_PEN_INVALID if there is no matching SDL_PenID.\n\n \\since This function is available since SDL 3.TBD\n\n \\sa SDL_GUID()"]
    pub fn SDL_GetPenFromGUID(guid: SDL_GUID) -> SDL_PenID;
}
extern "C" {
    #[doc = " Retrieves the ::SDL_GUID for a given ::SDL_PenID.\n\n \\param instance_id The pen to query.\n\n \\returns The corresponding pen GUID; persistent across multiple sessions.\n     If \"instance_id\" is ::SDL_PEN_INVALID, returns an all-zeroes GUID.\n\n \\since This function is available since SDL 3.TBD\n\n \\sa SDL_PenForID()"]
    pub fn SDL_GetPenGUID(instance_id: SDL_PenID) -> SDL_GUID;
}
extern "C" {
    #[doc = " Checks whether a pen is still attached.\n\n If a pen is detached, it will not show up for ::SDL_GetPens().\n Other operations will still be available but may return default values.\n\n \\param instance_id A pen ID.\n \\returns SDL_TRUE if \"instance_id\" is valid and the corresponding pen is attached, or\n     SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.TBD"]
    pub fn SDL_PenConnected(instance_id: SDL_PenID) -> SDL_bool;
}
extern "C" {
    #[doc = " Retrieves a human-readable description for a ::SDL_PenID.\n\n \\param instance_id The pen to query.\n\n \\returns A string that contains the name of the pen, intended for human consumption.\n     The string might or might not be localised, depending on platform settings.\n     It is not guaranteed to be unique; use ::SDL_GetPenGUID() for (best-effort)\n     unique identifiers.\n     The pointer is managed by the SDL pen subsystem and must not be deallocated.\n     The pointer remains valid until SDL is shut down.\n     Returns NULL on error (cf. ::SDL_GetError())\n\n \\since This function is available since SDL 3.TBD"]
    pub fn SDL_GetPenName(instance_id: SDL_PenID) -> *const libc::c_char;
}
#[doc = " Pen capabilities, as reported by ::SDL_GetPenCapabilities()"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_PenCapabilityInfo {
    #[doc = "< Physical maximum tilt values, or SDL_PEN_INFO_UNKNOWN .  Pens can't typically tilt all the way to 90 degrees, so this value is usually less than 1.0."]
    pub max_tilt: f32,
    #[doc = "< For Wacom devices: wacom tool type ID, otherwise 0 (useful e.g. with libwacom)"]
    pub wacom_id: Uint32,
    #[doc = "< Number of pen buttons (not counting the pen tip), or SDL_PEN_INFO_UNKNOWN"]
    pub num_buttons: Sint8,
}
#[test]
fn bindgen_test_layout_SDL_PenCapabilityInfo() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_PenCapabilityInfo> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_PenCapabilityInfo>(),
        12usize,
        concat!("Size of: ", stringify!(SDL_PenCapabilityInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_PenCapabilityInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_PenCapabilityInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_tilt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PenCapabilityInfo),
            "::",
            stringify!(max_tilt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wacom_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PenCapabilityInfo),
            "::",
            stringify!(wacom_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_buttons) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PenCapabilityInfo),
            "::",
            stringify!(num_buttons)
        )
    );
}
extern "C" {
    #[doc = " Retrieves capability flags for a given ::SDL_PenID.\n\n \\param instance_id The pen to query.\n \\param[out] capabilities Detail information about pen capabilities, such as the number of buttons\n\n \\returns a set of capability flags, cf. \\link SDL_PEN_CAPABILITIES \\endlink.  Returns 0 on error\n     (cf. ::SDL_GetError())\n\n \\since This function is available since SDL 3.TBD"]
    pub fn SDL_GetPenCapabilities(
        instance_id: SDL_PenID,
        capabilities: *mut SDL_PenCapabilityInfo,
    ) -> Uint32;
}
extern "C" {
    #[doc = " Retrieves the pen type for a given ::SDL_PenID.\n\n \\param instance_id The pen to query.\n \\returns The corresponding pen type (cf. ::SDL_PenSubtype) or 0 on error.\n \\since This function is available since SDL 3.TBD"]
    pub fn SDL_GetPenType(instance_id: SDL_PenID) -> SDL_PenSubtype;
}
pub type SDL_TouchID = Sint64;
pub type SDL_FingerID = Sint64;
#[repr(i32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_TouchDeviceType {
    SDL_TOUCH_DEVICE_INVALID = -1,
    SDL_TOUCH_DEVICE_DIRECT = 0,
    SDL_TOUCH_DEVICE_INDIRECT_ABSOLUTE = 1,
    SDL_TOUCH_DEVICE_INDIRECT_RELATIVE = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Finger {
    pub id: SDL_FingerID,
    pub x: f32,
    pub y: f32,
    pub pressure: f32,
}
#[test]
fn bindgen_test_layout_SDL_Finger() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_Finger> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_Finger>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_Finger))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Finger>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_Finger))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Finger),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Finger),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Finger),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pressure) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Finger),
            "::",
            stringify!(pressure)
        )
    );
}
extern "C" {
    #[doc = " Get the number of registered touch devices.\n\n On some platforms SDL first sees the touch device if it was actually used.\n Therefore SDL_GetNumTouchDevices() may return 0 although devices are\n available. After using all devices at least once the number will be\n correct.\n\n This was fixed for Android in SDL 2.0.1.\n\n \\returns the number of registered touch devices.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetTouchDevice"]
    pub fn SDL_GetNumTouchDevices() -> libc::c_int;
}
extern "C" {
    #[doc = " Get the touch ID with the given index.\n\n \\param index the touch device index\n \\returns the touch ID with the given index on success or 0 if the index is\n          invalid; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetNumTouchDevices"]
    pub fn SDL_GetTouchDevice(index: libc::c_int) -> SDL_TouchID;
}
extern "C" {
    #[doc = " Get the touch device name as reported from the driver or NULL if the index\n is invalid.\n\n \\param index the touch device index\n \\returns touch device name\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetTouchName(index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the type of the given touch device.\n\n \\param touchID the ID of a touch device\n \\returns touch device type\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetTouchDeviceType(touchID: SDL_TouchID) -> SDL_TouchDeviceType;
}
extern "C" {
    #[doc = " Get the number of active fingers for a given touch device.\n\n \\param touchID the ID of a touch device\n \\returns the number of active fingers for a given touch device on success\n          or a negative error code on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetTouchFinger"]
    pub fn SDL_GetNumTouchFingers(touchID: SDL_TouchID) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the finger object for specified touch device ID and finger index.\n\n The returned resource is owned by SDL and should not be deallocated.\n\n \\param touchID the ID of the requested touch device\n \\param index the index of the requested finger\n \\returns a pointer to the SDL_Finger object or NULL if no object at the\n          given ID and index could be found.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetTouchFinger(touchID: SDL_TouchID, index: libc::c_int) -> *mut SDL_Finger;
}
impl SDL_EventType {
    pub const SDL_EVENT_DISPLAY_FIRST: SDL_EventType = SDL_EventType::SDL_EVENT_DISPLAY_ORIENTATION;
}
impl SDL_EventType {
    pub const SDL_EVENT_DISPLAY_LAST: SDL_EventType =
        SDL_EventType::SDL_EVENT_DISPLAY_CONTENT_SCALE_CHANGED;
}
impl SDL_EventType {
    pub const SDL_EVENT_WINDOW_FIRST: SDL_EventType = SDL_EventType::SDL_EVENT_WINDOW_SHOWN;
}
impl SDL_EventType {
    pub const SDL_EVENT_WINDOW_LAST: SDL_EventType = SDL_EventType::SDL_EVENT_WINDOW_PEN_LEAVE;
}
#[repr(u32)]
#[doc = " The types of events that can be delivered."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_EventType {
    #[doc = "< Unused (do not remove)"]
    SDL_EVENT_FIRST = 0,
    #[doc = "< User-requested quit"]
    SDL_EVENT_QUIT = 256,
    #[doc = "< The application is being terminated by the OS\nCalled on iOS in applicationWillTerminate()\nCalled on Android in onDestroy()"]
    SDL_EVENT_TERMINATING = 257,
    #[doc = "< The application is low on memory, free memory if possible.\nCalled on iOS in applicationDidReceiveMemoryWarning()\nCalled on Android in onLowMemory()"]
    SDL_EVENT_LOW_MEMORY = 258,
    #[doc = "< The application is about to enter the background\nCalled on iOS in applicationWillResignActive()\nCalled on Android in onPause()"]
    SDL_EVENT_WILL_ENTER_BACKGROUND = 259,
    #[doc = "< The application did enter the background and may not get CPU for some time\nCalled on iOS in applicationDidEnterBackground()\nCalled on Android in onPause()"]
    SDL_EVENT_DID_ENTER_BACKGROUND = 260,
    #[doc = "< The application is about to enter the foreground\nCalled on iOS in applicationWillEnterForeground()\nCalled on Android in onResume()"]
    SDL_EVENT_WILL_ENTER_FOREGROUND = 261,
    #[doc = "< The application is now interactive\nCalled on iOS in applicationDidBecomeActive()\nCalled on Android in onResume()"]
    SDL_EVENT_DID_ENTER_FOREGROUND = 262,
    #[doc = "< The user's locale preferences have changed."]
    SDL_EVENT_LOCALE_CHANGED = 263,
    #[doc = "< The system theme changed"]
    SDL_EVENT_SYSTEM_THEME_CHANGED = 264,
    #[doc = "< Display orientation has changed to data1"]
    SDL_EVENT_DISPLAY_ORIENTATION = 337,
    #[doc = "< Display has been added to the system"]
    SDL_EVENT_DISPLAY_CONNECTED = 338,
    #[doc = "< Display has been removed from the system"]
    SDL_EVENT_DISPLAY_DISCONNECTED = 339,
    #[doc = "< Display has changed position"]
    SDL_EVENT_DISPLAY_MOVED = 340,
    #[doc = "< Display has changed content scale"]
    SDL_EVENT_DISPLAY_CONTENT_SCALE_CHANGED = 341,
    #[doc = "< System specific event"]
    SDL_EVENT_SYSWM = 513,
    #[doc = "< Window has been shown"]
    SDL_EVENT_WINDOW_SHOWN = 514,
    #[doc = "< Window has been hidden"]
    SDL_EVENT_WINDOW_HIDDEN = 515,
    #[doc = "< Window has been exposed and should be redrawn"]
    SDL_EVENT_WINDOW_EXPOSED = 516,
    #[doc = "< Window has been moved to data1, data2"]
    SDL_EVENT_WINDOW_MOVED = 517,
    #[doc = "< Window has been resized to data1xdata2"]
    SDL_EVENT_WINDOW_RESIZED = 518,
    #[doc = "< The pixel size of the window has changed to data1xdata2"]
    SDL_EVENT_WINDOW_PIXEL_SIZE_CHANGED = 519,
    #[doc = "< Window has been minimized"]
    SDL_EVENT_WINDOW_MINIMIZED = 520,
    #[doc = "< Window has been maximized"]
    SDL_EVENT_WINDOW_MAXIMIZED = 521,
    #[doc = "< Window has been restored to normal size and position"]
    SDL_EVENT_WINDOW_RESTORED = 522,
    #[doc = "< Window has gained mouse focus"]
    SDL_EVENT_WINDOW_MOUSE_ENTER = 523,
    #[doc = "< Window has lost mouse focus"]
    SDL_EVENT_WINDOW_MOUSE_LEAVE = 524,
    #[doc = "< Window has gained keyboard focus"]
    SDL_EVENT_WINDOW_FOCUS_GAINED = 525,
    #[doc = "< Window has lost keyboard focus"]
    SDL_EVENT_WINDOW_FOCUS_LOST = 526,
    #[doc = "< The window manager requests that the window be closed"]
    SDL_EVENT_WINDOW_CLOSE_REQUESTED = 527,
    #[doc = "< Window is being offered a focus (should SetWindowInputFocus() on itself or a subwindow, or ignore)"]
    SDL_EVENT_WINDOW_TAKE_FOCUS = 528,
    #[doc = "< Window had a hit test that wasn't SDL_HITTEST_NORMAL"]
    SDL_EVENT_WINDOW_HIT_TEST = 529,
    #[doc = "< The ICC profile of the window's display has changed"]
    SDL_EVENT_WINDOW_ICCPROF_CHANGED = 530,
    #[doc = "< Window has been moved to display data1"]
    SDL_EVENT_WINDOW_DISPLAY_CHANGED = 531,
    #[doc = "< Window display scale has been changed"]
    SDL_EVENT_WINDOW_DISPLAY_SCALE_CHANGED = 532,
    #[doc = "< The window has been occluded"]
    SDL_EVENT_WINDOW_OCCLUDED = 533,
    #[doc = "< The window with the associated ID is being or has been destroyed. If this message is being handled\nin an event watcher, the window handle is still valid and can still be used to retrieve any userdata\nassociated with the window. Otherwise, the handle has already been destroyed and all resources\nassociated with it are invalid"]
    SDL_EVENT_WINDOW_DESTROYED = 534,
    #[doc = "< Window has gained focus of the pressure-sensitive pen with ID \"data1\""]
    SDL_EVENT_WINDOW_PEN_ENTER = 535,
    #[doc = "< Window has lost focus of the pressure-sensitive pen with ID \"data1\""]
    SDL_EVENT_WINDOW_PEN_LEAVE = 536,
    #[doc = "< Key pressed"]
    SDL_EVENT_KEY_DOWN = 768,
    #[doc = "< Key released"]
    SDL_EVENT_KEY_UP = 769,
    #[doc = "< Keyboard text editing (composition)"]
    SDL_EVENT_TEXT_EDITING = 770,
    #[doc = "< Keyboard text input"]
    SDL_EVENT_TEXT_INPUT = 771,
    #[doc = "< Keymap changed due to a system event such as an\ninput language or keyboard layout change."]
    SDL_EVENT_KEYMAP_CHANGED = 772,
    #[doc = "< Extended keyboard text editing (composition)"]
    SDL_EVENT_TEXT_EDITING_EXT = 773,
    #[doc = "< Mouse moved"]
    SDL_EVENT_MOUSE_MOTION = 1024,
    #[doc = "< Mouse button pressed"]
    SDL_EVENT_MOUSE_BUTTON_DOWN = 1025,
    #[doc = "< Mouse button released"]
    SDL_EVENT_MOUSE_BUTTON_UP = 1026,
    #[doc = "< Mouse wheel motion"]
    SDL_EVENT_MOUSE_WHEEL = 1027,
    #[doc = "< Joystick axis motion"]
    SDL_EVENT_JOYSTICK_AXIS_MOTION = 1536,
    #[doc = "< Joystick hat position change"]
    SDL_EVENT_JOYSTICK_HAT_MOTION = 1538,
    #[doc = "< Joystick button pressed"]
    SDL_EVENT_JOYSTICK_BUTTON_DOWN = 1539,
    #[doc = "< Joystick button released"]
    SDL_EVENT_JOYSTICK_BUTTON_UP = 1540,
    #[doc = "< A new joystick has been inserted into the system"]
    SDL_EVENT_JOYSTICK_ADDED = 1541,
    #[doc = "< An opened joystick has been removed"]
    SDL_EVENT_JOYSTICK_REMOVED = 1542,
    #[doc = "< Joystick battery level change"]
    SDL_EVENT_JOYSTICK_BATTERY_UPDATED = 1543,
    #[doc = "< Joystick update is complete (disabled by default)"]
    SDL_EVENT_JOYSTICK_UPDATE_COMPLETE = 1544,
    #[doc = "< Gamepad axis motion"]
    SDL_EVENT_GAMEPAD_AXIS_MOTION = 1616,
    #[doc = "< Gamepad button pressed"]
    SDL_EVENT_GAMEPAD_BUTTON_DOWN = 1617,
    #[doc = "< Gamepad button released"]
    SDL_EVENT_GAMEPAD_BUTTON_UP = 1618,
    #[doc = "< A new gamepad has been inserted into the system"]
    SDL_EVENT_GAMEPAD_ADDED = 1619,
    #[doc = "< An opened gamepad has been removed"]
    SDL_EVENT_GAMEPAD_REMOVED = 1620,
    #[doc = "< The gamepad mapping was updated"]
    SDL_EVENT_GAMEPAD_REMAPPED = 1621,
    #[doc = "< Gamepad touchpad was touched"]
    SDL_EVENT_GAMEPAD_TOUCHPAD_DOWN = 1622,
    #[doc = "< Gamepad touchpad finger was moved"]
    SDL_EVENT_GAMEPAD_TOUCHPAD_MOTION = 1623,
    #[doc = "< Gamepad touchpad finger was lifted"]
    SDL_EVENT_GAMEPAD_TOUCHPAD_UP = 1624,
    #[doc = "< Gamepad sensor was updated"]
    SDL_EVENT_GAMEPAD_SENSOR_UPDATE = 1625,
    #[doc = "< Gamepad update is complete (disabled by default)"]
    SDL_EVENT_GAMEPAD_UPDATE_COMPLETE = 1626,
    SDL_EVENT_FINGER_DOWN = 1792,
    SDL_EVENT_FINGER_UP = 1793,
    SDL_EVENT_FINGER_MOTION = 1794,
    #[doc = "< The clipboard or primary selection changed"]
    SDL_EVENT_CLIPBOARD_UPDATE = 2304,
    #[doc = "< The system requests a file open"]
    SDL_EVENT_DROP_FILE = 4096,
    #[doc = "< text/plain drag-and-drop event"]
    SDL_EVENT_DROP_TEXT = 4097,
    #[doc = "< A new set of drops is beginning (NULL filename)"]
    SDL_EVENT_DROP_BEGIN = 4098,
    #[doc = "< Current set of drops is now complete (NULL filename)"]
    SDL_EVENT_DROP_COMPLETE = 4099,
    #[doc = "< Position while moving over the window"]
    SDL_EVENT_DROP_POSITION = 4100,
    #[doc = "< A new audio device is available"]
    SDL_EVENT_AUDIO_DEVICE_ADDED = 4352,
    #[doc = "< An audio device has been removed."]
    SDL_EVENT_AUDIO_DEVICE_REMOVED = 4353,
    #[doc = "< A sensor was updated"]
    SDL_EVENT_SENSOR_UPDATE = 4608,
    #[doc = "< Pressure-sensitive pen moved, or change in angle/pressure changed"]
    SDL_EVENT_PEN_MOTION = 4864,
    #[doc = "< Pressure-sensitive pen button pressed"]
    SDL_EVENT_PEN_BUTTON_DOWN = 4865,
    #[doc = "< Pressure-sensitive pen button released"]
    SDL_EVENT_PEN_BUTTON_UP = 4866,
    #[doc = "< The render targets have been reset and their contents need to be updated"]
    SDL_EVENT_RENDER_TARGETS_RESET = 8192,
    #[doc = "< The device has been reset and all textures need to be recreated"]
    SDL_EVENT_RENDER_DEVICE_RESET = 8193,
    #[doc = "< Signals the end of an event poll cycle"]
    SDL_EVENT_POLL_SENTINEL = 32512,
    #[doc = " Events ::SDL_EVENT_USER through ::SDL_EVENT_LAST are for your use,\n  and should be allocated with SDL_RegisterEvents()"]
    SDL_EVENT_USER = 32768,
    #[doc = "  This last event is only for bounding internal arrays"]
    SDL_EVENT_LAST = 65535,
}
#[doc = "  \\brief Fields shared by every event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_CommonEvent {
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
}
#[test]
fn bindgen_test_layout_SDL_CommonEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_CommonEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_CommonEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_CommonEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_CommonEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_CommonEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_CommonEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_CommonEvent),
            "::",
            stringify!(timestamp)
        )
    );
}
#[doc = "  \\brief Display state change event data (event.display.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_DisplayEvent {
    #[doc = "< ::SDL_DISPLAYEVENT_*"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The associated display"]
    pub displayID: SDL_DisplayID,
    #[doc = "< event dependent data"]
    pub data1: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_DisplayEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_DisplayEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_DisplayEvent>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_DisplayEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_DisplayEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_DisplayEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).displayID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(displayID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data1) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(data1)
        )
    );
}
#[doc = "  \\brief Window state change event data (event.window.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_WindowEvent {
    #[doc = "< ::SDL_WINDOWEVENT_*"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The associated window"]
    pub windowID: SDL_WindowID,
    #[doc = "< event dependent data"]
    pub data1: Sint32,
    #[doc = "< event dependent data"]
    pub data2: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_WindowEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_WindowEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_WindowEvent>(),
        32usize,
        concat!("Size of: ", stringify!(SDL_WindowEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_WindowEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_WindowEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windowID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data1) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(data1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(data2)
        )
    );
}
#[doc = "  \\brief Keyboard button event structure (event.key.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_KeyboardEvent {
    #[doc = "< ::SDL_EVENT_KEY_DOWN or ::SDL_EVENT_KEY_UP"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The window with keyboard focus, if any"]
    pub windowID: SDL_WindowID,
    #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
    pub state: Uint8,
    #[doc = "< Non-zero if this is a key repeat"]
    pub repeat: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    #[doc = "< The key that was pressed or released"]
    pub keysym: SDL_Keysym,
}
#[test]
fn bindgen_test_layout_SDL_KeyboardEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_KeyboardEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_KeyboardEvent>(),
        40usize,
        concat!("Size of: ", stringify!(SDL_KeyboardEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_KeyboardEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_KeyboardEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windowID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).repeat) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(repeat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding2) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding3) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(padding3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keysym) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(keysym)
        )
    );
}
#[doc = "  \\brief Keyboard text editing event structure (event.edit.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_TextEditingEvent {
    #[doc = "< ::SDL_EVENT_TEXT_EDITING"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The window with keyboard focus, if any"]
    pub windowID: SDL_WindowID,
    #[doc = "< The editing text"]
    pub text: [libc::c_char; 32usize],
    #[doc = "< The start cursor of selected editing text"]
    pub start: Sint32,
    #[doc = "< The length of selected editing text"]
    pub length: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_TextEditingEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_TextEditingEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_TextEditingEvent>(),
        64usize,
        concat!("Size of: ", stringify!(SDL_TextEditingEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_TextEditingEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_TextEditingEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windowID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingEvent),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingEvent),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingEvent),
            "::",
            stringify!(length)
        )
    );
}
#[doc = "  \\brief Extended keyboard text editing event structure (event.editExt.*) when text would be\n  truncated if stored in the text buffer SDL_TextEditingEvent"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_TextEditingExtEvent {
    #[doc = "< ::SDL_EVENT_TEXT_EDITING_EXT"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The window with keyboard focus, if any"]
    pub windowID: SDL_WindowID,
    #[doc = "< The editing text, which should be freed with SDL_free(), and will not be NULL"]
    pub text: *mut libc::c_char,
    #[doc = "< The start cursor of selected editing text"]
    pub start: Sint32,
    #[doc = "< The length of selected editing text"]
    pub length: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_TextEditingExtEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_TextEditingExtEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_TextEditingExtEvent>(),
        40usize,
        concat!("Size of: ", stringify!(SDL_TextEditingExtEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_TextEditingExtEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_TextEditingExtEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingExtEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingExtEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windowID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingExtEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingExtEvent),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingExtEvent),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingExtEvent),
            "::",
            stringify!(length)
        )
    );
}
#[doc = "  \\brief Keyboard text input event structure (event.text.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_TextInputEvent {
    #[doc = "< ::SDL_EVENT_TEXT_INPUT"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The window with keyboard focus, if any"]
    pub windowID: SDL_WindowID,
    #[doc = "< The input text"]
    pub text: [libc::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_SDL_TextInputEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_TextInputEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_TextInputEvent>(),
        56usize,
        concat!("Size of: ", stringify!(SDL_TextInputEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_TextInputEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_TextInputEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextInputEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextInputEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windowID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextInputEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextInputEvent),
            "::",
            stringify!(text)
        )
    );
}
#[doc = "  \\brief Mouse motion event structure (event.motion.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_MouseMotionEvent {
    #[doc = "< ::SDL_EVENT_MOUSE_MOTION"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The window with mouse focus, if any"]
    pub windowID: SDL_WindowID,
    #[doc = "< The mouse instance id, SDL_TOUCH_MOUSEID, or SDL_PEN_MOUSEID"]
    pub which: SDL_MouseID,
    #[doc = "< The current button state"]
    pub state: Uint32,
    #[doc = "< X coordinate, relative to window"]
    pub x: f32,
    #[doc = "< Y coordinate, relative to window"]
    pub y: f32,
    #[doc = "< The relative motion in the X direction"]
    pub xrel: f32,
    #[doc = "< The relative motion in the Y direction"]
    pub yrel: f32,
}
#[test]
fn bindgen_test_layout_SDL_MouseMotionEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_MouseMotionEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_MouseMotionEvent>(),
        48usize,
        concat!("Size of: ", stringify!(SDL_MouseMotionEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_MouseMotionEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_MouseMotionEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windowID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xrel) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(xrel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).yrel) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(yrel)
        )
    );
}
#[doc = "  \\brief Mouse button event structure (event.button.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_MouseButtonEvent {
    #[doc = "< ::SDL_EVENT_MOUSE_BUTTON_DOWN or ::SDL_EVENT_MOUSE_BUTTON_UP"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The window with mouse focus, if any"]
    pub windowID: SDL_WindowID,
    #[doc = "< The mouse instance id, SDL_TOUCH_MOUSEID, or SDL_PEN_MOUSEID"]
    pub which: SDL_MouseID,
    #[doc = "< The mouse button index"]
    pub button: Uint8,
    #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
    pub state: Uint8,
    #[doc = "< 1 for single-click, 2 for double-click, etc."]
    pub clicks: Uint8,
    pub padding: Uint8,
    #[doc = "< X coordinate, relative to window"]
    pub x: f32,
    #[doc = "< Y coordinate, relative to window"]
    pub y: f32,
}
#[test]
fn bindgen_test_layout_SDL_MouseButtonEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_MouseButtonEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_MouseButtonEvent>(),
        40usize,
        concat!("Size of: ", stringify!(SDL_MouseButtonEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_MouseButtonEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_MouseButtonEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windowID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).button) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clicks) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(clicks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(y)
        )
    );
}
#[doc = "  \\brief Mouse wheel event structure (event.wheel.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_MouseWheelEvent {
    #[doc = "< ::SDL_EVENT_MOUSE_WHEEL"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The window with mouse focus, if any"]
    pub windowID: SDL_WindowID,
    #[doc = "< The mouse instance id, SDL_TOUCH_MOUSEID, or SDL_PEN_MOUSEID"]
    pub which: SDL_MouseID,
    #[doc = "< The amount scrolled horizontally, positive to the right and negative to the left"]
    pub x: f32,
    #[doc = "< The amount scrolled vertically, positive away from the user and negative toward the user"]
    pub y: f32,
    #[doc = "< Set to one of the SDL_MOUSEWHEEL_* defines. When FLIPPED the values in X and Y will be opposite. Multiply by -1 to change them back"]
    pub direction: Uint32,
    #[doc = "< X coordinate, relative to window"]
    pub mouseX: f32,
    #[doc = "< Y coordinate, relative to window"]
    pub mouseY: f32,
}
#[test]
fn bindgen_test_layout_SDL_MouseWheelEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_MouseWheelEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_MouseWheelEvent>(),
        48usize,
        concat!("Size of: ", stringify!(SDL_MouseWheelEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_MouseWheelEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_MouseWheelEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windowID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mouseX) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(mouseX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mouseY) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(mouseY)
        )
    );
}
#[doc = "  \\brief Joystick axis motion event structure (event.jaxis.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_JoyAxisEvent {
    #[doc = "< ::SDL_EVENT_JOYSTICK_AXIS_MOTION"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The joystick axis index"]
    pub axis: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    #[doc = "< The axis value (range: -32768 to 32767)"]
    pub value: Sint16,
    pub padding4: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_JoyAxisEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_JoyAxisEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_JoyAxisEvent>(),
        32usize,
        concat!("Size of: ", stringify!(SDL_JoyAxisEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_JoyAxisEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_JoyAxisEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).axis) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(axis)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding1) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding2) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding3) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(padding3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding4) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(padding4)
        )
    );
}
#[doc = "  \\brief Joystick hat position change event structure (event.jhat.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_JoyHatEvent {
    #[doc = "< ::SDL_EVENT_JOYSTICK_HAT_MOTION"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The joystick hat index"]
    pub hat: Uint8,
    #[doc = "< The hat position value.\n   \\sa ::SDL_HAT_LEFTUP ::SDL_HAT_UP ::SDL_HAT_RIGHTUP\n   \\sa ::SDL_HAT_LEFT ::SDL_HAT_CENTERED ::SDL_HAT_RIGHT\n   \\sa ::SDL_HAT_LEFTDOWN ::SDL_HAT_DOWN ::SDL_HAT_RIGHTDOWN\n\n   Note that zero means the POV is centered."]
    pub value: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_JoyHatEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_JoyHatEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_JoyHatEvent>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_JoyHatEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_JoyHatEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_JoyHatEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hat) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(hat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding1) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding2) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(padding2)
        )
    );
}
#[doc = "  \\brief Joystick button event structure (event.jbutton.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_JoyButtonEvent {
    #[doc = "< ::SDL_EVENT_JOYSTICK_BUTTON_DOWN or ::SDL_EVENT_JOYSTICK_BUTTON_UP"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The joystick button index"]
    pub button: Uint8,
    #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
    pub state: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_JoyButtonEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_JoyButtonEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_JoyButtonEvent>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_JoyButtonEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_JoyButtonEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_JoyButtonEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).button) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding1) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding2) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(padding2)
        )
    );
}
#[doc = "  \\brief Joystick device event structure (event.jdevice.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_JoyDeviceEvent {
    #[doc = "< ::SDL_EVENT_JOYSTICK_ADDED or ::SDL_EVENT_JOYSTICK_REMOVED or ::SDL_EVENT_JOYSTICK_UPDATE_COMPLETE"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
}
#[test]
fn bindgen_test_layout_SDL_JoyDeviceEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_JoyDeviceEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_JoyDeviceEvent>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_JoyDeviceEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_JoyDeviceEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_JoyDeviceEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyDeviceEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyDeviceEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyDeviceEvent),
            "::",
            stringify!(which)
        )
    );
}
#[doc = "  \\brief Joysick battery level change event structure (event.jbattery.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_JoyBatteryEvent {
    #[doc = "< ::SDL_EVENT_JOYSTICK_BATTERY_UPDATED"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The joystick battery level"]
    pub level: SDL_JoystickPowerLevel,
}
#[test]
fn bindgen_test_layout_SDL_JoyBatteryEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_JoyBatteryEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_JoyBatteryEvent>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_JoyBatteryEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_JoyBatteryEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_JoyBatteryEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBatteryEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBatteryEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBatteryEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBatteryEvent),
            "::",
            stringify!(level)
        )
    );
}
#[doc = "  \\brief Gamepad axis motion event structure (event.gaxis.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_GamepadAxisEvent {
    #[doc = "< ::SDL_EVENT_GAMEPAD_AXIS_MOTION"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The gamepad axis (SDL_GamepadAxis)"]
    pub axis: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    #[doc = "< The axis value (range: -32768 to 32767)"]
    pub value: Sint16,
    pub padding4: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_GamepadAxisEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_GamepadAxisEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_GamepadAxisEvent>(),
        32usize,
        concat!("Size of: ", stringify!(SDL_GamepadAxisEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_GamepadAxisEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_GamepadAxisEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadAxisEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadAxisEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadAxisEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).axis) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadAxisEvent),
            "::",
            stringify!(axis)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding1) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadAxisEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding2) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadAxisEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding3) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadAxisEvent),
            "::",
            stringify!(padding3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadAxisEvent),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding4) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadAxisEvent),
            "::",
            stringify!(padding4)
        )
    );
}
#[doc = "  \\brief Gamepad button event structure (event.gbutton.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_GamepadButtonEvent {
    #[doc = "< ::SDL_EVENT_GAMEPAD_BUTTON_DOWN or ::SDL_EVENT_GAMEPAD_BUTTON_UP"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The gamepad button (SDL_GamepadButton)"]
    pub button: Uint8,
    #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
    pub state: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_GamepadButtonEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_GamepadButtonEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_GamepadButtonEvent>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_GamepadButtonEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_GamepadButtonEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_GamepadButtonEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadButtonEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadButtonEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadButtonEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).button) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadButtonEvent),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadButtonEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding1) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadButtonEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding2) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadButtonEvent),
            "::",
            stringify!(padding2)
        )
    );
}
#[doc = "  \\brief Gamepad device event structure (event.gdevice.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_GamepadDeviceEvent {
    #[doc = "< ::SDL_EVENT_GAMEPAD_ADDED, ::SDL_EVENT_GAMEPAD_REMOVED, or ::SDL_EVENT_GAMEPAD_REMAPPED or ::SDL_EVENT_GAMEPAD_UPDATE_COMPLETE"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
}
#[test]
fn bindgen_test_layout_SDL_GamepadDeviceEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_GamepadDeviceEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_GamepadDeviceEvent>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_GamepadDeviceEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_GamepadDeviceEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_GamepadDeviceEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadDeviceEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadDeviceEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadDeviceEvent),
            "::",
            stringify!(which)
        )
    );
}
#[doc = "  \\brief Gamepad touchpad event structure (event.gtouchpad.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_GamepadTouchpadEvent {
    #[doc = "< ::SDL_EVENT_GAMEPAD_TOUCHPAD_DOWN or ::SDL_EVENT_GAMEPAD_TOUCHPAD_MOTION or ::SDL_EVENT_GAMEPAD_TOUCHPAD_UP"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The index of the touchpad"]
    pub touchpad: Sint32,
    #[doc = "< The index of the finger on the touchpad"]
    pub finger: Sint32,
    #[doc = "< Normalized in the range 0...1 with 0 being on the left"]
    pub x: f32,
    #[doc = "< Normalized in the range 0...1 with 0 being at the top"]
    pub y: f32,
    #[doc = "< Normalized in the range 0...1"]
    pub pressure: f32,
}
#[test]
fn bindgen_test_layout_SDL_GamepadTouchpadEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_GamepadTouchpadEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_GamepadTouchpadEvent>(),
        40usize,
        concat!("Size of: ", stringify!(SDL_GamepadTouchpadEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_GamepadTouchpadEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_GamepadTouchpadEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadTouchpadEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadTouchpadEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadTouchpadEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).touchpad) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadTouchpadEvent),
            "::",
            stringify!(touchpad)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).finger) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadTouchpadEvent),
            "::",
            stringify!(finger)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadTouchpadEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadTouchpadEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pressure) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadTouchpadEvent),
            "::",
            stringify!(pressure)
        )
    );
}
#[doc = "  \\brief Gamepad sensor event structure (event.gsensor.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_GamepadSensorEvent {
    #[doc = "< ::SDL_EVENT_GAMEPAD_SENSOR_UPDATE"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The type of the sensor, one of the values of ::SDL_SensorType"]
    pub sensor: Sint32,
    #[doc = "< Up to 3 values from the sensor, as defined in SDL_sensor.h"]
    pub data: [f32; 3usize],
    #[doc = "< The timestamp of the sensor reading in nanoseconds, not necessarily synchronized with the system clock"]
    pub sensor_timestamp: Uint64,
}
#[test]
fn bindgen_test_layout_SDL_GamepadSensorEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_GamepadSensorEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_GamepadSensorEvent>(),
        48usize,
        concat!("Size of: ", stringify!(SDL_GamepadSensorEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_GamepadSensorEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_GamepadSensorEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadSensorEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadSensorEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadSensorEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sensor) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadSensorEvent),
            "::",
            stringify!(sensor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadSensorEvent),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sensor_timestamp) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GamepadSensorEvent),
            "::",
            stringify!(sensor_timestamp)
        )
    );
}
#[doc = "  \\brief Audio device event structure (event.adevice.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_AudioDeviceEvent {
    #[doc = "< ::SDL_EVENT_AUDIO_DEVICE_ADDED, or ::SDL_EVENT_AUDIO_DEVICE_REMOVED"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The audio device index for the ADDED event (valid until next SDL_GetNumAudioDevices() call), SDL_AudioDeviceID for the REMOVED event"]
    pub which: SDL_AudioDeviceID,
    #[doc = "< zero if an output device, non-zero if a capture device."]
    pub iscapture: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_AudioDeviceEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_AudioDeviceEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_AudioDeviceEvent>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_AudioDeviceEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_AudioDeviceEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_AudioDeviceEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iscapture) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(iscapture)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding1) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding2) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding3) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(padding3)
        )
    );
}
#[doc = "  \\brief Touch finger event structure (event.tfinger.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_TouchFingerEvent {
    #[doc = "< ::SDL_EVENT_FINGER_MOTION or ::SDL_EVENT_FINGER_DOWN or ::SDL_EVENT_FINGER_UP"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The touch device id"]
    pub touchId: SDL_TouchID,
    pub fingerId: SDL_FingerID,
    #[doc = "< Normalized in the range 0...1"]
    pub x: f32,
    #[doc = "< Normalized in the range 0...1"]
    pub y: f32,
    #[doc = "< Normalized in the range -1...1"]
    pub dx: f32,
    #[doc = "< Normalized in the range -1...1"]
    pub dy: f32,
    #[doc = "< Normalized in the range 0...1"]
    pub pressure: f32,
    #[doc = "< The window underneath the finger, if any"]
    pub windowID: SDL_WindowID,
}
#[test]
fn bindgen_test_layout_SDL_TouchFingerEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_TouchFingerEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_TouchFingerEvent>(),
        56usize,
        concat!("Size of: ", stringify!(SDL_TouchFingerEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_TouchFingerEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_TouchFingerEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).touchId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(touchId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fingerId) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(fingerId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dx) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dy) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(dy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pressure) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(pressure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windowID) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(windowID)
        )
    );
}
#[doc = "  \\brief Pressure-sensitive pen motion / pressure / angle event structure (event.pmotion.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_PenMotionEvent {
    #[doc = "< ::SDL_EVENT_PEN_MOTION"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The window with pen focus, if any"]
    pub windowID: Uint32,
    #[doc = "< The pen instance id"]
    pub which: SDL_PenID,
    pub padding1: Uint16,
    #[doc = "< Pen button msks (where SDL_BUTTON_LMASK is the pen tip). ::SDL_PEN_ERASER_MASK is set if the pen is (used as) an eraser."]
    pub pen_state: Uint16,
    #[doc = "< X coordinate, relative to window"]
    pub x: f32,
    #[doc = "< Y coordinate, relative to window"]
    pub y: f32,
    #[doc = "< Pen axes such as pressure and tilt (ordered as per ::SDL_PenAxis)"]
    pub axes: [f32; 6usize],
}
#[test]
fn bindgen_test_layout_SDL_PenMotionEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_PenMotionEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_PenMotionEvent>(),
        64usize,
        concat!("Size of: ", stringify!(SDL_PenMotionEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_PenMotionEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_PenMotionEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PenMotionEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PenMotionEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windowID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PenMotionEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PenMotionEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PenMotionEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pen_state) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PenMotionEvent),
            "::",
            stringify!(pen_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PenMotionEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PenMotionEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).axes) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PenMotionEvent),
            "::",
            stringify!(axes)
        )
    );
}
#[doc = "  \\brief Pressure-sensitive pen button event structure (event.pbutton.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_PenButtonEvent {
    #[doc = "< ::SDL_EVENT_PEN_BUTTON_DOWN or ::SDL_EVENT_PEN_BUTTON_UP"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The window with pen focus, if any"]
    pub windowID: Uint32,
    #[doc = "< The pen instance id"]
    pub which: SDL_PenID,
    #[doc = "< The pen button index (1 represents the pen tip for compatibility with mouse events)"]
    pub button: Uint8,
    #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
    pub state: Uint8,
    #[doc = "< Pen button msks (where SDL_BUTTON_LMASK is the pen tip). ::SDL_PEN_ERASER_MASK is set if the pen is (used as) an eraser."]
    pub pen_state: Uint16,
    #[doc = "< X coordinate, relative to window"]
    pub x: f32,
    #[doc = "< Y coordinate, relative to window"]
    pub y: f32,
    #[doc = "< Pen axes such as pressure and tilt (ordered as per ::SDL_PenAxis)"]
    pub axes: [f32; 6usize],
}
#[test]
fn bindgen_test_layout_SDL_PenButtonEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_PenButtonEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_PenButtonEvent>(),
        64usize,
        concat!("Size of: ", stringify!(SDL_PenButtonEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_PenButtonEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_PenButtonEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PenButtonEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PenButtonEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windowID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PenButtonEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PenButtonEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).button) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PenButtonEvent),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PenButtonEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pen_state) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PenButtonEvent),
            "::",
            stringify!(pen_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PenButtonEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PenButtonEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).axes) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PenButtonEvent),
            "::",
            stringify!(axes)
        )
    );
}
#[doc = "  \\brief An event used to request a file open by the system (event.drop.*)\n         This event is enabled by default, you can disable it with SDL_SetEventEnabled().\n  \\note If this event is enabled, you must free the filename in the event."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_DropEvent {
    #[doc = "< ::SDL_EVENT_DROP_BEGIN or ::SDL_EVENT_DROP_FILE or ::SDL_EVENT_DROP_TEXT or ::SDL_EVENT_DROP_COMPLETE or ::SDL_EVENT_DROP_POSITION"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The file name, which should be freed with SDL_free(), is NULL on begin/complete"]
    pub file: *mut libc::c_char,
    #[doc = "< The window that was dropped on, if any"]
    pub windowID: SDL_WindowID,
    #[doc = "< X coordinate, relative to window (not on begin)"]
    pub x: f32,
    #[doc = "< Y coordinate, relative to window (not on begin)"]
    pub y: f32,
}
#[test]
fn bindgen_test_layout_SDL_DropEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_DropEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_DropEvent>(),
        40usize,
        concat!("Size of: ", stringify!(SDL_DropEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_DropEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_DropEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DropEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DropEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DropEvent),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windowID) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DropEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DropEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DropEvent),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " \\brief An event triggered when the clipboard contents have changed (event.clipboard.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_ClipboardEvent {
    #[doc = "< ::SDL_EVENT_CLIPBOARD_UPDATE"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
}
#[test]
fn bindgen_test_layout_SDL_ClipboardEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_ClipboardEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_ClipboardEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_ClipboardEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_ClipboardEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_ClipboardEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ClipboardEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ClipboardEvent),
            "::",
            stringify!(timestamp)
        )
    );
}
#[doc = "  \\brief Sensor event structure (event.sensor.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SensorEvent {
    #[doc = "< ::SDL_EVENT_SENSOR_UPDATE"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The instance ID of the sensor"]
    pub which: SDL_SensorID,
    #[doc = "< Up to 6 values from the sensor - additional values can be queried using SDL_GetSensorData()"]
    pub data: [f32; 6usize],
    #[doc = "< The timestamp of the sensor reading in nanoseconds, not necessarily synchronized with the system clock"]
    pub sensor_timestamp: Uint64,
}
#[test]
fn bindgen_test_layout_SDL_SensorEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_SensorEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_SensorEvent>(),
        56usize,
        concat!("Size of: ", stringify!(SDL_SensorEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_SensorEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_SensorEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SensorEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SensorEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SensorEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SensorEvent),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sensor_timestamp) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SensorEvent),
            "::",
            stringify!(sensor_timestamp)
        )
    );
}
#[doc = "  \\brief The \"quit requested\" event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_QuitEvent {
    #[doc = "< ::SDL_EVENT_QUIT"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
}
#[test]
fn bindgen_test_layout_SDL_QuitEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_QuitEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_QuitEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_QuitEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_QuitEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_QuitEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_QuitEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_QuitEvent),
            "::",
            stringify!(timestamp)
        )
    );
}
#[doc = "  \\brief OS Specific event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_OSEvent {
    #[doc = "< ::SDL_EVENT_QUIT"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
}
#[test]
fn bindgen_test_layout_SDL_OSEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_OSEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_OSEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_OSEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_OSEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_OSEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_OSEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_OSEvent),
            "::",
            stringify!(timestamp)
        )
    );
}
#[doc = "  \\brief A user-defined event type (event.user.*)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_UserEvent {
    #[doc = "< ::SDL_EVENT_USER through ::SDL_EVENT_LAST-1"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< The associated window if any"]
    pub windowID: SDL_WindowID,
    #[doc = "< User defined event code"]
    pub code: Sint32,
    #[doc = "< User defined data pointer"]
    pub data1: *mut libc::c_void,
    #[doc = "< User defined data pointer"]
    pub data2: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_UserEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_UserEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_UserEvent>(),
        40usize,
        concat!("Size of: ", stringify!(SDL_UserEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_UserEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_UserEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windowID) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(data1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data2) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(data2)
        )
    );
}
#[doc = "  \\brief A video driver dependent system event (event.syswm.*)\n         This event is disabled by default, you can enable it with SDL_SetEventEnabled()\n\n  \\note If you want to use this event, you should include SDL_syswm.h."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SysWMEvent {
    #[doc = "< ::SDL_EVENT_SYSWM"]
    pub type_: Uint32,
    #[doc = "< In nanoseconds, populated using SDL_GetTicksNS()"]
    pub timestamp: Uint64,
    #[doc = "< driver dependent data, defined in SDL_syswm.h"]
    pub msg: *mut SDL_SysWMmsg,
}
#[test]
fn bindgen_test_layout_SDL_SysWMEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_SysWMEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_SysWMEvent>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_SysWMEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_SysWMEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_SysWMEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMEvent),
            "::",
            stringify!(msg)
        )
    );
}
#[doc = "  \\brief General event structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_Event {
    #[doc = "< Event type, shared with all events"]
    pub type_: Uint32,
    #[doc = "< Common event data"]
    pub common: SDL_CommonEvent,
    #[doc = "< Display event data"]
    pub display: SDL_DisplayEvent,
    #[doc = "< Window event data"]
    pub window: SDL_WindowEvent,
    #[doc = "< Keyboard event data"]
    pub key: SDL_KeyboardEvent,
    #[doc = "< Text editing event data"]
    pub edit: SDL_TextEditingEvent,
    #[doc = "< Extended text editing event data"]
    pub editExt: SDL_TextEditingExtEvent,
    #[doc = "< Text input event data"]
    pub text: SDL_TextInputEvent,
    #[doc = "< Mouse motion event data"]
    pub motion: SDL_MouseMotionEvent,
    #[doc = "< Mouse button event data"]
    pub button: SDL_MouseButtonEvent,
    #[doc = "< Mouse wheel event data"]
    pub wheel: SDL_MouseWheelEvent,
    #[doc = "< Joystick axis event data"]
    pub jaxis: SDL_JoyAxisEvent,
    #[doc = "< Joystick hat event data"]
    pub jhat: SDL_JoyHatEvent,
    #[doc = "< Joystick button event data"]
    pub jbutton: SDL_JoyButtonEvent,
    #[doc = "< Joystick device change event data"]
    pub jdevice: SDL_JoyDeviceEvent,
    #[doc = "< Joystick battery event data"]
    pub jbattery: SDL_JoyBatteryEvent,
    #[doc = "< Gamepad axis event data"]
    pub gaxis: SDL_GamepadAxisEvent,
    #[doc = "< Gamepad button event data"]
    pub gbutton: SDL_GamepadButtonEvent,
    #[doc = "< Gamepad device event data"]
    pub gdevice: SDL_GamepadDeviceEvent,
    #[doc = "< Gamepad touchpad event data"]
    pub gtouchpad: SDL_GamepadTouchpadEvent,
    #[doc = "< Gamepad sensor event data"]
    pub gsensor: SDL_GamepadSensorEvent,
    #[doc = "< Audio device event data"]
    pub adevice: SDL_AudioDeviceEvent,
    #[doc = "< Sensor event data"]
    pub sensor: SDL_SensorEvent,
    #[doc = "< Quit request event data"]
    pub quit: SDL_QuitEvent,
    #[doc = "< Custom event data"]
    pub user: SDL_UserEvent,
    #[doc = "< System dependent window event data"]
    pub syswm: SDL_SysWMEvent,
    #[doc = "< Touch finger event data"]
    pub tfinger: SDL_TouchFingerEvent,
    #[doc = "< Pen change in position, pressure, or angle"]
    pub pmotion: SDL_PenMotionEvent,
    #[doc = "< Pen button press"]
    pub pbutton: SDL_PenButtonEvent,
    #[doc = "< Drag and drop event data"]
    pub drop: SDL_DropEvent,
    #[doc = "< Clipboard cancelled event data"]
    pub clipboard: SDL_ClipboardEvent,
    pub padding: [Uint8; 128usize],
}
#[test]
fn bindgen_test_layout_SDL_Event() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_Event> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_Event>(),
        128usize,
        concat!("Size of: ", stringify!(SDL_Event))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Event>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_Event))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).common) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(common)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).edit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(edit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).editExt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(editExt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).motion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(motion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).button) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wheel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(wheel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).jaxis) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(jaxis)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).jhat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(jhat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).jbutton) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(jbutton)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).jdevice) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(jdevice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).jbattery) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(jbattery)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gaxis) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(gaxis)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gbutton) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(gbutton)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gdevice) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(gdevice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gtouchpad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(gtouchpad)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gsensor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(gsensor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adevice) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(adevice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sensor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(sensor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(quit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).syswm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(syswm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tfinger) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(tfinger)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pmotion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(pmotion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pbutton) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(pbutton)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).drop) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(drop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clipboard) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(clipboard)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    #[doc = " Pump the event loop, gathering events from the input devices.\n\n This function updates the event queue and internal input device state.\n\n **WARNING**: This should only be run in the thread that initialized the\n video subsystem, and for extra safety, you should consider only doing those\n things on the main thread in any case.\n\n SDL_PumpEvents() gathers all the pending input information from devices and\n places it in the event queue. Without calls to SDL_PumpEvents() no events\n would ever be placed on the queue. Often the need for calls to\n SDL_PumpEvents() is hidden from the user since SDL_PollEvent() and\n SDL_WaitEvent() implicitly call SDL_PumpEvents(). However, if you are not\n polling or waiting for events (e.g. you are filtering them), then you must\n call SDL_PumpEvents() to force an event queue update.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_PollEvent\n \\sa SDL_WaitEvent"]
    pub fn SDL_PumpEvents();
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_eventaction {
    SDL_ADDEVENT = 0,
    SDL_PEEKEVENT = 1,
    SDL_GETEVENT = 2,
}
extern "C" {
    #[doc = " Check the event queue for messages and optionally return them.\n\n `action` may be any of the following:\n\n - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the\n   event queue.\n - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,\n   within the specified minimum and maximum type, will be returned to the\n   caller and will _not_ be removed from the queue.\n - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,\n   within the specified minimum and maximum type, will be returned to the\n   caller and will be removed from the queue.\n\n You may have to call SDL_PumpEvents() before calling this function.\n Otherwise, the events may not be ready to be filtered when you call\n SDL_PeepEvents().\n\n This function is thread-safe.\n\n \\param events destination buffer for the retrieved events\n \\param numevents if action is SDL_ADDEVENT, the number of events to add\n                  back to the event queue; if action is SDL_PEEKEVENT or\n                  SDL_GETEVENT, the maximum number of events to retrieve\n \\param action action to take; see [[#action|Remarks]] for details\n \\param minType minimum value of the event type to be considered;\n                SDL_EVENT_FIRST is a safe choice\n \\param maxType maximum value of the event type to be considered;\n                SDL_EVENT_LAST is a safe choice\n \\returns the number of events actually stored or a negative error code on\n          failure; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_PollEvent\n \\sa SDL_PumpEvents\n \\sa SDL_PushEvent"]
    pub fn SDL_PeepEvents(
        events: *mut SDL_Event,
        numevents: libc::c_int,
        action: SDL_eventaction,
        minType: Uint32,
        maxType: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Check for the existence of a certain event type in the event queue.\n\n If you need to check for a range of event types, use SDL_HasEvents()\n instead.\n\n \\param type the type of event to be queried; see SDL_EventType for details\n \\returns SDL_TRUE if events matching `type` are present, or SDL_FALSE if\n          events matching `type` are not present.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HasEvents"]
    pub fn SDL_HasEvent(type_: Uint32) -> SDL_bool;
}
extern "C" {
    #[doc = " Check for the existence of certain event types in the event queue.\n\n If you need to check for a single event type, use SDL_HasEvent() instead.\n\n \\param minType the low end of event type to be queried, inclusive; see\n                SDL_EventType for details\n \\param maxType the high end of event type to be queried, inclusive; see\n                SDL_EventType for details\n \\returns SDL_TRUE if events with type >= `minType` and <= `maxType` are\n          present, or SDL_FALSE if not.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HasEvents"]
    pub fn SDL_HasEvents(minType: Uint32, maxType: Uint32) -> SDL_bool;
}
extern "C" {
    #[doc = " Clear events of a specific type from the event queue.\n\n This will unconditionally remove any events from the queue that match\n `type`. If you need to remove a range of event types, use SDL_FlushEvents()\n instead.\n\n It's also normal to just ignore events you don't care about in your event\n loop without calling this function.\n\n This function only affects currently queued events. If you want to make\n sure that all pending OS events are flushed, you can call SDL_PumpEvents()\n on the main thread immediately before the flush call.\n\n \\param type the type of event to be cleared; see SDL_EventType for details\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_FlushEvents"]
    pub fn SDL_FlushEvent(type_: Uint32);
}
extern "C" {
    #[doc = " Clear events of a range of types from the event queue.\n\n This will unconditionally remove any events from the queue that are in the\n range of `minType` to `maxType`, inclusive. If you need to remove a single\n event type, use SDL_FlushEvent() instead.\n\n It's also normal to just ignore events you don't care about in your event\n loop without calling this function.\n\n This function only affects currently queued events. If you want to make\n sure that all pending OS events are flushed, you can call SDL_PumpEvents()\n on the main thread immediately before the flush call.\n\n \\param minType the low end of event type to be cleared, inclusive; see\n                SDL_EventType for details\n \\param maxType the high end of event type to be cleared, inclusive; see\n                SDL_EventType for details\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_FlushEvent"]
    pub fn SDL_FlushEvents(minType: Uint32, maxType: Uint32);
}
extern "C" {
    #[doc = " Poll for currently pending events.\n\n If `event` is not NULL, the next event is removed from the queue and stored\n in the SDL_Event structure pointed to by `event`. The 1 returned refers to\n this event, immediately stored in the SDL Event structure -- not an event\n to follow.\n\n If `event` is NULL, it simply returns 1 if there is an event in the queue,\n but will not remove it from the queue.\n\n As this function may implicitly call SDL_PumpEvents(), you can only call\n this function in the thread that set the video mode.\n\n SDL_PollEvent() is the favored way of receiving system events since it can\n be done from the main loop and does not suspend the main loop while waiting\n on an event to be posted.\n\n The common practice is to fully process the event queue once every frame,\n usually as a first step before updating the game's state:\n\n ```c\n while (game_is_still_running) {\n     SDL_Event event;\n     while (SDL_PollEvent(&event)) {  // poll until all events are handled!\n         // decide what to do with this event.\n     }\n\n     // update game state, draw the current frame\n }\n ```\n\n \\param event the SDL_Event structure to be filled with the next event from\n              the queue, or NULL\n \\returns 1 if there is a pending event or 0 if there are none available.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetEventFilter\n \\sa SDL_PeepEvents\n \\sa SDL_PushEvent\n \\sa SDL_SetEventFilter\n \\sa SDL_WaitEvent\n \\sa SDL_WaitEventTimeout"]
    pub fn SDL_PollEvent(event: *mut SDL_Event) -> libc::c_int;
}
extern "C" {
    #[doc = " Wait indefinitely for the next available event.\n\n If `event` is not NULL, the next event is removed from the queue and stored\n in the SDL_Event structure pointed to by `event`.\n\n As this function may implicitly call SDL_PumpEvents(), you can only call\n this function in the thread that initialized the video subsystem.\n\n \\param event the SDL_Event structure to be filled in with the next event\n              from the queue, or NULL\n \\returns 1 on success or 0 if there was an error while waiting for events;\n          call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_PollEvent\n \\sa SDL_PumpEvents\n \\sa SDL_WaitEventTimeout"]
    pub fn SDL_WaitEvent(event: *mut SDL_Event) -> libc::c_int;
}
extern "C" {
    #[doc = " Wait until the specified timeout (in milliseconds) for the next available\n event.\n\n If `event` is not NULL, the next event is removed from the queue and stored\n in the SDL_Event structure pointed to by `event`.\n\n As this function may implicitly call SDL_PumpEvents(), you can only call\n this function in the thread that initialized the video subsystem.\n\n The timeout is not guaranteed, the actual wait time could be longer due to\n system scheduling.\n\n \\param event the SDL_Event structure to be filled in with the next event\n              from the queue, or NULL\n \\param timeoutMS the maximum number of milliseconds to wait for the next\n                  available event\n \\returns 1 on success or 0 if there was an error while waiting for events;\n          call SDL_GetError() for more information. This also returns 0 if\n          the timeout elapsed without an event arriving.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_PollEvent\n \\sa SDL_PumpEvents\n \\sa SDL_WaitEvent"]
    pub fn SDL_WaitEventTimeout(event: *mut SDL_Event, timeoutMS: Sint32) -> libc::c_int;
}
extern "C" {
    #[doc = " Add an event to the event queue.\n\n The event queue can actually be used as a two way communication channel.\n Not only can events be read from the queue, but the user can also push\n their own events onto it. `event` is a pointer to the event structure you\n wish to push onto the queue. The event is copied into the queue, and the\n caller may dispose of the memory pointed to after SDL_PushEvent() returns.\n\n Note: Pushing device input events onto the queue doesn't modify the state\n of the device within SDL.\n\n This function is thread-safe, and can be called from other threads safely.\n\n Note: Events pushed onto the queue with SDL_PushEvent() get passed through\n the event filter but events added with SDL_PeepEvents() do not.\n\n For pushing application-specific events, please use SDL_RegisterEvents() to\n get an event type that does not conflict with other code that also wants\n its own custom event types.\n\n \\param event the SDL_Event to be added to the queue\n \\returns 1 on success, 0 if the event was filtered, or a negative error\n          code on failure; call SDL_GetError() for more information. A\n          common reason for error is the event queue being full.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_PeepEvents\n \\sa SDL_PollEvent\n \\sa SDL_RegisterEvents"]
    pub fn SDL_PushEvent(event: *mut SDL_Event) -> libc::c_int;
}
#[doc = " A function pointer used for callbacks that watch the event queue.\n\n \\param userdata what was passed as `userdata` to SDL_SetEventFilter()\n        or SDL_AddEventWatch, etc\n \\param event the event that triggered the callback\n \\returns 1 to permit event to be added to the queue, and 0 to disallow\n          it. When used with SDL_AddEventWatch, the return value is ignored.\n\n \\sa SDL_SetEventFilter\n \\sa SDL_AddEventWatch"]
pub type SDL_EventFilter = ::core::option::Option<
    unsafe extern "C" fn(userdata: *mut libc::c_void, event: *mut SDL_Event) -> libc::c_int,
>;
extern "C" {
    #[doc = " Set up a filter to process all events before they change internal state and\n are posted to the internal event queue.\n\n If the filter function returns 1 when called, then the event will be added\n to the internal queue. If it returns 0, then the event will be dropped from\n the queue, but the internal state will still be updated. This allows\n selective filtering of dynamically arriving events.\n\n **WARNING**: Be very careful of what you do in the event filter function,\n as it may run in a different thread!\n\n On platforms that support it, if the quit event is generated by an\n interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the\n application at the next event poll.\n\n There is one caveat when dealing with the ::SDL_QuitEvent event type. The\n event filter is only called when the window manager desires to close the\n application window. If the event filter returns 1, then the window will be\n closed, otherwise the window will remain open if possible.\n\n Note: Disabled events never make it to the event filter function; see\n SDL_SetEventEnabled().\n\n Note: If you just want to inspect events without filtering, you should use\n SDL_AddEventWatch() instead.\n\n Note: Events pushed onto the queue with SDL_PushEvent() get passed through\n the event filter, but events pushed onto the queue with SDL_PeepEvents() do\n not.\n\n \\param filter An SDL_EventFilter function to call when an event happens\n \\param userdata a pointer that is passed to `filter`\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_AddEventWatch\n \\sa SDL_SetEventEnabled\n \\sa SDL_GetEventFilter\n \\sa SDL_PeepEvents\n \\sa SDL_PushEvent"]
    pub fn SDL_SetEventFilter(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
extern "C" {
    #[doc = " Query the current event filter.\n\n This function can be used to \"chain\" filters, by saving the existing filter\n before replacing it with a function that will call that saved filter.\n\n \\param filter the current callback function will be stored here\n \\param userdata the pointer that is passed to the current event filter will\n                 be stored here\n \\returns SDL_TRUE on success or SDL_FALSE if there is no event filter set.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetEventFilter"]
    pub fn SDL_GetEventFilter(
        filter: *mut SDL_EventFilter,
        userdata: *mut *mut libc::c_void,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Add a callback to be triggered when an event is added to the event queue.\n\n `filter` will be called when an event happens, and its return value is\n ignored.\n\n **WARNING**: Be very careful of what you do in the event filter function,\n as it may run in a different thread!\n\n If the quit event is generated by a signal (e.g. SIGINT), it will bypass\n the internal queue and be delivered to the watch callback immediately, and\n arrive at the next event poll.\n\n Note: the callback is called for events posted by the user through\n SDL_PushEvent(), but not for disabled events, nor for events by a filter\n callback set with SDL_SetEventFilter(), nor for events posted by the user\n through SDL_PeepEvents().\n\n \\param filter an SDL_EventFilter function to call when an event happens.\n \\param userdata a pointer that is passed to `filter`\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_DelEventWatch\n \\sa SDL_SetEventFilter"]
    pub fn SDL_AddEventWatch(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
extern "C" {
    #[doc = " Remove an event watch callback added with SDL_AddEventWatch().\n\n This function takes the same input as SDL_AddEventWatch() to identify and\n delete the corresponding callback.\n\n \\param filter the function originally passed to SDL_AddEventWatch()\n \\param userdata the pointer originally passed to SDL_AddEventWatch()\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_AddEventWatch"]
    pub fn SDL_DelEventWatch(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
extern "C" {
    #[doc = " Run a specific filter function on the current event queue, removing any\n events for which the filter returns 0.\n\n See SDL_SetEventFilter() for more information. Unlike SDL_SetEventFilter(),\n this function does not change the filter permanently, it only uses the\n supplied filter until this function returns.\n\n \\param filter the SDL_EventFilter function to call when an event happens\n \\param userdata a pointer that is passed to `filter`\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetEventFilter\n \\sa SDL_SetEventFilter"]
    pub fn SDL_FilterEvents(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
extern "C" {
    #[doc = " Set the state of processing events by type.\n\n \\param type the type of event; see SDL_EventType for details\n \\param enabled whether to process the event or not\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_IsEventEnabled"]
    pub fn SDL_SetEventEnabled(type_: Uint32, enabled: SDL_bool);
}
extern "C" {
    #[doc = " Query the state of processing events by type.\n\n \\param type the type of event; see SDL_EventType for details\n \\returns SDL_TRUE if the event is being processed, SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetEventEnabled"]
    pub fn SDL_EventEnabled(type_: Uint32) -> SDL_bool;
}
extern "C" {
    #[doc = " Allocate a set of user-defined events, and return the beginning event\n number for that set of events.\n\n Calling this function with `numevents` <= 0 is an error and will return\n (Uint32)-1.\n\n Note, (Uint32)-1 means the maximum unsigned 32-bit integer value (or\n 0xFFFFFFFF), but is clearer to write.\n\n \\param numevents the number of events to be allocated\n \\returns the beginning event number, or (Uint32)-1 if there are not enough\n          user-defined events left.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_PushEvent"]
    pub fn SDL_RegisterEvents(numevents: libc::c_int) -> Uint32;
}
extern "C" {
    #[doc = " Get the directory where the application was run from.\n\n This is not necessarily a fast call, so you should call this once near\n startup and save the string if you need it.\n\n **macOS and iOS Specific Functionality**: If the application is in a \".app\"\n bundle, this function returns the Resource directory (e.g.\n MyApp.app/Contents/Resources/). This behaviour can be overridden by adding\n a property to the Info.plist file. Adding a string key with the name\n SDL_FILESYSTEM_BASE_DIR_TYPE with a supported value will change the\n behaviour.\n\n Supported values for the SDL_FILESYSTEM_BASE_DIR_TYPE property (Given an\n application in /Applications/SDLApp/MyApp.app):\n\n - `resource`: bundle resource directory (the default). For example:\n   `/Applications/SDLApp/MyApp.app/Contents/Resources`\n - `bundle`: the Bundle directory. For example:\n   `/Applications/SDLApp/MyApp.app/`\n - `parent`: the containing directory of the bundle. For example:\n   `/Applications/SDLApp/`\n\n **Nintendo 3DS Specific Functionality**: This function returns \"romfs\"\n directory of the application as it is uncommon to store resources outside\n the executable. As such it is not a writable directory.\n\n The returned path is guaranteed to end with a path separator ('\\' on\n Windows, '/' on most other platforms).\n\n The pointer returned is owned by the caller. Please call SDL_free() on the\n pointer when done with it.\n\n \\returns an absolute path in UTF-8 encoding to the application data\n          directory. NULL will be returned on error or when the platform\n          doesn't implement this functionality, call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetPrefPath"]
    pub fn SDL_GetBasePath() -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Get the user-and-app-specific path where files can be written.\n\n Get the \"pref dir\". This is meant to be where users can write personal\n files (preferences and save games, etc) that are specific to your\n application. This directory is unique per user, per application.\n\n This function will decide the appropriate location in the native\n filesystem, create the directory if necessary, and return a string of the\n absolute path to the directory in UTF-8 encoding.\n\n On Windows, the string might look like:\n\n `C:\\\\Users\\\\bob\\\\AppData\\\\Roaming\\\\My Company\\\\My Program Name\\\\`\n\n On Linux, the string might look like:\n\n `/home/bob/.local/share/My Program Name/`\n\n On macOS, the string might look like:\n\n `/Users/bob/Library/Application Support/My Program Name/`\n\n You should assume the path returned by this function is the only safe place\n to write files (and that SDL_GetBasePath(), while it might be writable, or\n even the parent of the returned path, isn't where you should be writing\n things).\n\n Both the org and app strings may become part of a directory name, so please\n follow these rules:\n\n - Try to use the same org string (_including case-sensitivity_) for all\n   your applications that use this function.\n - Always use a unique app string for each one, and make sure it never\n   changes for an app once you've decided on it.\n - Unicode characters are legal, as long as it's UTF-8 encoded, but...\n - ...only use letters, numbers, and spaces. Avoid punctuation like \"Game\n   Name 2: Bad Guy's Revenge!\" ... \"Game Name 2\" is sufficient.\n\n The returned path is guaranteed to end with a path separator ('\\' on\n Windows, '/' on most other platforms).\n\n The pointer returned is owned by the caller. Please call SDL_free() on the\n pointer when done with it.\n\n \\param org the name of your organization\n \\param app the name of your application\n \\returns a UTF-8 string of the user directory in platform-dependent\n          notation. NULL if there's a problem (creating directory failed,\n          etc.).\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetBasePath"]
    pub fn SDL_GetPrefPath(org: *const libc::c_char, app: *const libc::c_char)
        -> *mut libc::c_char;
}
#[repr(u32)]
#[doc = " The type of the OS-provided default folder for a specific purpose.\n\n Note that the Trash folder isn't included here, because trashing files usually\n involves extra OS-specific functionality to remember the file's original\n location.\n\n The folders supported per platform are:\n\n |             | Windows | macOS/iOS | tvOS | Unix (XDG) | Haiku | Emscripten |\n | ----------- | ------- | --------- | ---- | ---------- | ----- | ---------- |\n | HOME        | X       | X         |      | X          | X     | X          |\n | DESKTOP     | X       | X         |      | X          | X     |            |\n | DOCUMENTS   | X       | X         |      | X          |       |            |\n | DOWNLOADS   | Vista+  | X         |      | X          |       |            |\n | MUSIC       | X       | X         |      | X          |       |            |\n | PICTURES    | X       | X         |      | X          |       |            |\n | PUBLICSHARE |         | X         |      | X          |       |            |\n | SAVEDGAMES  | Vista+  |           |      |            |       |            |\n | SCREENSHOTS | Vista+  |           |      |            |       |            |\n | TEMPLATES   | X       | X         |      | X          |       |            |\n | VIDEOS      | X       | X*        |      | X          |       |            |\n\n * Note that on macOS/iOS, the Videos folder is called \"Movies\".\n\n \\sa SDL_GetUserFolder"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_Folder {
    #[doc = " The folder which contains all of the current user's data, preferences,\nand documents. It usually contains most of the other folders. If a\nrequested folder does not exist, the home folder can be considered a safe\nfallback to store a user's documents."]
    SDL_FOLDER_HOME = 0,
    #[doc = " The folder of files that are displayed on the desktop. Note that the\nexistence of a desktop folder does not guarantee that the system does\nshow icons on its desktop; certain GNU/Linux distros with a graphical\nenvironment may not have desktop icons."]
    SDL_FOLDER_DESKTOP = 1,
    #[doc = " User document files, possibly application-specific. This is a good\nplace to save a user's projects."]
    SDL_FOLDER_DOCUMENTS = 2,
    #[doc = " Standard folder for user files downloaded from the internet."]
    SDL_FOLDER_DOWNLOADS = 3,
    #[doc = " Music files that can be played using a standard music player (mp3,\nogg...)."]
    SDL_FOLDER_MUSIC = 4,
    #[doc = " Image files that can be displayed using a standard viewer (png,\njpg...)."]
    SDL_FOLDER_PICTURES = 5,
    #[doc = " Files that are meant to be shared with other users on the same\ncomputer."]
    SDL_FOLDER_PUBLICSHARE = 6,
    #[doc = " Save files for games."]
    SDL_FOLDER_SAVEDGAMES = 7,
    #[doc = " Application screenshots."]
    SDL_FOLDER_SCREENSHOTS = 8,
    #[doc = " Template files to be used when the user requests the desktop environment\nto create a new file in a certain folder, such as \"New Text File.txt\".\nAny file in the Templates folder can be used as a starting point for a\nnew file."]
    SDL_FOLDER_TEMPLATES = 9,
    #[doc = " Video files that can be played using a standard video player (mp4,\nwebm...)."]
    SDL_FOLDER_VIDEOS = 10,
}
extern "C" {
    #[doc = " Finds the most suitable user folder for @p purpose, and returns its path in\n OS-specific notation.\n\n Many OSes provide certain standard folders for certain purposes, such as\n storing pictures, music or videos for a certain user. This function gives\n the path for many of those special locations.\n\n This function is specifically for _user_ folders, which are meant for the\n user to access and manage. For application-specific folders, meant to hold\n data for the application to manage, see SDL_GetBasePath() and\n SDL_GetPrefPath().\n\n Note that the function is expensive, and should be called once at the\n beginning of the execution and kept for as long as needed.\n\n The returned value is owned by the caller and should be freed with\n SDL_free().\n\n If NULL is returned, the error may be obtained with SDL_GetError().\n\n \\param folder The type of folder to find\n \\returns Either a null-terminated C string containing the full path to the\n          folder, or NULL if an error happened.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_Folder"]
    pub fn SDL_GetUserFolder(folder: SDL_Folder) -> *mut libc::c_char;
}
#[doc = "  \\typedef SDL_Haptic\n\n  \\brief The haptic structure used to identify an SDL haptic.\n\n  \\sa SDL_HapticOpen\n  \\sa SDL_HapticOpenFromJoystick\n  \\sa SDL_HapticClose"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Haptic {
    _unused: [u8; 0],
}
#[doc = "  \\brief Structure that represents a haptic direction.\n\n  This is the direction where the force comes from,\n  instead of the direction in which the force is exerted.\n\n  Directions can be specified by:\n   - ::SDL_HAPTIC_POLAR : Specified by polar coordinates.\n   - ::SDL_HAPTIC_CARTESIAN : Specified by cartesian coordinates.\n   - ::SDL_HAPTIC_SPHERICAL : Specified by spherical coordinates.\n\n  Cardinal directions of the haptic device are relative to the positioning\n  of the device.  North is considered to be away from the user.\n\n  The following diagram represents the cardinal directions:\n  \\verbatim\n.--.\n|__| .-------.\n|=.| |.-----.|\n|--| ||     ||\n|  | |'-----'|\n|__|~')_____('\n[ COMPUTER ]\n\n\nNorth (0,-1)\n^\n|\n|\n(-1,0)  West <----[ HAPTIC ]----> East (1,0)\n|\n|\nv\nSouth (0,1)\n\n\n[ USER ]\n\\|||/\n(o o)\n---ooO-(_)-Ooo---\n\\endverbatim\n\n  If type is ::SDL_HAPTIC_POLAR, direction is encoded by hundredths of a\n  degree starting north and turning clockwise.  ::SDL_HAPTIC_POLAR only uses\n  the first \\c dir parameter.  The cardinal directions would be:\n   - North: 0 (0 degrees)\n   - East: 9000 (90 degrees)\n   - South: 18000 (180 degrees)\n   - West: 27000 (270 degrees)\n\n  If type is ::SDL_HAPTIC_CARTESIAN, direction is encoded by three positions\n  (X axis, Y axis and Z axis (with 3 axes)).  ::SDL_HAPTIC_CARTESIAN uses\n  the first three \\c dir parameters.  The cardinal directions would be:\n   - North:  0,-1, 0\n   - East:   1, 0, 0\n   - South:  0, 1, 0\n   - West:  -1, 0, 0\n\n  The Z axis represents the height of the effect if supported, otherwise\n  it's unused.  In cartesian encoding (1, 2) would be the same as (2, 4), you\n  can use any multiple you want, only the direction matters.\n\n  If type is ::SDL_HAPTIC_SPHERICAL, direction is encoded by two rotations.\n  The first two \\c dir parameters are used.  The \\c dir parameters are as\n  follows (all values are in hundredths of degrees):\n   - Degrees from (1, 0) rotated towards (0, 1).\n   - Degrees towards (0, 0, 1) (device needs at least 3 axes).\n\n\n  Example of force coming from the south with all encodings (force coming\n  from the south means the user will have to pull the stick to counteract):\n  \\code\n  SDL_HapticDirection direction;\n\n  // Cartesian directions\n  direction.type = SDL_HAPTIC_CARTESIAN; // Using cartesian direction encoding.\n  direction.dir[0] = 0; // X position\n  direction.dir[1] = 1; // Y position\n  // Assuming the device has 2 axes, we don't need to specify third parameter.\n\n  // Polar directions\n  direction.type = SDL_HAPTIC_POLAR; // We'll be using polar direction encoding.\n  direction.dir[0] = 18000; // Polar only uses first parameter\n\n  // Spherical coordinates\n  direction.type = SDL_HAPTIC_SPHERICAL; // Spherical encoding\n  direction.dir[0] = 9000; // Since we only have two axes we don't need more parameters.\n  \\endcode\n\n  \\sa SDL_HAPTIC_POLAR\n  \\sa SDL_HAPTIC_CARTESIAN\n  \\sa SDL_HAPTIC_SPHERICAL\n  \\sa SDL_HAPTIC_STEERING_AXIS\n  \\sa SDL_HapticEffect\n  \\sa SDL_HapticNumAxes"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_HapticDirection {
    #[doc = "< The type of encoding."]
    pub type_: Uint8,
    #[doc = "< The encoded direction."]
    pub dir: [Sint32; 3usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticDirection() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_HapticDirection> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_HapticDirection>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_HapticDirection))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_HapticDirection>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticDirection))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticDirection),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dir) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticDirection),
            "::",
            stringify!(dir)
        )
    );
}
#[doc = "  \\brief A structure containing a template for a Constant effect.\n\n  This struct is exclusively for the ::SDL_HAPTIC_CONSTANT effect.\n\n  A constant effect applies a constant force in the specified direction\n  to the joystick.\n\n  \\sa SDL_HAPTIC_CONSTANT\n  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_HapticConstant {
    #[doc = "< ::SDL_HAPTIC_CONSTANT"]
    pub type_: Uint16,
    #[doc = "< Direction of the effect."]
    pub direction: SDL_HapticDirection,
    #[doc = "< Duration of the effect."]
    pub length: Uint32,
    #[doc = "< Delay before starting the effect."]
    pub delay: Uint16,
    #[doc = "< Button that triggers the effect."]
    pub button: Uint16,
    #[doc = "< How soon it can be triggered again after button."]
    pub interval: Uint16,
    #[doc = "< Strength of the constant effect."]
    pub level: Sint16,
    #[doc = "< Duration of the attack."]
    pub attack_length: Uint16,
    #[doc = "< Level at the start of the attack."]
    pub attack_level: Uint16,
    #[doc = "< Duration of the fade."]
    pub fade_length: Uint16,
    #[doc = "< Level at the end of the fade."]
    pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticConstant() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_HapticConstant> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_HapticConstant>(),
        40usize,
        concat!("Size of: ", stringify!(SDL_HapticConstant))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_HapticConstant>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticConstant))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delay) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).button) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interval) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attack_length) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(attack_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attack_level) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(attack_level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fade_length) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(fade_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fade_level) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(fade_level)
        )
    );
}
#[doc = "  \\brief A structure containing a template for a Periodic effect.\n\n  The struct handles the following effects:\n   - ::SDL_HAPTIC_SINE\n   - ::SDL_HAPTIC_LEFTRIGHT\n   - ::SDL_HAPTIC_TRIANGLE\n   - ::SDL_HAPTIC_SAWTOOTHUP\n   - ::SDL_HAPTIC_SAWTOOTHDOWN\n\n  A periodic effect consists in a wave-shaped effect that repeats itself\n  over time.  The type determines the shape of the wave and the parameters\n  determine the dimensions of the wave.\n\n  Phase is given by hundredth of a degree meaning that giving the phase a value\n  of 9000 will displace it 25% of its period.  Here are sample values:\n   -     0: No phase displacement.\n   -  9000: Displaced 25% of its period.\n   - 18000: Displaced 50% of its period.\n   - 27000: Displaced 75% of its period.\n   - 36000: Displaced 100% of its period, same as 0, but 0 is preferred.\n\n  Examples:\n  \\verbatim\nSDL_HAPTIC_SINE\n__      __      __      __\n/  \\    /  \\    /  \\    /\n/    \\__/    \\__/    \\__/\n\nSDL_HAPTIC_SQUARE\n__    __    __    __    __\n|  |  |  |  |  |  |  |  |  |\n|  |__|  |__|  |__|  |__|  |\n\nSDL_HAPTIC_TRIANGLE\n/\\    /\\    /\\    /\\    /\\\n/  \\  /  \\  /  \\  /  \\  /\n/    \\/    \\/    \\/    \\/\n\nSDL_HAPTIC_SAWTOOTHUP\n/|  /|  /|  /|  /|  /|  /|\n/ | / | / | / | / | / | / |\n/  |/  |/  |/  |/  |/  |/  |\n\nSDL_HAPTIC_SAWTOOTHDOWN\n\\  |\\  |\\  |\\  |\\  |\\  |\\  |\n\\ | \\ | \\ | \\ | \\ | \\ | \\ |\n\\|  \\|  \\|  \\|  \\|  \\|  \\|\n\\endverbatim\n\n  \\sa SDL_HAPTIC_SINE\n  \\sa SDL_HAPTIC_LEFTRIGHT\n  \\sa SDL_HAPTIC_TRIANGLE\n  \\sa SDL_HAPTIC_SAWTOOTHUP\n  \\sa SDL_HAPTIC_SAWTOOTHDOWN\n  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_HapticPeriodic {
    #[doc = "< ::SDL_HAPTIC_SINE, ::SDL_HAPTIC_LEFTRIGHT,\n::SDL_HAPTIC_TRIANGLE, ::SDL_HAPTIC_SAWTOOTHUP or\n::SDL_HAPTIC_SAWTOOTHDOWN"]
    pub type_: Uint16,
    #[doc = "< Direction of the effect."]
    pub direction: SDL_HapticDirection,
    #[doc = "< Duration of the effect."]
    pub length: Uint32,
    #[doc = "< Delay before starting the effect."]
    pub delay: Uint16,
    #[doc = "< Button that triggers the effect."]
    pub button: Uint16,
    #[doc = "< How soon it can be triggered again after button."]
    pub interval: Uint16,
    #[doc = "< Period of the wave."]
    pub period: Uint16,
    #[doc = "< Peak value; if negative, equivalent to 180 degrees extra phase shift."]
    pub magnitude: Sint16,
    #[doc = "< Mean value of the wave."]
    pub offset: Sint16,
    #[doc = "< Positive phase shift given by hundredth of a degree."]
    pub phase: Uint16,
    #[doc = "< Duration of the attack."]
    pub attack_length: Uint16,
    #[doc = "< Level at the start of the attack."]
    pub attack_level: Uint16,
    #[doc = "< Duration of the fade."]
    pub fade_length: Uint16,
    #[doc = "< Level at the end of the fade."]
    pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticPeriodic() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_HapticPeriodic> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_HapticPeriodic>(),
        48usize,
        concat!("Size of: ", stringify!(SDL_HapticPeriodic))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_HapticPeriodic>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticPeriodic))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delay) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).button) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interval) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).period) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).magnitude) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(magnitude)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phase) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(phase)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attack_length) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(attack_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attack_level) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(attack_level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fade_length) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(fade_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fade_level) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(fade_level)
        )
    );
}
#[doc = "  \\brief A structure containing a template for a Condition effect.\n\n  The struct handles the following effects:\n   - ::SDL_HAPTIC_SPRING: Effect based on axes position.\n   - ::SDL_HAPTIC_DAMPER: Effect based on axes velocity.\n   - ::SDL_HAPTIC_INERTIA: Effect based on axes acceleration.\n   - ::SDL_HAPTIC_FRICTION: Effect based on axes movement.\n\n  Direction is handled by condition internals instead of a direction member.\n  The condition effect specific members have three parameters.  The first\n  refers to the X axis, the second refers to the Y axis and the third\n  refers to the Z axis.  The right terms refer to the positive side of the\n  axis and the left terms refer to the negative side of the axis.  Please\n  refer to the ::SDL_HapticDirection diagram for which side is positive and\n  which is negative.\n\n  \\sa SDL_HapticDirection\n  \\sa SDL_HAPTIC_SPRING\n  \\sa SDL_HAPTIC_DAMPER\n  \\sa SDL_HAPTIC_INERTIA\n  \\sa SDL_HAPTIC_FRICTION\n  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_HapticCondition {
    #[doc = "< ::SDL_HAPTIC_SPRING, ::SDL_HAPTIC_DAMPER,\n::SDL_HAPTIC_INERTIA or ::SDL_HAPTIC_FRICTION"]
    pub type_: Uint16,
    #[doc = "< Direction of the effect - Not used ATM."]
    pub direction: SDL_HapticDirection,
    #[doc = "< Duration of the effect."]
    pub length: Uint32,
    #[doc = "< Delay before starting the effect."]
    pub delay: Uint16,
    #[doc = "< Button that triggers the effect."]
    pub button: Uint16,
    #[doc = "< How soon it can be triggered again after button."]
    pub interval: Uint16,
    #[doc = "< Level when joystick is to the positive side; max 0xFFFF."]
    pub right_sat: [Uint16; 3usize],
    #[doc = "< Level when joystick is to the negative side; max 0xFFFF."]
    pub left_sat: [Uint16; 3usize],
    #[doc = "< How fast to increase the force towards the positive side."]
    pub right_coeff: [Sint16; 3usize],
    #[doc = "< How fast to increase the force towards the negative side."]
    pub left_coeff: [Sint16; 3usize],
    #[doc = "< Size of the dead zone; max 0xFFFF: whole axis-range when 0-centered."]
    pub deadband: [Uint16; 3usize],
    #[doc = "< Position of the dead zone."]
    pub center: [Sint16; 3usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticCondition() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_HapticCondition> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_HapticCondition>(),
        68usize,
        concat!("Size of: ", stringify!(SDL_HapticCondition))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_HapticCondition>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticCondition))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delay) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).button) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interval) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).right_sat) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(right_sat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).left_sat) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(left_sat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).right_coeff) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(right_coeff)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).left_coeff) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(left_coeff)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deadband) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(deadband)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).center) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(center)
        )
    );
}
#[doc = "  \\brief A structure containing a template for a Ramp effect.\n\n  This struct is exclusively for the ::SDL_HAPTIC_RAMP effect.\n\n  The ramp effect starts at start strength and ends at end strength.\n  It augments in linear fashion.  If you use attack and fade with a ramp\n  the effects get added to the ramp effect making the effect become\n  quadratic instead of linear.\n\n  \\sa SDL_HAPTIC_RAMP\n  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_HapticRamp {
    #[doc = "< ::SDL_HAPTIC_RAMP"]
    pub type_: Uint16,
    #[doc = "< Direction of the effect."]
    pub direction: SDL_HapticDirection,
    #[doc = "< Duration of the effect."]
    pub length: Uint32,
    #[doc = "< Delay before starting the effect."]
    pub delay: Uint16,
    #[doc = "< Button that triggers the effect."]
    pub button: Uint16,
    #[doc = "< How soon it can be triggered again after button."]
    pub interval: Uint16,
    #[doc = "< Beginning strength level."]
    pub start: Sint16,
    #[doc = "< Ending strength level."]
    pub end: Sint16,
    #[doc = "< Duration of the attack."]
    pub attack_length: Uint16,
    #[doc = "< Level at the start of the attack."]
    pub attack_level: Uint16,
    #[doc = "< Duration of the fade."]
    pub fade_length: Uint16,
    #[doc = "< Level at the end of the fade."]
    pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticRamp() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_HapticRamp> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_HapticRamp>(),
        44usize,
        concat!("Size of: ", stringify!(SDL_HapticRamp))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_HapticRamp>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticRamp))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delay) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).button) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interval) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attack_length) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(attack_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attack_level) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(attack_level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fade_length) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(fade_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fade_level) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(fade_level)
        )
    );
}
#[doc = " \\brief A structure containing a template for a Left/Right effect.\n\n This struct is exclusively for the ::SDL_HAPTIC_LEFTRIGHT effect.\n\n The Left/Right effect is used to explicitly control the large and small\n motors, commonly found in modern game controllers. The small (right) motor\n is high frequency, and the large (left) motor is low frequency.\n\n \\sa SDL_HAPTIC_LEFTRIGHT\n \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_HapticLeftRight {
    #[doc = "< ::SDL_HAPTIC_LEFTRIGHT"]
    pub type_: Uint16,
    #[doc = "< Duration of the effect in milliseconds."]
    pub length: Uint32,
    #[doc = "< Control of the large controller motor."]
    pub large_magnitude: Uint16,
    #[doc = "< Control of the small controller motor."]
    pub small_magnitude: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticLeftRight() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_HapticLeftRight> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_HapticLeftRight>(),
        12usize,
        concat!("Size of: ", stringify!(SDL_HapticLeftRight))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_HapticLeftRight>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticLeftRight))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticLeftRight),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticLeftRight),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).large_magnitude) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticLeftRight),
            "::",
            stringify!(large_magnitude)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).small_magnitude) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticLeftRight),
            "::",
            stringify!(small_magnitude)
        )
    );
}
#[doc = "  \\brief A structure containing a template for the ::SDL_HAPTIC_CUSTOM effect.\n\n  This struct is exclusively for the ::SDL_HAPTIC_CUSTOM effect.\n\n  A custom force feedback effect is much like a periodic effect, where the\n  application can define its exact shape.  You will have to allocate the\n  data yourself.  Data should consist of channels * samples Uint16 samples.\n\n  If channels is one, the effect is rotated using the defined direction.\n  Otherwise it uses the samples in data for the different axes.\n\n  \\sa SDL_HAPTIC_CUSTOM\n  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_HapticCustom {
    #[doc = "< ::SDL_HAPTIC_CUSTOM"]
    pub type_: Uint16,
    #[doc = "< Direction of the effect."]
    pub direction: SDL_HapticDirection,
    #[doc = "< Duration of the effect."]
    pub length: Uint32,
    #[doc = "< Delay before starting the effect."]
    pub delay: Uint16,
    #[doc = "< Button that triggers the effect."]
    pub button: Uint16,
    #[doc = "< How soon it can be triggered again after button."]
    pub interval: Uint16,
    #[doc = "< Axes to use, minimum of one."]
    pub channels: Uint8,
    #[doc = "< Sample periods."]
    pub period: Uint16,
    #[doc = "< Amount of samples."]
    pub samples: Uint16,
    #[doc = "< Should contain channels*samples items."]
    pub data: *mut Uint16,
    #[doc = "< Duration of the attack."]
    pub attack_length: Uint16,
    #[doc = "< Level at the start of the attack."]
    pub attack_level: Uint16,
    #[doc = "< Duration of the fade."]
    pub fade_length: Uint16,
    #[doc = "< Level at the end of the fade."]
    pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticCustom() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_HapticCustom> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_HapticCustom>(),
        56usize,
        concat!("Size of: ", stringify!(SDL_HapticCustom))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_HapticCustom>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_HapticCustom))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delay) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).button) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interval) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).period) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).samples) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(samples)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attack_length) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(attack_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attack_level) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(attack_level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fade_length) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(fade_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fade_level) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(fade_level)
        )
    );
}
#[doc = "  \\brief The generic template for any haptic effect.\n\n  All values max at 32767 (0x7FFF).  Signed values also can be negative.\n  Time values unless specified otherwise are in milliseconds.\n\n  You can also pass ::SDL_HAPTIC_INFINITY to length instead of a 0-32767\n  value.  Neither delay, interval, attack_length nor fade_length support\n  ::SDL_HAPTIC_INFINITY.  Fade will also not be used since effect never ends.\n\n  Additionally, the ::SDL_HAPTIC_RAMP effect does not support a duration of\n  ::SDL_HAPTIC_INFINITY.\n\n  Button triggers may not be supported on all devices, it is advised to not\n  use them if possible.  Buttons start at index 1 instead of index 0 like\n  the joystick.\n\n  If both attack_length and fade_level are 0, the envelope is not used,\n  otherwise both values are used.\n\n  Common parts:\n  \\code\n  // Replay - All effects have this\n  Uint32 length;        // Duration of effect (ms).\n  Uint16 delay;         // Delay before starting effect.\n\n  // Trigger - All effects have this\n  Uint16 button;        // Button that triggers effect.\n  Uint16 interval;      // How soon before effect can be triggered again.\n\n  // Envelope - All effects except condition effects have this\n  Uint16 attack_length; // Duration of the attack (ms).\n  Uint16 attack_level;  // Level at the start of the attack.\n  Uint16 fade_length;   // Duration of the fade out (ms).\n  Uint16 fade_level;    // Level at the end of the fade.\n  \\endcode\n\n\n  Here we have an example of a constant effect evolution in time:\n  \\verbatim\nStrength\n^\n|\n|    effect level -->  _________________\n|                     /                 \\\n|                    /                   \\\n|                   /                     \\\n|                  /                       \\\n| attack_level --> |                        \\\n|                  |                        |  <---  fade_level\n|\n+--------------------------------------------------> Time\n[--]                 [---]\nattack_length        fade_length\n\n[------------------][-----------------------]\ndelay               length\n\\endverbatim\n\n  Note either the attack_level or the fade_level may be above the actual\n  effect level.\n\n  \\sa SDL_HapticConstant\n  \\sa SDL_HapticPeriodic\n  \\sa SDL_HapticCondition\n  \\sa SDL_HapticRamp\n  \\sa SDL_HapticLeftRight\n  \\sa SDL_HapticCustom"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_HapticEffect {
    #[doc = "< Effect type."]
    pub type_: Uint16,
    #[doc = "< Constant effect."]
    pub constant: SDL_HapticConstant,
    #[doc = "< Periodic effect."]
    pub periodic: SDL_HapticPeriodic,
    #[doc = "< Condition effect."]
    pub condition: SDL_HapticCondition,
    #[doc = "< Ramp effect."]
    pub ramp: SDL_HapticRamp,
    #[doc = "< Left/Right effect."]
    pub leftright: SDL_HapticLeftRight,
    #[doc = "< Custom effect."]
    pub custom: SDL_HapticCustom,
}
#[test]
fn bindgen_test_layout_SDL_HapticEffect() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_HapticEffect> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_HapticEffect>(),
        72usize,
        concat!("Size of: ", stringify!(SDL_HapticEffect))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_HapticEffect>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_HapticEffect))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).constant) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(constant)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).periodic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(periodic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).condition) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(condition)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ramp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(ramp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).leftright) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(leftright)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).custom) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(custom)
        )
    );
}
extern "C" {
    #[doc = " Count the number of haptic devices attached to the system.\n\n \\returns the number of haptic devices detected on the system or a negative\n          error code on failure; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticName"]
    pub fn SDL_NumHaptics() -> libc::c_int;
}
extern "C" {
    #[doc = " Get the implementation dependent name of a haptic device.\n\n This can be called before any joysticks are opened. If no name can be\n found, this function returns NULL.\n\n \\param device_index index of the device to query.\n \\returns the name of the device or NULL on failure; call SDL_GetError() for\n          more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_NumHaptics"]
    pub fn SDL_HapticName(device_index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Open a haptic device for use.\n\n The index passed as an argument refers to the N'th haptic device on this\n system.\n\n When opening a haptic device, its gain will be set to maximum and\n autocenter will be disabled. To modify these values use SDL_HapticSetGain()\n and SDL_HapticSetAutocenter().\n\n \\param device_index index of the device to open\n \\returns the device identifier or NULL on failure; call SDL_GetError() for\n          more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticClose\n \\sa SDL_HapticIndex\n \\sa SDL_HapticOpenFromJoystick\n \\sa SDL_HapticOpenFromMouse\n \\sa SDL_HapticPause\n \\sa SDL_HapticSetAutocenter\n \\sa SDL_HapticSetGain\n \\sa SDL_HapticStopAll"]
    pub fn SDL_HapticOpen(device_index: libc::c_int) -> *mut SDL_Haptic;
}
extern "C" {
    #[doc = " Check if the haptic device at the designated index has been opened.\n\n \\param device_index the index of the device to query\n \\returns 1 if it has been opened, 0 if it hasn't or on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticIndex\n \\sa SDL_HapticOpen"]
    pub fn SDL_HapticOpened(device_index: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the index of a haptic device.\n\n \\param haptic the SDL_Haptic device to query\n \\returns the index of the specified haptic device or a negative error code\n          on failure; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticOpen\n \\sa SDL_HapticOpened"]
    pub fn SDL_HapticIndex(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = " Query whether or not the current mouse has haptic capabilities.\n\n \\returns SDL_TRUE if the mouse is haptic or SDL_FALSE if it isn't.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticOpenFromMouse"]
    pub fn SDL_MouseIsHaptic() -> libc::c_int;
}
extern "C" {
    #[doc = " Try to open a haptic device from the current mouse.\n\n \\returns the haptic device identifier or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticOpen\n \\sa SDL_MouseIsHaptic"]
    pub fn SDL_HapticOpenFromMouse() -> *mut SDL_Haptic;
}
extern "C" {
    #[doc = " Query if a joystick has haptic features.\n\n \\param joystick the SDL_Joystick to test for haptic capabilities\n \\returns SDL_TRUE if the joystick is haptic, SDL_FALSE if it isn't, or a\n          negative error code on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticOpenFromJoystick"]
    pub fn SDL_JoystickIsHaptic(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
    #[doc = " Open a haptic device for use from a joystick device.\n\n You must still close the haptic device separately. It will not be closed\n with the joystick.\n\n When opened from a joystick you should first close the haptic device before\n closing the joystick device. If not, on some implementations the haptic\n device will also get unallocated and you'll be unable to use force feedback\n on that device.\n\n \\param joystick the SDL_Joystick to create a haptic device from\n \\returns a valid haptic device identifier on success or NULL on failure;\n          call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticClose\n \\sa SDL_HapticOpen\n \\sa SDL_JoystickIsHaptic"]
    pub fn SDL_HapticOpenFromJoystick(joystick: *mut SDL_Joystick) -> *mut SDL_Haptic;
}
extern "C" {
    #[doc = " Close a haptic device previously opened with SDL_HapticOpen().\n\n \\param haptic the SDL_Haptic device to close\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticOpen"]
    pub fn SDL_HapticClose(haptic: *mut SDL_Haptic);
}
extern "C" {
    #[doc = " Get the number of effects a haptic device can store.\n\n On some platforms this isn't fully supported, and therefore is an\n approximation. Always check to see if your created effect was actually\n created and do not rely solely on SDL_HapticNumEffects().\n\n \\param haptic the SDL_Haptic device to query\n \\returns the number of effects the haptic device can store or a negative\n          error code on failure; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticNumEffectsPlaying\n \\sa SDL_HapticQuery"]
    pub fn SDL_HapticNumEffects(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the number of effects a haptic device can play at the same time.\n\n This is not supported on all platforms, but will always return a value.\n\n \\param haptic the SDL_Haptic device to query maximum playing effects\n \\returns the number of effects the haptic device can play at the same time\n          or a negative error code on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticNumEffects\n \\sa SDL_HapticQuery"]
    pub fn SDL_HapticNumEffectsPlaying(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the haptic device's supported features in bitwise manner.\n\n \\param haptic the SDL_Haptic device to query\n \\returns a list of supported haptic features in bitwise manner (OR'd), or 0\n          on failure; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticEffectSupported\n \\sa SDL_HapticNumEffects"]
    pub fn SDL_HapticQuery(haptic: *mut SDL_Haptic) -> libc::c_uint;
}
extern "C" {
    #[doc = " Get the number of haptic axes the device has.\n\n The number of haptic axes might be useful if working with the\n SDL_HapticDirection effect.\n\n \\param haptic the SDL_Haptic device to query\n \\returns the number of axes on success or a negative error code on failure;\n          call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_HapticNumAxes(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = " Check to see if an effect is supported by a haptic device.\n\n \\param haptic the SDL_Haptic device to query\n \\param effect the desired effect to query\n \\returns SDL_TRUE if effect is supported, SDL_FALSE if it isn't, or a\n          negative error code on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticNewEffect\n \\sa SDL_HapticQuery"]
    pub fn SDL_HapticEffectSupported(
        haptic: *mut SDL_Haptic,
        effect: *mut SDL_HapticEffect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Create a new haptic effect on a specified device.\n\n \\param haptic an SDL_Haptic device to create the effect on\n \\param effect an SDL_HapticEffect structure containing the properties of\n               the effect to create\n \\returns the ID of the effect on success or a negative error code on\n          failure; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticDestroyEffect\n \\sa SDL_HapticRunEffect\n \\sa SDL_HapticUpdateEffect"]
    pub fn SDL_HapticNewEffect(
        haptic: *mut SDL_Haptic,
        effect: *mut SDL_HapticEffect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Update the properties of an effect.\n\n Can be used dynamically, although behavior when dynamically changing\n direction may be strange. Specifically the effect may re-upload itself and\n start playing from the start. You also cannot change the type either when\n running SDL_HapticUpdateEffect().\n\n \\param haptic the SDL_Haptic device that has the effect\n \\param effect the identifier of the effect to update\n \\param data an SDL_HapticEffect structure containing the new effect\n             properties to use\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticDestroyEffect\n \\sa SDL_HapticNewEffect\n \\sa SDL_HapticRunEffect"]
    pub fn SDL_HapticUpdateEffect(
        haptic: *mut SDL_Haptic,
        effect: libc::c_int,
        data: *mut SDL_HapticEffect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Run the haptic effect on its associated haptic device.\n\n To repeat the effect over and over indefinitely, set `iterations` to\n `SDL_HAPTIC_INFINITY`. (Repeats the envelope - attack and fade.) To make\n one instance of the effect last indefinitely (so the effect does not fade),\n set the effect's `length` in its structure/union to `SDL_HAPTIC_INFINITY`\n instead.\n\n \\param haptic the SDL_Haptic device to run the effect on\n \\param effect the ID of the haptic effect to run\n \\param iterations the number of iterations to run the effect; use\n                   `SDL_HAPTIC_INFINITY` to repeat forever\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticDestroyEffect\n \\sa SDL_HapticGetEffectStatus\n \\sa SDL_HapticStopEffect"]
    pub fn SDL_HapticRunEffect(
        haptic: *mut SDL_Haptic,
        effect: libc::c_int,
        iterations: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Stop the haptic effect on its associated haptic device.\n\n *\n\n \\param haptic the SDL_Haptic device to stop the effect on\n \\param effect the ID of the haptic effect to stop\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticDestroyEffect\n \\sa SDL_HapticRunEffect"]
    pub fn SDL_HapticStopEffect(haptic: *mut SDL_Haptic, effect: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Destroy a haptic effect on the device.\n\n This will stop the effect if it's running. Effects are automatically\n destroyed when the device is closed.\n\n \\param haptic the SDL_Haptic device to destroy the effect on\n \\param effect the ID of the haptic effect to destroy\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticNewEffect"]
    pub fn SDL_HapticDestroyEffect(haptic: *mut SDL_Haptic, effect: libc::c_int);
}
extern "C" {
    #[doc = " Get the status of the current effect on the specified haptic device.\n\n Device must support the SDL_HAPTIC_STATUS feature.\n\n \\param haptic the SDL_Haptic device to query for the effect status on\n \\param effect the ID of the haptic effect to query its status\n \\returns 0 if it isn't playing, 1 if it is playing, or a negative error\n          code on failure; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticRunEffect\n \\sa SDL_HapticStopEffect"]
    pub fn SDL_HapticGetEffectStatus(haptic: *mut SDL_Haptic, effect: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the global gain of the specified haptic device.\n\n Device must support the SDL_HAPTIC_GAIN feature.\n\n The user may specify the maximum gain by setting the environment variable\n `SDL_HAPTIC_GAIN_MAX` which should be between 0 and 100. All calls to\n SDL_HapticSetGain() will scale linearly using `SDL_HAPTIC_GAIN_MAX` as the\n maximum.\n\n \\param haptic the SDL_Haptic device to set the gain on\n \\param gain value to set the gain to, should be between 0 and 100 (0 - 100)\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticQuery"]
    pub fn SDL_HapticSetGain(haptic: *mut SDL_Haptic, gain: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the global autocenter of the device.\n\n Autocenter should be between 0 and 100. Setting it to 0 will disable\n autocentering.\n\n Device must support the SDL_HAPTIC_AUTOCENTER feature.\n\n \\param haptic the SDL_Haptic device to set autocentering on\n \\param autocenter value to set autocenter to (0-100)\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticQuery"]
    pub fn SDL_HapticSetAutocenter(haptic: *mut SDL_Haptic, autocenter: libc::c_int)
        -> libc::c_int;
}
extern "C" {
    #[doc = " Pause a haptic device.\n\n Device must support the `SDL_HAPTIC_PAUSE` feature. Call\n SDL_HapticUnpause() to resume playback.\n\n Do not modify the effects nor add new ones while the device is paused. That\n can cause all sorts of weird errors.\n\n \\param haptic the SDL_Haptic device to pause\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticUnpause"]
    pub fn SDL_HapticPause(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = " Unpause a haptic device.\n\n Call to unpause after SDL_HapticPause().\n\n \\param haptic the SDL_Haptic device to unpause\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticPause"]
    pub fn SDL_HapticUnpause(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = " Stop all the currently playing effects on a haptic device.\n\n \\param haptic the SDL_Haptic device to stop\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_HapticStopAll(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = " Check whether rumble is supported on a haptic device.\n\n \\param haptic haptic device to check for rumble support\n \\returns SDL_TRUE if effect is supported, SDL_FALSE if it isn't, or a\n          negative error code on failure; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticRumbleInit\n \\sa SDL_HapticRumblePlay\n \\sa SDL_HapticRumbleStop"]
    pub fn SDL_HapticRumbleSupported(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = " Initialize a haptic device for simple rumble playback.\n\n \\param haptic the haptic device to initialize for simple rumble playback\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticOpen\n \\sa SDL_HapticRumblePlay\n \\sa SDL_HapticRumbleStop\n \\sa SDL_HapticRumbleSupported"]
    pub fn SDL_HapticRumbleInit(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = " Run a simple rumble effect on a haptic device.\n\n \\param haptic the haptic device to play the rumble effect on\n \\param strength strength of the rumble to play as a 0-1 float value\n \\param length length of the rumble to play in milliseconds\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticRumbleInit\n \\sa SDL_HapticRumbleStop\n \\sa SDL_HapticRumbleSupported"]
    pub fn SDL_HapticRumblePlay(
        haptic: *mut SDL_Haptic,
        strength: f32,
        length: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Stop the simple rumble on a haptic device.\n\n \\param haptic the haptic device to stop the rumble effect on\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_HapticRumbleInit\n \\sa SDL_HapticRumblePlay\n \\sa SDL_HapticRumbleSupported"]
    pub fn SDL_HapticRumbleStop(haptic: *mut SDL_Haptic) -> libc::c_int;
}
#[doc = "  \\brief  A handle representing an open HID device"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_hid_device_ {
    _unused: [u8; 0],
}
pub type SDL_hid_device = SDL_hid_device_;
#[repr(u32)]
#[doc = "  \\brief HID underlying bus types."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_hid_bus_type {
    #[doc = " Unknown bus type"]
    SDL_HID_API_BUS_UNKNOWN = 0,
    #[doc = " USB bus\nSpecifications:\nhttps://usb.org/hid"]
    SDL_HID_API_BUS_USB = 1,
    #[doc = " Bluetooth or Bluetooth LE bus\nSpecifications:\nhttps://www.bluetooth.com/specifications/specs/human-interface-device-profile-1-1-1/\nhttps://www.bluetooth.com/specifications/specs/hid-service-1-0/\nhttps://www.bluetooth.com/specifications/specs/hid-over-gatt-profile-1-0/"]
    SDL_HID_API_BUS_BLUETOOTH = 2,
    #[doc = " I2C bus\nSpecifications:\nhttps://docs.microsoft.com/previous-versions/windows/hardware/design/dn642101(v=vs.85)"]
    SDL_HID_API_BUS_I2C = 3,
    #[doc = " SPI bus\nSpecifications:\nhttps://www.microsoft.com/download/details.aspx?id=103325"]
    SDL_HID_API_BUS_SPI = 4,
}
#[doc = " hidapi info structure */\n/**\n  \\brief  Information about a connected HID device"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_hid_device_info {
    #[doc = " Platform-specific device path"]
    pub path: *mut libc::c_char,
    #[doc = " Device Vendor ID"]
    pub vendor_id: libc::c_ushort,
    #[doc = " Device Product ID"]
    pub product_id: libc::c_ushort,
    #[doc = " Serial Number"]
    pub serial_number: *mut wchar_t,
    #[doc = " Device Release Number in binary-coded decimal,\nalso known as Device Version Number"]
    pub release_number: libc::c_ushort,
    #[doc = " Manufacturer String"]
    pub manufacturer_string: *mut wchar_t,
    #[doc = " Product string"]
    pub product_string: *mut wchar_t,
    #[doc = " Usage Page for this Device/Interface\n(Windows/Mac/hidraw only)"]
    pub usage_page: libc::c_ushort,
    #[doc = " Usage for this Device/Interface\n(Windows/Mac/hidraw only)"]
    pub usage: libc::c_ushort,
    #[doc = " The USB interface which this logical device\nrepresents.\n\nValid only if the device is a USB HID device.\nSet to -1 in all other cases."]
    pub interface_number: libc::c_int,
    #[doc = " Additional information about the USB interface.\nValid on libusb and Android implementations."]
    pub interface_class: libc::c_int,
    pub interface_subclass: libc::c_int,
    pub interface_protocol: libc::c_int,
    #[doc = " Underlying bus type"]
    pub bus_type: SDL_hid_bus_type,
    #[doc = " Pointer to the next device"]
    pub next: *mut SDL_hid_device_info,
}
#[test]
fn bindgen_test_layout_SDL_hid_device_info() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_hid_device_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_hid_device_info>(),
        80usize,
        concat!("Size of: ", stringify!(SDL_hid_device_info))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_hid_device_info>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_hid_device_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vendor_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(vendor_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).product_id) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(product_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial_number) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(serial_number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).release_number) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(release_number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).manufacturer_string) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(manufacturer_string)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).product_string) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(product_string)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).usage_page) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(usage_page)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).usage) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(usage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interface_number) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(interface_number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interface_class) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(interface_class)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interface_subclass) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(interface_subclass)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interface_protocol) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(interface_protocol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bus_type) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(bus_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_hid_device_info),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    #[doc = " Initialize the HIDAPI library.\n\n This function initializes the HIDAPI library. Calling it is not strictly\n necessary, as it will be called automatically by SDL_hid_enumerate() and\n any of the SDL_hid_open_*() functions if it is needed. This function should\n be called at the beginning of execution however, if there is a chance of\n HIDAPI handles being opened by different threads simultaneously.\n\n Each call to this function should have a matching call to SDL_hid_exit()\n\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_hid_exit"]
    pub fn SDL_hid_init() -> libc::c_int;
}
extern "C" {
    #[doc = " Finalize the HIDAPI library.\n\n This function frees all of the static data associated with HIDAPI. It\n should be called at the end of execution to avoid memory leaks.\n\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_hid_init"]
    pub fn SDL_hid_exit() -> libc::c_int;
}
extern "C" {
    #[doc = " Check to see if devices may have been added or removed.\n\n Enumerating the HID devices is an expensive operation, so you can call this\n to see if there have been any system device changes since the last call to\n this function. A change in the counter returned doesn't necessarily mean\n that anything has changed, but you can call SDL_hid_enumerate() to get an\n updated device list.\n\n Calling this function for the first time may cause a thread or other system\n resource to be allocated to track device change notifications.\n\n \\returns a change counter that is incremented with each potential device\n          change, or 0 if device change detection isn't available.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_hid_enumerate"]
    pub fn SDL_hid_device_change_count() -> Uint32;
}
extern "C" {
    #[doc = " Enumerate the HID Devices.\n\n This function returns a linked list of all the HID devices attached to the\n system which match vendor_id and product_id. If `vendor_id` is set to 0\n then any vendor matches. If `product_id` is set to 0 then any product\n matches. If `vendor_id` and `product_id` are both set to 0, then all HID\n devices will be returned.\n\n By default SDL will only enumerate controllers, to reduce risk of hanging\n or crashing on bad drivers, but SDL_HINT_HIDAPI_ENUMERATE_ONLY_CONTROLLERS\n can be set to \"0\" to enumerate all HID devices.\n\n \\param vendor_id The Vendor ID (VID) of the types of device to open, or 0\n                  to match any vendor.\n \\param product_id The Product ID (PID) of the types of device to open, or 0\n                   to match any product.\n \\returns a pointer to a linked list of type SDL_hid_device_info, containing\n          information about the HID devices attached to the system, or NULL\n          in the case of failure. Free this linked list by calling\n          SDL_hid_free_enumeration().\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_hid_device_change_count"]
    pub fn SDL_hid_enumerate(
        vendor_id: libc::c_ushort,
        product_id: libc::c_ushort,
    ) -> *mut SDL_hid_device_info;
}
extern "C" {
    #[doc = " Free an enumeration Linked List\n\n This function frees a linked list created by SDL_hid_enumerate().\n\n \\param devs Pointer to a list of struct_device returned from\n             SDL_hid_enumerate().\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_hid_free_enumeration(devs: *mut SDL_hid_device_info);
}
extern "C" {
    #[doc = " Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally\n a serial number.\n\n If `serial_number` is NULL, the first device with the specified VID and PID\n is opened.\n\n \\param vendor_id The Vendor ID (VID) of the device to open.\n \\param product_id The Product ID (PID) of the device to open.\n \\param serial_number The Serial Number of the device to open (Optionally\n                      NULL).\n \\returns a pointer to a SDL_hid_device object on success or NULL on\n          failure.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_hid_open(
        vendor_id: libc::c_ushort,
        product_id: libc::c_ushort,
        serial_number: *const wchar_t,
    ) -> *mut SDL_hid_device;
}
extern "C" {
    #[doc = " Open a HID device by its path name.\n\n The path name be determined by calling SDL_hid_enumerate(), or a\n platform-specific path name can be used (eg: /dev/hidraw0 on Linux).\n\n \\param path The path name of the device to open\n \\returns a pointer to a SDL_hid_device object on success or NULL on\n          failure.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_hid_open_path(path: *const libc::c_char) -> *mut SDL_hid_device;
}
extern "C" {
    #[doc = " Write an Output report to a HID device.\n\n The first byte of `data` must contain the Report ID. For devices which only\n support a single report, this must be set to 0x0. The remaining bytes\n contain the report data. Since the Report ID is mandatory, calls to\n SDL_hid_write() will always contain one more byte than the report contains.\n For example, if a hid report is 16 bytes long, 17 bytes must be passed to\n SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),\n followed by the report data (16 bytes). In this example, the length passed\n in would be 17.\n\n SDL_hid_write() will send the data on the first OUT endpoint, if one\n exists. If it does not, it will send the data through the Control Endpoint\n (Endpoint 0).\n\n \\param dev A device handle returned from SDL_hid_open().\n \\param data The data to send, including the report number as the first\n             byte.\n \\param length The length in bytes of the data to send.\n \\returns the actual number of bytes written and -1 on error.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_hid_write(
        dev: *mut SDL_hid_device,
        data: *const libc::c_uchar,
        length: usize,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Read an Input report from a HID device with timeout.\n\n Input reports are returned to the host through the INTERRUPT IN endpoint.\n The first byte will contain the Report number if the device uses numbered\n reports.\n\n \\param dev A device handle returned from SDL_hid_open().\n \\param data A buffer to put the read data into.\n \\param length The number of bytes to read. For devices with multiple\n               reports, make sure to read an extra byte for the report\n               number.\n \\param milliseconds timeout in milliseconds or -1 for blocking wait.\n \\returns the actual number of bytes read and -1 on error. If no packet was\n          available to be read within the timeout period, this function\n          returns 0.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_hid_read_timeout(
        dev: *mut SDL_hid_device,
        data: *mut libc::c_uchar,
        length: usize,
        milliseconds: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Read an Input report from a HID device.\n\n Input reports are returned to the host through the INTERRUPT IN endpoint.\n The first byte will contain the Report number if the device uses numbered\n reports.\n\n \\param dev A device handle returned from SDL_hid_open().\n \\param data A buffer to put the read data into.\n \\param length The number of bytes to read. For devices with multiple\n               reports, make sure to read an extra byte for the report\n               number.\n \\returns the actual number of bytes read and -1 on error. If no packet was\n          available to be read and the handle is in non-blocking mode, this\n          function returns 0.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_hid_read(
        dev: *mut SDL_hid_device,
        data: *mut libc::c_uchar,
        length: usize,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the device handle to be non-blocking.\n\n In non-blocking mode calls to SDL_hid_read() will return immediately with a\n value of 0 if there is no data to be read. In blocking mode, SDL_hid_read()\n will wait (block) until there is data to read before returning.\n\n Nonblocking can be turned on and off at any time.\n\n \\param dev A device handle returned from SDL_hid_open().\n \\param nonblock enable or not the nonblocking reads - 1 to enable\n                 nonblocking - 0 to disable nonblocking.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_hid_set_nonblocking(dev: *mut SDL_hid_device, nonblock: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Send a Feature report to the device.\n\n Feature reports are sent over the Control endpoint as a Set_Report\n transfer. The first byte of `data` must contain the Report ID. For devices\n which only support a single report, this must be set to 0x0. The remaining\n bytes contain the report data. Since the Report ID is mandatory, calls to\n SDL_hid_send_feature_report() will always contain one more byte than the\n report contains. For example, if a hid report is 16 bytes long, 17 bytes\n must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for\n devices which do not use numbered reports), followed by the report data (16\n bytes). In this example, the length passed in would be 17.\n\n \\param dev A device handle returned from SDL_hid_open().\n \\param data The data to send, including the report number as the first\n             byte.\n \\param length The length in bytes of the data to send, including the report\n               number.\n \\returns the actual number of bytes written and -1 on error.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_hid_send_feature_report(
        dev: *mut SDL_hid_device,
        data: *const libc::c_uchar,
        length: usize,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get a feature report from a HID device.\n\n Set the first byte of `data` to the Report ID of the report to be read.\n Make sure to allow space for this extra byte in `data`. Upon return, the\n first byte will still contain the Report ID, and the report data will start\n in data[1].\n\n \\param dev A device handle returned from SDL_hid_open().\n \\param data A buffer to put the read data into, including the Report ID.\n             Set the first byte of `data` to the Report ID of the report to\n             be read, or set it to zero if your device does not use numbered\n             reports.\n \\param length The number of bytes to read, including an extra byte for the\n               report ID. The buffer can be longer than the actual report.\n \\returns the number of bytes read plus one for the report ID (which is\n          still in the first byte), or -1 on error.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_hid_get_feature_report(
        dev: *mut SDL_hid_device,
        data: *mut libc::c_uchar,
        length: usize,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get an input report from a HID device.\n\n Set the first byte of `data` to the Report ID of the report to be read.\n Make sure to allow space for this extra byte in `data`. Upon return, the\n first byte will still contain the Report ID, and the report data will start\n in data[1].\n\n \\param dev A device handle returned from SDL_hid_open().\n \\param data A buffer to put the read data into, including the Report ID.\n             Set the first byte of `data` to the Report ID of the report to\n             be read, or set it to zero if your device does not use numbered\n             reports.\n \\param length The number of bytes to read, including an extra byte for the\n               report ID. The buffer can be longer than the actual report.\n \\returns the number of bytes read plus one for the report ID (which is\n          still in the first byte), or -1 on error.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_hid_get_input_report(
        dev: *mut SDL_hid_device,
        data: *mut libc::c_uchar,
        length: usize,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Close a HID device.\n\n \\param dev A device handle returned from SDL_hid_open().\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_hid_close(dev: *mut SDL_hid_device) -> libc::c_int;
}
extern "C" {
    #[doc = " Get The Manufacturer String from a HID device.\n\n \\param dev A device handle returned from SDL_hid_open().\n \\param string A wide string buffer to put the data into.\n \\param maxlen The length of the buffer in multiples of wchar_t.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_hid_get_manufacturer_string(
        dev: *mut SDL_hid_device,
        string: *mut wchar_t,
        maxlen: usize,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get The Product String from a HID device.\n\n \\param dev A device handle returned from SDL_hid_open().\n \\param string A wide string buffer to put the data into.\n \\param maxlen The length of the buffer in multiples of wchar_t.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_hid_get_product_string(
        dev: *mut SDL_hid_device,
        string: *mut wchar_t,
        maxlen: usize,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get The Serial Number String from a HID device.\n\n \\param dev A device handle returned from SDL_hid_open().\n \\param string A wide string buffer to put the data into.\n \\param maxlen The length of the buffer in multiples of wchar_t.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_hid_get_serial_number_string(
        dev: *mut SDL_hid_device,
        string: *mut wchar_t,
        maxlen: usize,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get a string from a HID device, based on its string index.\n\n \\param dev A device handle returned from SDL_hid_open().\n \\param string_index The index of the string to get.\n \\param string A wide string buffer to put the data into.\n \\param maxlen The length of the buffer in multiples of wchar_t.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_hid_get_indexed_string(
        dev: *mut SDL_hid_device,
        string_index: libc::c_int,
        string: *mut wchar_t,
        maxlen: usize,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the device info from a HID device.\n\n \\param dev A device handle returned from SDL_hid_open().\n \\returns a pointer to the SDL_hid_device_info for this hid_device, or NULL\n          in the case of failure; call SDL_GetError() for more information.\n          This struct is valid until the device is closed with\n          SDL_hid_close().\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_hid_get_device_info(dev: *mut SDL_hid_device) -> *mut SDL_hid_device_info;
}
extern "C" {
    #[doc = " Get a report descriptor from a HID device.\n\n User has to provide a preallocated buffer where descriptor will be copied\n to. The recommended size for a preallocated buffer is 4096 bytes.\n\n \\param dev A device handle returned from SDL_hid_open().\n \\param buf The buffer to copy descriptor into.\n \\param buf_size The size of the buffer in bytes.\n \\returns the number of bytes actually copied, or -1 on error; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_hid_get_report_descriptor(
        dev: *mut SDL_hid_device,
        buf: *mut libc::c_uchar,
        buf_size: usize,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Start or stop a BLE scan on iOS and tvOS to pair Steam Controllers\n\n \\param active SDL_TRUE to start the scan, SDL_FALSE to stop the scan\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_hid_ble_scan(active: SDL_bool);
}
#[repr(u32)]
#[doc = "  \\brief  An enumeration of hint priorities"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_HintPriority {
    SDL_HINT_DEFAULT = 0,
    SDL_HINT_NORMAL = 1,
    SDL_HINT_OVERRIDE = 2,
}
extern "C" {
    #[doc = " Set a hint with a specific priority.\n\n The priority controls the behavior when setting a hint that already has a\n value. Hints will replace existing hints of their priority and lower.\n Environment variables are considered to have override priority.\n\n \\param name the hint to set\n \\param value the value of the hint variable\n \\param priority the SDL_HintPriority level for the hint\n \\returns SDL_TRUE if the hint was set, SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetHint\n \\sa SDL_SetHint"]
    pub fn SDL_SetHintWithPriority(
        name: *const libc::c_char,
        value: *const libc::c_char,
        priority: SDL_HintPriority,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Set a hint with normal priority.\n\n Hints will not be set if there is an existing override hint or environment\n variable that takes precedence. You can use SDL_SetHintWithPriority() to\n set the hint with override priority instead.\n\n \\param name the hint to set\n \\param value the value of the hint variable\n \\returns SDL_TRUE if the hint was set, SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetHint\n \\sa SDL_SetHintWithPriority"]
    pub fn SDL_SetHint(name: *const libc::c_char, value: *const libc::c_char) -> SDL_bool;
}
extern "C" {
    #[doc = " Reset a hint to the default value.\n\n This will reset a hint to the value of the environment variable, or NULL if\n the environment isn't set. Callbacks will be called normally with this\n change.\n\n \\param name the hint to set\n \\returns SDL_TRUE if the hint was set, SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetHint\n \\sa SDL_SetHint"]
    pub fn SDL_ResetHint(name: *const libc::c_char) -> SDL_bool;
}
extern "C" {
    #[doc = " Reset all hints to the default values.\n\n This will reset all hints to the value of the associated environment\n variable, or NULL if the environment isn't set. Callbacks will be called\n normally with this change.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetHint\n \\sa SDL_SetHint\n \\sa SDL_ResetHint"]
    pub fn SDL_ResetHints();
}
extern "C" {
    #[doc = " Get the value of a hint.\n\n \\param name the hint to query\n \\returns the string value of a hint or NULL if the hint isn't set.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetHint\n \\sa SDL_SetHintWithPriority"]
    pub fn SDL_GetHint(name: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Get the boolean value of a hint variable.\n\n \\param name the name of the hint to get the boolean value from\n \\param default_value the value to return if the hint does not exist\n \\returns the boolean value of a hint or the provided default value if the\n          hint does not exist.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetHint\n \\sa SDL_SetHint"]
    pub fn SDL_GetHintBoolean(name: *const libc::c_char, default_value: SDL_bool) -> SDL_bool;
}
#[doc = " Type definition of the hint callback function.\n\n \\param userdata what was passed as `userdata` to SDL_AddHintCallback()\n \\param name what was passed as `name` to SDL_AddHintCallback()\n \\param oldValue the previous hint value\n \\param newValue the new value hint is to be set to"]
pub type SDL_HintCallback = ::core::option::Option<
    unsafe extern "C" fn(
        userdata: *mut libc::c_void,
        name: *const libc::c_char,
        oldValue: *const libc::c_char,
        newValue: *const libc::c_char,
    ),
>;
extern "C" {
    #[doc = " Add a function to watch a particular hint.\n\n \\param name the hint to watch\n \\param callback An SDL_HintCallback function that will be called when the\n                 hint value changes\n \\param userdata a pointer to pass to the callback function\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_DelHintCallback"]
    pub fn SDL_AddHintCallback(
        name: *const libc::c_char,
        callback: SDL_HintCallback,
        userdata: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Remove a function watching a particular hint.\n\n \\param name the hint being watched\n \\param callback An SDL_HintCallback function that will be called when the\n                 hint value changes\n \\param userdata a pointer being passed to the callback function\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_AddHintCallback"]
    pub fn SDL_DelHintCallback(
        name: *const libc::c_char,
        callback: SDL_HintCallback,
        userdata: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " Clear all hints.\n\n This function is automatically called during SDL_Quit(), and deletes all\n callbacks without calling them and frees all memory associated with hints.\n If you're calling this from application code you probably want to call\n SDL_ResetHints() instead.\n\n This function will be removed from the API the next time we rev the ABI.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_ResetHints"]
    pub fn SDL_ClearHints();
}
#[repr(u32)]
#[doc = "   \\brief Initialization flags for SDL_Init and/or SDL_InitSubSystem\n\n These are the flags which may be passed to SDL_Init().  You should\n specify the subsystems which you will be using in your application.\n\n \\sa SDL_Init\n \\sa SDL_Quit\n \\sa SDL_InitSubSystem\n \\sa SDL_QuitSubSystem\n \\sa SDL_WasInit"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_InitFlags {
    SDL_INIT_TIMER = 1,
    SDL_INIT_AUDIO = 16,
    #[doc = "< `SDL_INIT_VIDEO` implies `SDL_INIT_EVENTS`"]
    SDL_INIT_VIDEO = 32,
    #[doc = "< `SDL_INIT_JOYSTICK` implies `SDL_INIT_EVENTS`"]
    SDL_INIT_JOYSTICK = 512,
    SDL_INIT_HAPTIC = 4096,
    #[doc = "< `SDL_INIT_GAMEPAD` implies `SDL_INIT_JOYSTICK`"]
    SDL_INIT_GAMEPAD = 8192,
    SDL_INIT_EVENTS = 16384,
    SDL_INIT_SENSOR = 32768,
}
extern "C" {
    #[doc = " Initialize the SDL library.\n\n SDL_Init() simply forwards to calling SDL_InitSubSystem(). Therefore, the\n two may be used interchangeably. Though for readability of your code\n SDL_InitSubSystem() might be preferred.\n\n The file I/O (for example: SDL_RWFromFile) and threading (SDL_CreateThread)\n subsystems are initialized by default. Message boxes\n (SDL_ShowSimpleMessageBox) also attempt to work without initializing the\n video subsystem, in hopes of being useful in showing an error dialog when\n SDL_Init fails. You must specifically initialize other subsystems if you\n use them in your application.\n\n Logging (such as SDL_Log) works without initialization, too.\n\n `flags` may be any of the following OR'd together:\n\n - `SDL_INIT_TIMER`: timer subsystem\n - `SDL_INIT_AUDIO`: audio subsystem\n - `SDL_INIT_VIDEO`: video subsystem; automatically initializes the events\n   subsystem\n - `SDL_INIT_JOYSTICK`: joystick subsystem; automatically initializes the\n   events subsystem\n - `SDL_INIT_HAPTIC`: haptic (force feedback) subsystem\n - `SDL_INIT_GAMEPAD`: gamepad subsystem; automatically initializes the\n   joystick subsystem\n - `SDL_INIT_EVENTS`: events subsystem\n - `SDL_INIT_EVERYTHING`: all of the above subsystems\n\n Subsystem initialization is ref-counted, you must call SDL_QuitSubSystem()\n for each SDL_InitSubSystem() to correctly shutdown a subsystem manually (or\n call SDL_Quit() to force shutdown). If a subsystem is already loaded then\n this call will increase the ref-count and return.\n\n \\param flags subsystem initialization flags\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_InitSubSystem\n \\sa SDL_Quit\n \\sa SDL_SetMainReady\n \\sa SDL_WasInit"]
    pub fn SDL_Init(flags: Uint32) -> libc::c_int;
}
extern "C" {
    #[doc = " Compatibility function to initialize the SDL library.\n\n This function and SDL_Init() are interchangeable.\n\n \\param flags any of the flags used by SDL_Init(); see SDL_Init for details.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_Init\n \\sa SDL_Quit\n \\sa SDL_QuitSubSystem"]
    pub fn SDL_InitSubSystem(flags: Uint32) -> libc::c_int;
}
extern "C" {
    #[doc = " Shut down specific SDL subsystems.\n\n You still need to call SDL_Quit() even if you close all open subsystems\n with SDL_QuitSubSystem().\n\n \\param flags any of the flags used by SDL_Init(); see SDL_Init for details.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_InitSubSystem\n \\sa SDL_Quit"]
    pub fn SDL_QuitSubSystem(flags: Uint32);
}
extern "C" {
    #[doc = " Get a mask of the specified subsystems which are currently initialized.\n\n \\param flags any of the flags used by SDL_Init(); see SDL_Init for details.\n \\returns a mask of all initialized subsystems if `flags` is 0, otherwise it\n          returns the initialization status of the specified subsystems.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_Init\n \\sa SDL_InitSubSystem"]
    pub fn SDL_WasInit(flags: Uint32) -> Uint32;
}
extern "C" {
    #[doc = " Clean up all initialized subsystems.\n\n You should call this function even if you have already shutdown each\n initialized subsystem with SDL_QuitSubSystem(). It is safe to call this\n function even in the case of errors in initialization.\n\n You can use this function with atexit() to ensure that it is run when your\n application is shutdown, but it is not wise to do this from a library or\n other dynamically loaded code.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_Init\n \\sa SDL_QuitSubSystem"]
    pub fn SDL_Quit();
}
extern "C" {
    #[doc = " Dynamically load a shared object.\n\n \\param sofile a system-dependent name of the object file\n \\returns an opaque pointer to the object handle or NULL if there was an\n          error; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_LoadFunction\n \\sa SDL_UnloadObject"]
    pub fn SDL_LoadObject(sofile: *const libc::c_char) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Look up the address of the named function in a shared object.\n\n This function pointer is no longer valid after calling SDL_UnloadObject().\n\n This function can only look up C function names. Other languages may have\n name mangling and intrinsic language support that varies from compiler to\n compiler.\n\n Make sure you declare your function pointers with the same calling\n convention as the actual library function. Your code will crash\n mysteriously if you do not do this.\n\n If the requested function doesn't exist, NULL is returned.\n\n \\param handle a valid shared object handle returned by SDL_LoadObject()\n \\param name the name of the function to look up\n \\returns a pointer to the function or NULL if there was an error; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_LoadObject\n \\sa SDL_UnloadObject"]
    pub fn SDL_LoadFunction(
        handle: *mut libc::c_void,
        name: *const libc::c_char,
    ) -> SDL_FunctionPointer;
}
extern "C" {
    #[doc = " Unload a shared object from memory.\n\n \\param handle a valid shared object handle returned by SDL_LoadObject()\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_LoadFunction\n \\sa SDL_LoadObject"]
    pub fn SDL_UnloadObject(handle: *mut libc::c_void);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Locale {
    #[doc = "< A language name, like \"en\" for English."]
    pub language: *const libc::c_char,
    #[doc = "< A country, like \"US\" for America. Can be NULL."]
    pub country: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_SDL_Locale() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_Locale> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_Locale>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_Locale))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Locale>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_Locale))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).language) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Locale),
            "::",
            stringify!(language)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).country) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Locale),
            "::",
            stringify!(country)
        )
    );
}
extern "C" {
    #[doc = " Report the user's preferred locale.\n\n This returns an array of SDL_Locale structs, the final item zeroed out.\n When the caller is done with this array, it should call SDL_free() on the\n returned value; all the memory involved is allocated in a single block, so\n a single SDL_free() will suffice.\n\n Returned language strings are in the format xx, where 'xx' is an ISO-639\n language specifier (such as \"en\" for English, \"de\" for German, etc).\n Country strings are in the format YY, where \"YY\" is an ISO-3166 country\n code (such as \"US\" for the United States, \"CA\" for Canada, etc). Country\n might be NULL if there's no specific guidance on them (so you might get {\n \"en\", \"US\" } for American English, but { \"en\", NULL } means \"English\n language, generically\"). Language strings are never NULL, except to\n terminate the array.\n\n Please note that not all of these strings are 2 characters; some are three\n or more.\n\n The returned list of locales are in the order of the user's preference. For\n example, a German citizen that is fluent in US English and knows enough\n Japanese to navigate around Tokyo might have a list like: { \"de\", \"en_US\",\n \"jp\", NULL }. Someone from England might prefer British English (where\n \"color\" is spelled \"colour\", etc), but will settle for anything like it: {\n \"en_GB\", \"en\", NULL }.\n\n This function returns NULL on error, including when the platform does not\n supply this information at all.\n\n This might be a \"slow\" call that has to query the operating system. It's\n best to ask for this once and save the results. However, this list can\n change, usually because the user has changed a system preference outside of\n your program; SDL will send an SDL_EVENT_LOCALE_CHANGED event in this case,\n if possible, and you can call this function again to get an updated copy of\n preferred locales.\n\n \\returns array of locales, terminated with a locale with a NULL language\n          field. Will return NULL on error.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetPreferredLocales() -> *mut SDL_Locale;
}
#[repr(u32)]
#[doc = "  \\brief The predefined log categories\n\n  By default the application category is enabled at the INFO level,\n  the assert category is enabled at the WARN level, test is enabled\n  at the VERBOSE level and all other categories are enabled at the\n  CRITICAL level."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_LogCategory {
    SDL_LOG_CATEGORY_APPLICATION = 0,
    SDL_LOG_CATEGORY_ERROR = 1,
    SDL_LOG_CATEGORY_ASSERT = 2,
    SDL_LOG_CATEGORY_SYSTEM = 3,
    SDL_LOG_CATEGORY_AUDIO = 4,
    SDL_LOG_CATEGORY_VIDEO = 5,
    SDL_LOG_CATEGORY_RENDER = 6,
    SDL_LOG_CATEGORY_INPUT = 7,
    SDL_LOG_CATEGORY_TEST = 8,
    SDL_LOG_CATEGORY_RESERVED1 = 9,
    SDL_LOG_CATEGORY_RESERVED2 = 10,
    SDL_LOG_CATEGORY_RESERVED3 = 11,
    SDL_LOG_CATEGORY_RESERVED4 = 12,
    SDL_LOG_CATEGORY_RESERVED5 = 13,
    SDL_LOG_CATEGORY_RESERVED6 = 14,
    SDL_LOG_CATEGORY_RESERVED7 = 15,
    SDL_LOG_CATEGORY_RESERVED8 = 16,
    SDL_LOG_CATEGORY_RESERVED9 = 17,
    SDL_LOG_CATEGORY_RESERVED10 = 18,
    SDL_LOG_CATEGORY_CUSTOM = 19,
}
#[repr(u32)]
#[doc = "  \\brief The predefined log priorities"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_LogPriority {
    SDL_LOG_PRIORITY_VERBOSE = 1,
    SDL_LOG_PRIORITY_DEBUG = 2,
    SDL_LOG_PRIORITY_INFO = 3,
    SDL_LOG_PRIORITY_WARN = 4,
    SDL_LOG_PRIORITY_ERROR = 5,
    SDL_LOG_PRIORITY_CRITICAL = 6,
    SDL_NUM_LOG_PRIORITIES = 7,
}
extern "C" {
    #[doc = " Set the priority of all log categories.\n\n \\param priority the SDL_LogPriority to assign\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_LogSetPriority"]
    pub fn SDL_LogSetAllPriority(priority: SDL_LogPriority);
}
extern "C" {
    #[doc = " Set the priority of a particular log category.\n\n \\param category the category to assign a priority to\n \\param priority the SDL_LogPriority to assign\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_LogGetPriority\n \\sa SDL_LogSetAllPriority"]
    pub fn SDL_LogSetPriority(category: libc::c_int, priority: SDL_LogPriority);
}
extern "C" {
    #[doc = " Get the priority of a particular log category.\n\n \\param category the category to query\n \\returns the SDL_LogPriority for the requested category\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_LogSetPriority"]
    pub fn SDL_LogGetPriority(category: libc::c_int) -> SDL_LogPriority;
}
extern "C" {
    #[doc = " Reset all priorities to default.\n\n This is called by SDL_Quit().\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_LogSetAllPriority\n \\sa SDL_LogSetPriority"]
    pub fn SDL_LogResetPriorities();
}
extern "C" {
    #[doc = " Log a message with SDL_LOG_CATEGORY_APPLICATION and SDL_LOG_PRIORITY_INFO.\n\n = * \\param fmt a printf() style message format string\n\n \\param ... additional parameters matching % tokens in the `fmt` string, if\n            any\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_LogCritical\n \\sa SDL_LogDebug\n \\sa SDL_LogError\n \\sa SDL_LogInfo\n \\sa SDL_LogMessage\n \\sa SDL_LogMessageV\n \\sa SDL_LogVerbose\n \\sa SDL_LogWarn"]
    pub fn SDL_Log(fmt: *const libc::c_char, ...);
}
extern "C" {
    #[doc = " Log a message with SDL_LOG_PRIORITY_VERBOSE.\n\n \\param category the category of the message\n \\param fmt a printf() style message format string\n \\param ... additional parameters matching % tokens in the **fmt** string,\n            if any\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_Log\n \\sa SDL_LogCritical\n \\sa SDL_LogDebug\n \\sa SDL_LogError\n \\sa SDL_LogInfo\n \\sa SDL_LogMessage\n \\sa SDL_LogMessageV\n \\sa SDL_LogWarn"]
    pub fn SDL_LogVerbose(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
    #[doc = " Log a message with SDL_LOG_PRIORITY_DEBUG.\n\n \\param category the category of the message\n \\param fmt a printf() style message format string\n \\param ... additional parameters matching % tokens in the **fmt** string,\n            if any\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_Log\n \\sa SDL_LogCritical\n \\sa SDL_LogError\n \\sa SDL_LogInfo\n \\sa SDL_LogMessage\n \\sa SDL_LogMessageV\n \\sa SDL_LogVerbose\n \\sa SDL_LogWarn"]
    pub fn SDL_LogDebug(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
    #[doc = " Log a message with SDL_LOG_PRIORITY_INFO.\n\n \\param category the category of the message\n \\param fmt a printf() style message format string\n \\param ... additional parameters matching % tokens in the **fmt** string,\n            if any\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_Log\n \\sa SDL_LogCritical\n \\sa SDL_LogDebug\n \\sa SDL_LogError\n \\sa SDL_LogMessage\n \\sa SDL_LogMessageV\n \\sa SDL_LogVerbose\n \\sa SDL_LogWarn"]
    pub fn SDL_LogInfo(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
    #[doc = " Log a message with SDL_LOG_PRIORITY_WARN.\n\n \\param category the category of the message\n \\param fmt a printf() style message format string\n \\param ... additional parameters matching % tokens in the **fmt** string,\n            if any\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_Log\n \\sa SDL_LogCritical\n \\sa SDL_LogDebug\n \\sa SDL_LogError\n \\sa SDL_LogInfo\n \\sa SDL_LogMessage\n \\sa SDL_LogMessageV\n \\sa SDL_LogVerbose"]
    pub fn SDL_LogWarn(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
    #[doc = " Log a message with SDL_LOG_PRIORITY_ERROR.\n\n \\param category the category of the message\n \\param fmt a printf() style message format string\n \\param ... additional parameters matching % tokens in the **fmt** string,\n            if any\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_Log\n \\sa SDL_LogCritical\n \\sa SDL_LogDebug\n \\sa SDL_LogInfo\n \\sa SDL_LogMessage\n \\sa SDL_LogMessageV\n \\sa SDL_LogVerbose\n \\sa SDL_LogWarn"]
    pub fn SDL_LogError(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
    #[doc = " Log a message with SDL_LOG_PRIORITY_CRITICAL.\n\n \\param category the category of the message\n \\param fmt a printf() style message format string\n \\param ... additional parameters matching % tokens in the **fmt** string,\n            if any\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_Log\n \\sa SDL_LogDebug\n \\sa SDL_LogError\n \\sa SDL_LogInfo\n \\sa SDL_LogMessage\n \\sa SDL_LogMessageV\n \\sa SDL_LogVerbose\n \\sa SDL_LogWarn"]
    pub fn SDL_LogCritical(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
    #[doc = " Log a message with the specified category and priority.\n\n \\param category the category of the message\n \\param priority the priority of the message\n \\param fmt a printf() style message format string\n \\param ... additional parameters matching % tokens in the **fmt** string,\n            if any\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_Log\n \\sa SDL_LogCritical\n \\sa SDL_LogDebug\n \\sa SDL_LogError\n \\sa SDL_LogInfo\n \\sa SDL_LogMessageV\n \\sa SDL_LogVerbose\n \\sa SDL_LogWarn"]
    pub fn SDL_LogMessage(
        category: libc::c_int,
        priority: SDL_LogPriority,
        fmt: *const libc::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Log a message with the specified category and priority.\n\n \\param category the category of the message\n \\param priority the priority of the message\n \\param fmt a printf() style message format string\n \\param ap a variable argument list\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_Log\n \\sa SDL_LogCritical\n \\sa SDL_LogDebug\n \\sa SDL_LogError\n \\sa SDL_LogInfo\n \\sa SDL_LogMessage\n \\sa SDL_LogVerbose\n \\sa SDL_LogWarn"]
    pub fn SDL_LogMessageV(
        category: libc::c_int,
        priority: SDL_LogPriority,
        fmt: *const libc::c_char,
        ap: *mut __va_list_tag,
    );
}
#[doc = " The prototype for the log output callback function.\n\n This function is called by SDL when there is new text to be logged.\n\n \\param userdata what was passed as `userdata` to SDL_LogSetOutputFunction()\n \\param category the category of the message\n \\param priority the priority of the message\n \\param message the message being output"]
pub type SDL_LogOutputFunction = ::core::option::Option<
    unsafe extern "C" fn(
        userdata: *mut libc::c_void,
        category: libc::c_int,
        priority: SDL_LogPriority,
        message: *const libc::c_char,
    ),
>;
extern "C" {
    #[doc = " Get the current log output function.\n\n \\param callback an SDL_LogOutputFunction filled in with the current log\n                 callback\n \\param userdata a pointer filled in with the pointer that is passed to\n                 `callback`\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_LogSetOutputFunction"]
    pub fn SDL_LogGetOutputFunction(
        callback: *mut SDL_LogOutputFunction,
        userdata: *mut *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " Replace the default log output function with one of your own.\n\n \\param callback an SDL_LogOutputFunction to call instead of the default\n \\param userdata a pointer that is passed to `callback`\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_LogGetOutputFunction"]
    pub fn SDL_LogSetOutputFunction(callback: SDL_LogOutputFunction, userdata: *mut libc::c_void);
}
#[repr(u32)]
#[doc = " SDL_MessageBox flags. If supported will display warning icon, etc."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_MessageBoxFlags {
    #[doc = "< error dialog"]
    SDL_MESSAGEBOX_ERROR = 16,
    #[doc = "< warning dialog"]
    SDL_MESSAGEBOX_WARNING = 32,
    #[doc = "< informational dialog"]
    SDL_MESSAGEBOX_INFORMATION = 64,
    #[doc = "< buttons placed left to right"]
    SDL_MESSAGEBOX_BUTTONS_LEFT_TO_RIGHT = 128,
    #[doc = "< buttons placed right to left"]
    SDL_MESSAGEBOX_BUTTONS_RIGHT_TO_LEFT = 256,
}
#[repr(u32)]
#[doc = " Flags for SDL_MessageBoxButtonData."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_MessageBoxButtonFlags {
    #[doc = "< Marks the default button when return is hit"]
    SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT = 1,
    #[doc = "< Marks the default button when escape is hit"]
    SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT = 2,
}
#[doc = " Individual button data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_MessageBoxButtonData {
    #[doc = "< ::SDL_MessageBoxButtonFlags"]
    pub flags: Uint32,
    #[doc = "< User defined button id (value returned via SDL_ShowMessageBox)"]
    pub buttonid: libc::c_int,
    #[doc = "< The UTF-8 button text"]
    pub text: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxButtonData() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_MessageBoxButtonData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_MessageBoxButtonData>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_MessageBoxButtonData))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_MessageBoxButtonData>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_MessageBoxButtonData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxButtonData),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buttonid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxButtonData),
            "::",
            stringify!(buttonid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxButtonData),
            "::",
            stringify!(text)
        )
    );
}
#[doc = " RGB value used in a message box color scheme"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_MessageBoxColor {
    pub r: Uint8,
    pub g: Uint8,
    pub b: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxColor() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_MessageBoxColor> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_MessageBoxColor>(),
        3usize,
        concat!("Size of: ", stringify!(SDL_MessageBoxColor))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_MessageBoxColor>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_MessageBoxColor))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxColor),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).g) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxColor),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxColor),
            "::",
            stringify!(b)
        )
    );
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_MessageBoxColorType {
    SDL_MESSAGEBOX_COLOR_BACKGROUND = 0,
    SDL_MESSAGEBOX_COLOR_TEXT = 1,
    SDL_MESSAGEBOX_COLOR_BUTTON_BORDER = 2,
    SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND = 3,
    SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED = 4,
    SDL_MESSAGEBOX_COLOR_MAX = 5,
}
#[doc = " A set of colors to use for message box dialogs"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_MessageBoxColorScheme {
    pub colors: [SDL_MessageBoxColor; 5usize],
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxColorScheme() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_MessageBoxColorScheme> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_MessageBoxColorScheme>(),
        15usize,
        concat!("Size of: ", stringify!(SDL_MessageBoxColorScheme))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_MessageBoxColorScheme>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_MessageBoxColorScheme))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).colors) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxColorScheme),
            "::",
            stringify!(colors)
        )
    );
}
#[doc = " MessageBox structure containing title, text, window, etc."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_MessageBoxData {
    #[doc = "< ::SDL_MessageBoxFlags"]
    pub flags: Uint32,
    #[doc = "< Parent window, can be NULL"]
    pub window: *mut SDL_Window,
    #[doc = "< UTF-8 title"]
    pub title: *const libc::c_char,
    #[doc = "< UTF-8 message text"]
    pub message: *const libc::c_char,
    pub numbuttons: libc::c_int,
    pub buttons: *const SDL_MessageBoxButtonData,
    #[doc = "< ::SDL_MessageBoxColorScheme, can be NULL to use system settings"]
    pub colorScheme: *const SDL_MessageBoxColorScheme,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxData() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_MessageBoxData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_MessageBoxData>(),
        56usize,
        concat!("Size of: ", stringify!(SDL_MessageBoxData))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_MessageBoxData>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_MessageBoxData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).title) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numbuttons) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(numbuttons)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buttons) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).colorScheme) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(colorScheme)
        )
    );
}
extern "C" {
    #[doc = " Create a modal message box.\n\n If your needs aren't complex, it might be easier to use\n SDL_ShowSimpleMessageBox.\n\n This function should be called on the thread that created the parent\n window, or on the main thread if the messagebox has no parent. It will\n block execution of that thread until the user clicks a button or closes the\n messagebox.\n\n This function may be called at any time, even before SDL_Init(). This makes\n it useful for reporting errors like a failure to create a renderer or\n OpenGL context.\n\n On X11, SDL rolls its own dialog box with X11 primitives instead of a\n formal toolkit like GTK+ or Qt.\n\n Note that if SDL_Init() would fail because there isn't any available video\n target, this function is likely to fail for the same reasons. If this is a\n concern, check the return value from this function and fall back to writing\n to stderr if you can.\n\n \\param messageboxdata the SDL_MessageBoxData structure with title, text and\n                       other options\n \\param buttonid the pointer to which user id of hit button should be copied\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_ShowSimpleMessageBox"]
    pub fn SDL_ShowMessageBox(
        messageboxdata: *const SDL_MessageBoxData,
        buttonid: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Display a simple modal message box.\n\n If your needs aren't complex, this function is preferred over\n SDL_ShowMessageBox.\n\n `flags` may be any of the following:\n\n - `SDL_MESSAGEBOX_ERROR`: error dialog\n - `SDL_MESSAGEBOX_WARNING`: warning dialog\n - `SDL_MESSAGEBOX_INFORMATION`: informational dialog\n\n This function should be called on the thread that created the parent\n window, or on the main thread if the messagebox has no parent. It will\n block execution of that thread until the user clicks a button or closes the\n messagebox.\n\n This function may be called at any time, even before SDL_Init(). This makes\n it useful for reporting errors like a failure to create a renderer or\n OpenGL context.\n\n On X11, SDL rolls its own dialog box with X11 primitives instead of a\n formal toolkit like GTK+ or Qt.\n\n Note that if SDL_Init() would fail because there isn't any available video\n target, this function is likely to fail for the same reasons. If this is a\n concern, check the return value from this function and fall back to writing\n to stderr if you can.\n\n \\param flags an SDL_MessageBoxFlags value\n \\param title UTF-8 title text\n \\param message UTF-8 message text\n \\param window the parent window, or NULL for no parent\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_ShowMessageBox"]
    pub fn SDL_ShowSimpleMessageBox(
        flags: Uint32,
        title: *const libc::c_char,
        message: *const libc::c_char,
        window: *mut SDL_Window,
    ) -> libc::c_int;
}
#[doc = "  \\brief A handle to a CAMetalLayer-backed NSView (macOS) or UIView (iOS/tvOS).\n\n  \\note This can be cast directly to an NSView or UIView."]
pub type SDL_MetalView = *mut libc::c_void;
extern "C" {
    #[doc = " Create a CAMetalLayer-backed NSView/UIView and attach it to the specified\n window.\n\n On macOS, this does *not* associate a MTLDevice with the CAMetalLayer on\n its own. It is up to user code to do that.\n\n The returned handle can be casted directly to a NSView or UIView. To access\n the backing CAMetalLayer, call SDL_Metal_GetLayer().\n\n \\param window the window\n \\returns handle NSView or UIView\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_Metal_DestroyView\n \\sa SDL_Metal_GetLayer"]
    pub fn SDL_Metal_CreateView(window: *mut SDL_Window) -> SDL_MetalView;
}
extern "C" {
    #[doc = " Destroy an existing SDL_MetalView object.\n\n This should be called before SDL_DestroyWindow, if SDL_Metal_CreateView was\n called after SDL_CreateWindow.\n\n \\param view the SDL_MetalView object\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_Metal_CreateView"]
    pub fn SDL_Metal_DestroyView(view: SDL_MetalView);
}
extern "C" {
    #[doc = " Get a pointer to the backing CAMetalLayer for the given view.\n\n \\param view the SDL_MetalView object\n \\returns a pointer\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_Metal_CreateView"]
    pub fn SDL_Metal_GetLayer(view: SDL_MetalView) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Open a URL/URI in the browser or other appropriate external application.\n\n Open a URL in a separate, system-provided application. How this works will\n vary wildly depending on the platform. This will likely launch what makes\n sense to handle a specific URL's protocol (a web browser for `http://`,\n etc), but it might also be able to launch file managers for directories and\n other things.\n\n What happens when you open a URL varies wildly as well: your game window\n may lose focus (and may or may not lose focus if your game was fullscreen\n or grabbing input at the time). On mobile devices, your app will likely\n move to the background or your process might be paused. Any given platform\n may or may not handle a given URL.\n\n If this is unimplemented (or simply unavailable) for a platform, this will\n fail with an error. A successful result does not mean the URL loaded, just\n that we launched _something_ to handle it (or at least believe we did).\n\n All this to say: this function can be useful, but you should definitely\n test it on every platform you target.\n\n \\param url A valid URL/URI to open. Use `file:///full/path/to/file` for\n            local files, if supported.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_OpenURL(url: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the name of the platform.\n\n Here are the names returned for some (but not all) supported platforms:\n\n - \"Windows\"\n - \"macOS\"\n - \"Linux\"\n - \"iOS\"\n - \"Android\"\n\n \\returns the name of the platform. If the correct platform name is not\n          available, returns a string beginning with the text \"Unknown\".\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetPlatform() -> *const libc::c_char;
}
#[repr(u32)]
#[doc = "  The basic state for the system's power supply."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_PowerState {
    #[doc = "< cannot determine power status"]
    SDL_POWERSTATE_UNKNOWN = 0,
    #[doc = "< Not plugged in, running on the battery"]
    SDL_POWERSTATE_ON_BATTERY = 1,
    #[doc = "< Plugged in, no battery available"]
    SDL_POWERSTATE_NO_BATTERY = 2,
    #[doc = "< Plugged in, charging battery"]
    SDL_POWERSTATE_CHARGING = 3,
    #[doc = "< Plugged in, battery charged"]
    SDL_POWERSTATE_CHARGED = 4,
}
extern "C" {
    #[doc = " Get the current power supply details.\n\n You should never take a battery status as absolute truth. Batteries\n (especially failing batteries) are delicate hardware, and the values\n reported here are best estimates based on what that hardware reports. It's\n not uncommon for older batteries to lose stored power much faster than it\n reports, or completely drain when reporting it has 20 percent left, etc.\n\n Battery status can change at any time; if you are concerned with power\n state, you should call this function frequently, and perhaps ignore changes\n until they seem to be stable for a few seconds.\n\n It's possible a platform can only report battery percentage or time left\n but not both.\n\n \\param seconds seconds of battery life left, you can pass a NULL here if\n                you don't care, will return -1 if we can't determine a\n                value, or we're not running on a battery\n \\param percent percentage of battery life left, between 0 and 100, you can\n                pass a NULL here if you don't care, will return -1 if we\n                can't determine a value, or we're not running on a battery\n \\returns an SDL_PowerState enum representing the current battery state.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetPowerInfo(seconds: *mut libc::c_int, percent: *mut libc::c_int)
        -> SDL_PowerState;
}
#[repr(u32)]
#[doc = " Flags used when creating a rendering context"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_RendererFlags {
    #[doc = "< The renderer is a software fallback"]
    SDL_RENDERER_SOFTWARE = 1,
    #[doc = "< The renderer uses hardware\nacceleration"]
    SDL_RENDERER_ACCELERATED = 2,
    #[doc = "< Present is synchronized\nwith the refresh rate"]
    SDL_RENDERER_PRESENTVSYNC = 4,
}
#[doc = " Information on the capabilities of a render driver or context."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_RendererInfo {
    #[doc = "< The name of the renderer"]
    pub name: *const libc::c_char,
    #[doc = "< Supported ::SDL_RendererFlags"]
    pub flags: Uint32,
    #[doc = "< The number of available texture formats"]
    pub num_texture_formats: Uint32,
    #[doc = "< The available texture formats"]
    pub texture_formats: [Uint32; 16usize],
    #[doc = "< The maximum texture width"]
    pub max_texture_width: libc::c_int,
    #[doc = "< The maximum texture height"]
    pub max_texture_height: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_RendererInfo() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_RendererInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_RendererInfo>(),
        88usize,
        concat!("Size of: ", stringify!(SDL_RendererInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_RendererInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_RendererInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RendererInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RendererInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_texture_formats) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RendererInfo),
            "::",
            stringify!(num_texture_formats)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).texture_formats) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RendererInfo),
            "::",
            stringify!(texture_formats)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_texture_width) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RendererInfo),
            "::",
            stringify!(max_texture_width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_texture_height) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RendererInfo),
            "::",
            stringify!(max_texture_height)
        )
    );
}
#[doc = "  Vertex structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Vertex {
    #[doc = "< Vertex position, in SDL_Renderer coordinates"]
    pub position: SDL_FPoint,
    #[doc = "< Vertex color"]
    pub color: SDL_Color,
    #[doc = "< Normalized texture coordinates, if needed"]
    pub tex_coord: SDL_FPoint,
}
#[test]
fn bindgen_test_layout_SDL_Vertex() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_Vertex> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_Vertex>(),
        20usize,
        concat!("Size of: ", stringify!(SDL_Vertex))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Vertex>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_Vertex))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Vertex),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Vertex),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tex_coord) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Vertex),
            "::",
            stringify!(tex_coord)
        )
    );
}
#[repr(u32)]
#[doc = " The scaling mode for a texture."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_ScaleMode {
    #[doc = "< nearest pixel sampling"]
    SDL_SCALEMODE_NEAREST = 0,
    #[doc = "< linear filtering"]
    SDL_SCALEMODE_LINEAR = 1,
    #[doc = "< anisotropic filtering"]
    SDL_SCALEMODE_BEST = 2,
}
#[repr(u32)]
#[doc = " The access pattern allowed for a texture."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_TextureAccess {
    #[doc = "< Changes rarely, not lockable"]
    SDL_TEXTUREACCESS_STATIC = 0,
    #[doc = "< Changes frequently, lockable"]
    SDL_TEXTUREACCESS_STREAMING = 1,
    #[doc = "< Texture can be used as a render target"]
    SDL_TEXTUREACCESS_TARGET = 2,
}
#[repr(u32)]
#[doc = " The texture channel modulation used in SDL_RenderTexture()."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_TextureModulate {
    #[doc = "< No modulation"]
    SDL_TEXTUREMODULATE_NONE = 0,
    #[doc = "< srcC = srcC * color"]
    SDL_TEXTUREMODULATE_COLOR = 1,
    #[doc = "< srcA = srcA * alpha"]
    SDL_TEXTUREMODULATE_ALPHA = 2,
}
#[repr(u32)]
#[doc = " Flip constants for SDL_RenderTextureRotated"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_RendererFlip {
    #[doc = "< Do not flip"]
    SDL_FLIP_NONE = 0,
    #[doc = "< flip horizontally"]
    SDL_FLIP_HORIZONTAL = 1,
    #[doc = "< flip vertically"]
    SDL_FLIP_VERTICAL = 2,
}
#[repr(u32)]
#[doc = " How the logical size is mapped to the output"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_RendererLogicalPresentation {
    #[doc = "< There is no logical size in effect"]
    SDL_LOGICAL_PRESENTATION_DISABLED = 0,
    #[doc = "< The rendered content is stretched to the output resolution"]
    SDL_LOGICAL_PRESENTATION_STRETCH = 1,
    #[doc = "< The rendered content is fit to the largest dimension and the other dimension is letterboxed with black bars"]
    SDL_LOGICAL_PRESENTATION_LETTERBOX = 2,
    #[doc = "< The rendered content is fit to the smallest dimension and the other dimension extends beyond the output bounds"]
    SDL_LOGICAL_PRESENTATION_OVERSCAN = 3,
    #[doc = "< The rendered content is scaled up by integer multiples to fit the output resolution"]
    SDL_LOGICAL_PRESENTATION_INTEGER_SCALE = 4,
}
#[doc = " A structure representing rendering state"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Renderer {
    _unused: [u8; 0],
}
#[doc = " An efficient driver-specific representation of pixel data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_Texture {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get the number of 2D rendering drivers available for the current display.\n\n A render driver is a set of code that handles rendering and texture\n management on a particular display. Normally there is only one, but some\n drivers may have several available with different capabilities.\n\n There may be none if SDL was compiled without render support.\n\n \\returns a number >= 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateRenderer\n \\sa SDL_GetRenderDriver"]
    pub fn SDL_GetNumRenderDrivers() -> libc::c_int;
}
extern "C" {
    #[doc = " Use this function to get the name of a built in 2D rendering driver.\n\n The list of rendering drivers is given in the order that they are normally\n initialized by default; the drivers that seem more reasonable to choose\n first (as far as the SDL developers believe) are earlier in the list.\n\n The names of drivers are all simple, low-ASCII identifiers, like \"opengl\",\n \"direct3d12\" or \"metal\". These never have Unicode characters, and are not\n meant to be proper names.\n\n The returned value points to a static, read-only string; do not modify or\n free it!\n\n \\param index the index of the rendering driver; the value ranges from 0 to\n              SDL_GetNumRenderDrivers() - 1\n \\returns the name of the rendering driver at the requested index, or NULL\n          if an invalid index was specified.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetNumRenderDrivers"]
    pub fn SDL_GetRenderDriver(index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    #[doc = " Create a window and default renderer.\n\n \\param width the width of the window\n \\param height the height of the window\n \\param window_flags the flags used to create the window (see\n                     SDL_CreateWindow())\n \\param window a pointer filled with the window, or NULL on error\n \\param renderer a pointer filled with the renderer, or NULL on error\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateRenderer\n \\sa SDL_CreateWindow"]
    pub fn SDL_CreateWindowAndRenderer(
        width: libc::c_int,
        height: libc::c_int,
        window_flags: Uint32,
        window: *mut *mut SDL_Window,
        renderer: *mut *mut SDL_Renderer,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Create a 2D rendering context for a window.\n\n If you want a specific renderer, you can specify its name here. A list of\n available renderers can be obtained by calling SDL_GetRenderDriver multiple\n times, with indices from 0 to SDL_GetNumRenderDrivers()-1. If you don't\n need a specific renderer, specify NULL and SDL will attempt to chooes the\n best option for you, based on what is available on the user's system.\n\n By default the rendering size matches the window size in pixels, but you\n can call SDL_SetRenderLogicalPresentation() to change the content size and\n scaling options.\n\n \\param window the window where rendering is displayed\n \\param name the name of the rendering driver to initialize, or NULL to\n             initialize the first one supporting the requested flags\n \\param flags 0, or one or more SDL_RendererFlags OR'd together\n \\returns a valid rendering context or NULL if there was an error; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateSoftwareRenderer\n \\sa SDL_DestroyRenderer\n \\sa SDL_GetNumRenderDrivers\n \\sa SDL_GetRenderDriver\n \\sa SDL_GetRendererInfo"]
    pub fn SDL_CreateRenderer(
        window: *mut SDL_Window,
        name: *const libc::c_char,
        flags: Uint32,
    ) -> *mut SDL_Renderer;
}
extern "C" {
    #[doc = " Create a 2D software rendering context for a surface.\n\n Two other API which can be used to create SDL_Renderer:\n SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_\n create a software renderer, but they are intended to be used with an\n SDL_Window as the final destination and not an SDL_Surface.\n\n \\param surface the SDL_Surface structure representing the surface where\n                rendering is done\n \\returns a valid rendering context or NULL if there was an error; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateRenderer\n \\sa SDL_CreateWindowRenderer\n \\sa SDL_DestroyRenderer"]
    pub fn SDL_CreateSoftwareRenderer(surface: *mut SDL_Surface) -> *mut SDL_Renderer;
}
extern "C" {
    #[doc = " Get the renderer associated with a window.\n\n \\param window the window to query\n \\returns the rendering context on success or NULL on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateRenderer"]
    pub fn SDL_GetRenderer(window: *mut SDL_Window) -> *mut SDL_Renderer;
}
extern "C" {
    #[doc = " Get the window associated with a renderer.\n\n \\param renderer the renderer to query\n \\returns the window on success or NULL on failure; call SDL_GetError() for\n          more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetRenderWindow(renderer: *mut SDL_Renderer) -> *mut SDL_Window;
}
extern "C" {
    #[doc = " Get information about a rendering context.\n\n \\param renderer the rendering context\n \\param info an SDL_RendererInfo structure filled with information about the\n             current renderer\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateRenderer"]
    pub fn SDL_GetRendererInfo(
        renderer: *mut SDL_Renderer,
        info: *mut SDL_RendererInfo,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the output size in pixels of a rendering context.\n\n This returns the true output size in pixels, ignoring any render targets or\n logical size and presentation.\n\n \\param renderer the rendering context\n \\param w a pointer filled in with the width in pixels\n \\param h a pointer filled in with the height in pixels\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetRenderer"]
    pub fn SDL_GetRenderOutputSize(
        renderer: *mut SDL_Renderer,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the current output size in pixels of a rendering context.\n\n If a rendering target is active, this will return the size of the rendering\n target in pixels, otherwise if a logical size is set, it will return the\n logical size, otherwise it will return the value of\n SDL_GetRenderOutputSize().\n\n \\param renderer the rendering context\n \\param w a pointer filled in with the current width\n \\param h a pointer filled in with the current height\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetRenderOutputSize\n \\sa SDL_GetRenderer"]
    pub fn SDL_GetCurrentRenderOutputSize(
        renderer: *mut SDL_Renderer,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Create a texture for a rendering context.\n\n You can set the texture scaling method by setting\n `SDL_HINT_RENDER_SCALE_QUALITY` before creating the texture.\n\n \\param renderer the rendering context\n \\param format one of the enumerated values in SDL_PixelFormatEnum\n \\param access one of the enumerated values in SDL_TextureAccess\n \\param w the width of the texture in pixels\n \\param h the height of the texture in pixels\n \\returns a pointer to the created texture or NULL if no rendering context\n          was active, the format was unsupported, or the width or height\n          were out of range; call SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateTextureFromSurface\n \\sa SDL_DestroyTexture\n \\sa SDL_QueryTexture\n \\sa SDL_UpdateTexture"]
    pub fn SDL_CreateTexture(
        renderer: *mut SDL_Renderer,
        format: Uint32,
        access: libc::c_int,
        w: libc::c_int,
        h: libc::c_int,
    ) -> *mut SDL_Texture;
}
extern "C" {
    #[doc = " Create a texture from an existing surface.\n\n The surface is not modified or freed by this function.\n\n The SDL_TextureAccess hint for the created texture is\n `SDL_TEXTUREACCESS_STATIC`.\n\n The pixel format of the created texture may be different from the pixel\n format of the surface. Use SDL_QueryTexture() to query the pixel format of\n the texture.\n\n \\param renderer the rendering context\n \\param surface the SDL_Surface structure containing pixel data used to fill\n                the texture\n \\returns the created texture or NULL on failure; call SDL_GetError() for\n          more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateTexture\n \\sa SDL_DestroyTexture\n \\sa SDL_QueryTexture"]
    pub fn SDL_CreateTextureFromSurface(
        renderer: *mut SDL_Renderer,
        surface: *mut SDL_Surface,
    ) -> *mut SDL_Texture;
}
extern "C" {
    #[doc = " Query the attributes of a texture.\n\n \\param texture the texture to query\n \\param format a pointer filled in with the raw format of the texture; the\n               actual format may differ, but pixel transfers will use this\n               format (one of the SDL_PixelFormatEnum values). This argument\n               can be NULL if you don't need this information.\n \\param access a pointer filled in with the actual access to the texture\n               (one of the SDL_TextureAccess values). This argument can be\n               NULL if you don't need this information.\n \\param w a pointer filled in with the width of the texture in pixels. This\n          argument can be NULL if you don't need this information.\n \\param h a pointer filled in with the height of the texture in pixels. This\n          argument can be NULL if you don't need this information.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateTexture"]
    pub fn SDL_QueryTexture(
        texture: *mut SDL_Texture,
        format: *mut Uint32,
        access: *mut libc::c_int,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set an additional color value multiplied into render copy operations.\n\n When this texture is rendered, during the copy operation each source color\n channel is modulated by the appropriate color value according to the\n following formula:\n\n `srcC = srcC * (color / 255)`\n\n Color modulation is not always supported by the renderer; it will return -1\n if color modulation is not supported.\n\n \\param texture the texture to update\n \\param r the red color value multiplied into copy operations\n \\param g the green color value multiplied into copy operations\n \\param b the blue color value multiplied into copy operations\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetTextureColorMod\n \\sa SDL_SetTextureAlphaMod"]
    pub fn SDL_SetTextureColorMod(
        texture: *mut SDL_Texture,
        r: Uint8,
        g: Uint8,
        b: Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the additional color value multiplied into render copy operations.\n\n \\param texture the texture to query\n \\param r a pointer filled in with the current red color value\n \\param g a pointer filled in with the current green color value\n \\param b a pointer filled in with the current blue color value\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetTextureAlphaMod\n \\sa SDL_SetTextureColorMod"]
    pub fn SDL_GetTextureColorMod(
        texture: *mut SDL_Texture,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set an additional alpha value multiplied into render copy operations.\n\n When this texture is rendered, during the copy operation the source alpha\n value is modulated by this alpha value according to the following formula:\n\n `srcA = srcA * (alpha / 255)`\n\n Alpha modulation is not always supported by the renderer; it will return -1\n if alpha modulation is not supported.\n\n \\param texture the texture to update\n \\param alpha the source alpha value multiplied into copy operations\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetTextureAlphaMod\n \\sa SDL_SetTextureColorMod"]
    pub fn SDL_SetTextureAlphaMod(texture: *mut SDL_Texture, alpha: Uint8) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the additional alpha value multiplied into render copy operations.\n\n \\param texture the texture to query\n \\param alpha a pointer filled in with the current alpha value\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetTextureColorMod\n \\sa SDL_SetTextureAlphaMod"]
    pub fn SDL_GetTextureAlphaMod(texture: *mut SDL_Texture, alpha: *mut Uint8) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the blend mode for a texture, used by SDL_RenderTexture().\n\n If the blend mode is not supported, the closest supported mode is chosen\n and this function returns -1.\n\n \\param texture the texture to update\n \\param blendMode the SDL_BlendMode to use for texture blending\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetTextureBlendMode\n \\sa SDL_RenderTexture"]
    pub fn SDL_SetTextureBlendMode(
        texture: *mut SDL_Texture,
        blendMode: SDL_BlendMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the blend mode used for texture copy operations.\n\n \\param texture the texture to query\n \\param blendMode a pointer filled in with the current SDL_BlendMode\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetTextureBlendMode"]
    pub fn SDL_GetTextureBlendMode(
        texture: *mut SDL_Texture,
        blendMode: *mut SDL_BlendMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the scale mode used for texture scale operations.\n\n If the scale mode is not supported, the closest supported mode is chosen.\n\n \\param texture The texture to update.\n \\param scaleMode the SDL_ScaleMode to use for texture scaling.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetTextureScaleMode"]
    pub fn SDL_SetTextureScaleMode(
        texture: *mut SDL_Texture,
        scaleMode: SDL_ScaleMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the scale mode used for texture scale operations.\n\n \\param texture the texture to query.\n \\param scaleMode a pointer filled in with the current scale mode.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetTextureScaleMode"]
    pub fn SDL_GetTextureScaleMode(
        texture: *mut SDL_Texture,
        scaleMode: *mut SDL_ScaleMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Associate a user-specified pointer with a texture.\n\n \\param texture the texture to update.\n \\param userdata the pointer to associate with the texture.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetTextureUserData"]
    pub fn SDL_SetTextureUserData(
        texture: *mut SDL_Texture,
        userdata: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the user-specified pointer associated with a texture\n\n \\param texture the texture to query.\n \\returns the pointer associated with the texture, or NULL if the texture is\n          not valid.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetTextureUserData"]
    pub fn SDL_GetTextureUserData(texture: *mut SDL_Texture) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Update the given texture rectangle with new pixel data.\n\n The pixel data must be in the pixel format of the texture. Use\n SDL_QueryTexture() to query the pixel format of the texture.\n\n This is a fairly slow function, intended for use with static textures that\n do not change often.\n\n If the texture is intended to be updated often, it is preferred to create\n the texture as streaming and use the locking functions referenced below.\n While this function will work with streaming textures, for optimization\n reasons you may not get the pixels back if you lock the texture afterward.\n\n \\param texture the texture to update\n \\param rect an SDL_Rect structure representing the area to update, or NULL\n             to update the entire texture\n \\param pixels the raw pixel data in the format of the texture\n \\param pitch the number of bytes in a row of pixel data, including padding\n              between lines\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateTexture\n \\sa SDL_LockTexture\n \\sa SDL_UnlockTexture"]
    pub fn SDL_UpdateTexture(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        pixels: *const libc::c_void,
        pitch: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Update a rectangle within a planar YV12 or IYUV texture with new pixel\n data.\n\n You can use SDL_UpdateTexture() as long as your pixel data is a contiguous\n block of Y and U/V planes in the proper order, but this function is\n available if your pixel data is not contiguous.\n\n \\param texture the texture to update\n \\param rect a pointer to the rectangle of pixels to update, or NULL to\n             update the entire texture\n \\param Yplane the raw pixel data for the Y plane\n \\param Ypitch the number of bytes between rows of pixel data for the Y\n               plane\n \\param Uplane the raw pixel data for the U plane\n \\param Upitch the number of bytes between rows of pixel data for the U\n               plane\n \\param Vplane the raw pixel data for the V plane\n \\param Vpitch the number of bytes between rows of pixel data for the V\n               plane\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_UpdateTexture"]
    pub fn SDL_UpdateYUVTexture(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        Yplane: *const Uint8,
        Ypitch: libc::c_int,
        Uplane: *const Uint8,
        Upitch: libc::c_int,
        Vplane: *const Uint8,
        Vpitch: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Update a rectangle within a planar NV12 or NV21 texture with new pixels.\n\n You can use SDL_UpdateTexture() as long as your pixel data is a contiguous\n block of NV12/21 planes in the proper order, but this function is available\n if your pixel data is not contiguous.\n\n \\param texture the texture to update\n \\param rect a pointer to the rectangle of pixels to update, or NULL to\n             update the entire texture.\n \\param Yplane the raw pixel data for the Y plane.\n \\param Ypitch the number of bytes between rows of pixel data for the Y\n               plane.\n \\param UVplane the raw pixel data for the UV plane.\n \\param UVpitch the number of bytes between rows of pixel data for the UV\n                plane.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_UpdateNVTexture(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        Yplane: *const Uint8,
        Ypitch: libc::c_int,
        UVplane: *const Uint8,
        UVpitch: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Lock a portion of the texture for **write-only** pixel access.\n\n As an optimization, the pixels made available for editing don't necessarily\n contain the old texture data. This is a write-only operation, and if you\n need to keep a copy of the texture data you should do that at the\n application level.\n\n You must use SDL_UnlockTexture() to unlock the pixels and apply any\n changes.\n\n \\param texture the texture to lock for access, which was created with\n                `SDL_TEXTUREACCESS_STREAMING`\n \\param rect an SDL_Rect structure representing the area to lock for access;\n             NULL to lock the entire texture\n \\param pixels this is filled in with a pointer to the locked pixels,\n               appropriately offset by the locked area\n \\param pitch this is filled in with the pitch of the locked pixels; the\n              pitch is the length of one row in bytes\n \\returns 0 on success or a negative error code if the texture is not valid\n          or was not created with `SDL_TEXTUREACCESS_STREAMING`; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_UnlockTexture"]
    pub fn SDL_LockTexture(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        pixels: *mut *mut libc::c_void,
        pitch: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Lock a portion of the texture for **write-only** pixel access, and expose\n it as a SDL surface.\n\n Besides providing an SDL_Surface instead of raw pixel data, this function\n operates like SDL_LockTexture.\n\n As an optimization, the pixels made available for editing don't necessarily\n contain the old texture data. This is a write-only operation, and if you\n need to keep a copy of the texture data you should do that at the\n application level.\n\n You must use SDL_UnlockTexture() to unlock the pixels and apply any\n changes.\n\n The returned surface is freed internally after calling SDL_UnlockTexture()\n or SDL_DestroyTexture(). The caller should not free it.\n\n \\param texture the texture to lock for access, which must be created with\n                `SDL_TEXTUREACCESS_STREAMING`\n \\param rect a pointer to the rectangle to lock for access. If the rect is\n             NULL, the entire texture will be locked\n \\param surface this is filled in with an SDL surface representing the\n                locked area\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_LockTexture\n \\sa SDL_UnlockTexture"]
    pub fn SDL_LockTextureToSurface(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        surface: *mut *mut SDL_Surface,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Unlock a texture, uploading the changes to video memory, if needed.\n\n **Warning**: Please note that SDL_LockTexture() is intended to be\n write-only; it will not guarantee the previous contents of the texture will\n be provided. You must fully initialize any area of a texture that you lock\n before unlocking it, as the pixels might otherwise be uninitialized memory.\n\n Which is to say: locking and immediately unlocking a texture can result in\n corrupted textures, depending on the renderer in use.\n\n \\param texture a texture locked by SDL_LockTexture()\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_LockTexture"]
    pub fn SDL_UnlockTexture(texture: *mut SDL_Texture);
}
extern "C" {
    #[doc = " Set a texture as the current rendering target.\n\n The default render target is the window for which the renderer was created.\n To stop rendering to a texture and render to the window again, call this\n function with a NULL `texture`.\n\n \\param renderer the rendering context\n \\param texture the targeted texture, which must be created with the\n                `SDL_TEXTUREACCESS_TARGET` flag, or NULL to render to the\n                window instead of a texture.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetRenderTarget"]
    pub fn SDL_SetRenderTarget(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the current render target.\n\n The default render target is the window for which the renderer was created,\n and is reported a NULL here.\n\n \\param renderer the rendering context\n \\returns the current render target or NULL for the default render target.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetRenderTarget"]
    pub fn SDL_GetRenderTarget(renderer: *mut SDL_Renderer) -> *mut SDL_Texture;
}
extern "C" {
    #[doc = " Set a device independent resolution and presentation mode for rendering.\n\n This function sets the width and height of the logical rendering output. A\n render target is created at the specified size and used for rendering and\n then copied to the output during presentation.\n\n You can disable logical coordinates by setting the mode to\n SDL_LOGICAL_PRESENTATION_DISABLED, and in that case you get the full pixel\n resolution of the output window.\n\n You can convert coordinates in an event into rendering coordinates using\n SDL_ConvertEventToRenderCoordinates().\n\n \\param renderer the rendering context\n \\param w the width of the logical resolution\n \\param h the height of the logical resolution\n \\param mode the presentation mode used\n \\param scale_mode the scale mode used\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_ConvertEventToRenderCoordinates\n \\sa SDL_GetRenderLogicalPresentation"]
    pub fn SDL_SetRenderLogicalPresentation(
        renderer: *mut SDL_Renderer,
        w: libc::c_int,
        h: libc::c_int,
        mode: SDL_RendererLogicalPresentation,
        scale_mode: SDL_ScaleMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get device independent resolution and presentation mode for rendering.\n\n This function gets the width and height of the logical rendering output, or\n the output size in pixels if a logical resolution is not enabled.\n\n \\param renderer the rendering context\n \\param w an int to be filled with the width\n \\param h an int to be filled with the height\n \\param mode a pointer filled in with the presentation mode\n \\param scale_mode a pointer filled in with the scale mode\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetRenderLogicalPresentation"]
    pub fn SDL_GetRenderLogicalPresentation(
        renderer: *mut SDL_Renderer,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
        mode: *mut SDL_RendererLogicalPresentation,
        scale_mode: *mut SDL_ScaleMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get a point in render coordinates when given a point in window coordinates.\n\n \\param renderer the rendering context\n \\param window_x the x coordinate in window coordinates\n \\param window_y the y coordinate in window coordinates\n \\param x a pointer filled with the x coordinate in render coordinates\n \\param y a pointer filled with the y coordinate in render coordinates\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetRenderLogicalPresentation\n \\sa SDL_SetRenderScale"]
    pub fn SDL_RenderCoordinatesFromWindow(
        renderer: *mut SDL_Renderer,
        window_x: f32,
        window_y: f32,
        x: *mut f32,
        y: *mut f32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get a point in window coordinates when given a point in render coordinates.\n\n \\param renderer the rendering context\n \\param x the x coordinate in render coordinates\n \\param y the y coordinate in render coordinates\n \\param window_x a pointer filled with the x coordinate in window\n                 coordinates\n \\param window_y a pointer filled with the y coordinate in window\n                 coordinates\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetRenderLogicalPresentation\n \\sa SDL_SetRenderScale"]
    pub fn SDL_RenderCoordinatesToWindow(
        renderer: *mut SDL_Renderer,
        x: f32,
        y: f32,
        window_x: *mut f32,
        window_y: *mut f32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Convert the coordinates in an event to render coordinates.\n\n Touch coordinates are converted from normalized coordinates in the window\n to non-normalized rendering coordinates.\n\n Once converted, the coordinates may be outside the rendering area.\n\n \\param renderer the rendering context\n \\param event the event to modify\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetRenderCoordinatesFromWindowCoordinates"]
    pub fn SDL_ConvertEventToRenderCoordinates(
        renderer: *mut SDL_Renderer,
        event: *mut SDL_Event,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the drawing area for rendering on the current target.\n\n \\param renderer the rendering context\n \\param rect the SDL_Rect structure representing the drawing area, or NULL\n             to set the viewport to the entire target\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetRenderViewport"]
    pub fn SDL_SetRenderViewport(renderer: *mut SDL_Renderer, rect: *const SDL_Rect)
        -> libc::c_int;
}
extern "C" {
    #[doc = " Get the drawing area for the current target.\n\n \\param renderer the rendering context\n \\param rect an SDL_Rect structure filled in with the current drawing area\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetRenderViewport"]
    pub fn SDL_GetRenderViewport(renderer: *mut SDL_Renderer, rect: *mut SDL_Rect) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the clip rectangle for rendering on the specified target.\n\n \\param renderer the rendering context\n \\param rect an SDL_Rect structure representing the clip area, relative to\n             the viewport, or NULL to disable clipping\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetRenderClipRect\n \\sa SDL_RenderClipEnabled"]
    pub fn SDL_SetRenderClipRect(renderer: *mut SDL_Renderer, rect: *const SDL_Rect)
        -> libc::c_int;
}
extern "C" {
    #[doc = " Get the clip rectangle for the current target.\n\n \\param renderer the rendering context\n \\param rect an SDL_Rect structure filled in with the current clipping area\n             or an empty rectangle if clipping is disabled\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_RenderClipEnabled\n \\sa SDL_SetRenderClipRect"]
    pub fn SDL_GetRenderClipRect(renderer: *mut SDL_Renderer, rect: *mut SDL_Rect) -> libc::c_int;
}
extern "C" {
    #[doc = " Get whether clipping is enabled on the given renderer.\n\n \\param renderer the rendering context\n \\returns SDL_TRUE if clipping is enabled or SDL_FALSE if not; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetRenderClipRect\n \\sa SDL_SetRenderClipRect"]
    pub fn SDL_RenderClipEnabled(renderer: *mut SDL_Renderer) -> SDL_bool;
}
extern "C" {
    #[doc = " Set the drawing scale for rendering on the current target.\n\n The drawing coordinates are scaled by the x/y scaling factors before they\n are used by the renderer. This allows resolution independent drawing with a\n single coordinate system.\n\n If this results in scaling or subpixel drawing by the rendering backend, it\n will be handled using the appropriate quality hints. For best results use\n integer scaling factors.\n\n \\param renderer the rendering context\n \\param scaleX the horizontal scaling factor\n \\param scaleY the vertical scaling factor\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetRenderScale"]
    pub fn SDL_SetRenderScale(renderer: *mut SDL_Renderer, scaleX: f32, scaleY: f32)
        -> libc::c_int;
}
extern "C" {
    #[doc = " Get the drawing scale for the current target.\n\n \\param renderer the rendering context\n \\param scaleX a pointer filled in with the horizontal scaling factor\n \\param scaleY a pointer filled in with the vertical scaling factor\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetRenderScale"]
    pub fn SDL_GetRenderScale(
        renderer: *mut SDL_Renderer,
        scaleX: *mut f32,
        scaleY: *mut f32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the color used for drawing operations (Rect, Line and Clear).\n\n Set the color for drawing or filling rectangles, lines, and points, and for\n SDL_RenderClear().\n\n \\param renderer the rendering context\n \\param r the red value used to draw on the rendering target\n \\param g the green value used to draw on the rendering target\n \\param b the blue value used to draw on the rendering target\n \\param a the alpha value used to draw on the rendering target; usually\n          `SDL_ALPHA_OPAQUE` (255). Use SDL_SetRenderDrawBlendMode to\n          specify how the alpha channel is used\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetRenderDrawColor\n \\sa SDL_RenderClear\n \\sa SDL_RenderLine\n \\sa SDL_RenderLines\n \\sa SDL_RenderPoint\n \\sa SDL_RenderPoints\n \\sa SDL_RenderRect\n \\sa SDL_RenderRects\n \\sa SDL_RenderFillRect\n \\sa SDL_RenderFillRects"]
    pub fn SDL_SetRenderDrawColor(
        renderer: *mut SDL_Renderer,
        r: Uint8,
        g: Uint8,
        b: Uint8,
        a: Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the color used for drawing operations (Rect, Line and Clear).\n\n \\param renderer the rendering context\n \\param r a pointer filled in with the red value used to draw on the\n          rendering target\n \\param g a pointer filled in with the green value used to draw on the\n          rendering target\n \\param b a pointer filled in with the blue value used to draw on the\n          rendering target\n \\param a a pointer filled in with the alpha value used to draw on the\n          rendering target; usually `SDL_ALPHA_OPAQUE` (255)\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetRenderDrawColor"]
    pub fn SDL_GetRenderDrawColor(
        renderer: *mut SDL_Renderer,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
        a: *mut Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the blend mode used for drawing operations (Fill and Line).\n\n If the blend mode is not supported, the closest supported mode is chosen.\n\n \\param renderer the rendering context\n \\param blendMode the SDL_BlendMode to use for blending\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetRenderDrawBlendMode\n \\sa SDL_RenderLine\n \\sa SDL_RenderLines\n \\sa SDL_RenderPoint\n \\sa SDL_RenderPoints\n \\sa SDL_RenderRect\n \\sa SDL_RenderRects\n \\sa SDL_RenderFillRect\n \\sa SDL_RenderFillRects"]
    pub fn SDL_SetRenderDrawBlendMode(
        renderer: *mut SDL_Renderer,
        blendMode: SDL_BlendMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the blend mode used for drawing operations.\n\n \\param renderer the rendering context\n \\param blendMode a pointer filled in with the current SDL_BlendMode\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetRenderDrawBlendMode"]
    pub fn SDL_GetRenderDrawBlendMode(
        renderer: *mut SDL_Renderer,
        blendMode: *mut SDL_BlendMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Clear the current rendering target with the drawing color.\n\n This function clears the entire rendering target, ignoring the viewport and\n the clip rectangle.\n\n \\param renderer the rendering context\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_SetRenderDrawColor"]
    pub fn SDL_RenderClear(renderer: *mut SDL_Renderer) -> libc::c_int;
}
extern "C" {
    #[doc = " Draw a point on the current rendering target at subpixel precision.\n\n \\param renderer The renderer which should draw a point.\n \\param x The x coordinate of the point.\n \\param y The y coordinate of the point.\n \\returns 0 on success, or -1 on error\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_RenderPoint(renderer: *mut SDL_Renderer, x: f32, y: f32) -> libc::c_int;
}
extern "C" {
    #[doc = " Draw multiple points on the current rendering target at subpixel precision.\n\n \\param renderer The renderer which should draw multiple points.\n \\param points The points to draw\n \\param count The number of points to draw\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_RenderPoints(
        renderer: *mut SDL_Renderer,
        points: *const SDL_FPoint,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Draw a line on the current rendering target at subpixel precision.\n\n \\param renderer The renderer which should draw a line.\n \\param x1 The x coordinate of the start point.\n \\param y1 The y coordinate of the start point.\n \\param x2 The x coordinate of the end point.\n \\param y2 The y coordinate of the end point.\n \\returns 0 on success, or -1 on error\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_RenderLine(
        renderer: *mut SDL_Renderer,
        x1: f32,
        y1: f32,
        x2: f32,
        y2: f32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Draw a series of connected lines on the current rendering target at\n subpixel precision.\n\n \\param renderer The renderer which should draw multiple lines.\n \\param points The points along the lines\n \\param count The number of points, drawing count-1 lines\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_RenderLines(
        renderer: *mut SDL_Renderer,
        points: *const SDL_FPoint,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Draw a rectangle on the current rendering target at subpixel precision.\n\n \\param renderer The renderer which should draw a rectangle.\n \\param rect A pointer to the destination rectangle, or NULL to outline the\n             entire rendering target.\n \\returns 0 on success, or -1 on error\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_RenderRect(renderer: *mut SDL_Renderer, rect: *const SDL_FRect) -> libc::c_int;
}
extern "C" {
    #[doc = " Draw some number of rectangles on the current rendering target at subpixel\n precision.\n\n \\param renderer The renderer which should draw multiple rectangles.\n \\param rects A pointer to an array of destination rectangles.\n \\param count The number of rectangles.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_RenderRects(
        renderer: *mut SDL_Renderer,
        rects: *const SDL_FRect,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Fill a rectangle on the current rendering target with the drawing color at\n subpixel precision.\n\n \\param renderer The renderer which should fill a rectangle.\n \\param rect A pointer to the destination rectangle, or NULL for the entire\n             rendering target.\n \\returns 0 on success, or -1 on error\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_RenderFillRect(renderer: *mut SDL_Renderer, rect: *const SDL_FRect) -> libc::c_int;
}
extern "C" {
    #[doc = " Fill some number of rectangles on the current rendering target with the\n drawing color at subpixel precision.\n\n \\param renderer The renderer which should fill multiple rectangles.\n \\param rects A pointer to an array of destination rectangles.\n \\param count The number of rectangles.\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_RenderFillRects(
        renderer: *mut SDL_Renderer,
        rects: *const SDL_FRect,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Copy a portion of the texture to the current rendering target at subpixel\n precision.\n\n \\param renderer The renderer which should copy parts of a texture.\n \\param texture The source texture.\n \\param srcrect A pointer to the source rectangle, or NULL for the entire\n                texture.\n \\param dstrect A pointer to the destination rectangle, or NULL for the\n                entire rendering target.\n \\returns 0 on success, or -1 on error\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_RenderTexture(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        srcrect: *const SDL_FRect,
        dstrect: *const SDL_FRect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Copy a portion of the source texture to the current rendering target, with\n rotation and flipping, at subpixel precision.\n\n \\param renderer The renderer which should copy parts of a texture.\n \\param texture The source texture.\n \\param srcrect A pointer to the source rectangle, or NULL for the entire\n                texture.\n \\param dstrect A pointer to the destination rectangle, or NULL for the\n                entire rendering target.\n \\param angle An angle in degrees that indicates the rotation that will be\n              applied to dstrect, rotating it in a clockwise direction\n \\param center A pointer to a point indicating the point around which\n               dstrect will be rotated (if NULL, rotation will be done\n               around dstrect.w/2, dstrect.h/2).\n \\param flip An SDL_RendererFlip value stating which flipping actions should\n             be performed on the texture\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_RenderTextureRotated(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        srcrect: *const SDL_FRect,
        dstrect: *const SDL_FRect,
        angle: f64,
        center: *const SDL_FPoint,
        flip: SDL_RendererFlip,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Render a list of triangles, optionally using a texture and indices into the\n vertex array Color and alpha modulation is done per vertex\n (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).\n\n \\param renderer The rendering context.\n \\param texture (optional) The SDL texture to use.\n \\param vertices Vertices.\n \\param num_vertices Number of vertices.\n \\param indices (optional) An array of integer indices into the 'vertices'\n                array, if NULL all vertices will be rendered in sequential\n                order.\n \\param num_indices Number of indices.\n \\returns 0 on success, or -1 if the operation is not supported\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_RenderGeometryRaw\n \\sa SDL_Vertex"]
    pub fn SDL_RenderGeometry(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        vertices: *const SDL_Vertex,
        num_vertices: libc::c_int,
        indices: *const libc::c_int,
        num_indices: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Render a list of triangles, optionally using a texture and indices into the\n vertex arrays Color and alpha modulation is done per vertex\n (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).\n\n \\param renderer The rendering context.\n \\param texture (optional) The SDL texture to use.\n \\param xy Vertex positions\n \\param xy_stride Byte size to move from one element to the next element\n \\param color Vertex colors (as SDL_Color)\n \\param color_stride Byte size to move from one element to the next element\n \\param uv Vertex normalized texture coordinates\n \\param uv_stride Byte size to move from one element to the next element\n \\param num_vertices Number of vertices.\n \\param indices (optional) An array of indices into the 'vertices' arrays,\n                if NULL all vertices will be rendered in sequential order.\n \\param num_indices Number of indices.\n \\param size_indices Index size: 1 (byte), 2 (short), 4 (int)\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_RenderGeometry\n \\sa SDL_Vertex"]
    pub fn SDL_RenderGeometryRaw(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        xy: *const f32,
        xy_stride: libc::c_int,
        color: *const SDL_Color,
        color_stride: libc::c_int,
        uv: *const f32,
        uv_stride: libc::c_int,
        num_vertices: libc::c_int,
        indices: *const libc::c_void,
        num_indices: libc::c_int,
        size_indices: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Read pixels from the current rendering target to an array of pixels.\n\n **WARNING**: This is a very slow operation, and should not be used\n frequently. If you're using this on the main rendering target, it should be\n called after rendering and before SDL_RenderPresent().\n\n `pitch` specifies the number of bytes between rows in the destination\n `pixels` data. This allows you to write to a subrectangle or have padded\n rows in the destination. Generally, `pitch` should equal the number of\n pixels per row in the `pixels` data times the number of bytes per pixel,\n but it might contain additional padding (for example, 24bit RGB Windows\n Bitmap data pads all rows to multiples of 4 bytes).\n\n \\param renderer the rendering context\n \\param rect an SDL_Rect structure representing the area in pixels relative\n             to the to current viewport, or NULL for the entire viewport\n \\param format an SDL_PixelFormatEnum value of the desired format of the\n               pixel data, or 0 to use the format of the rendering target\n \\param pixels a pointer to the pixel data to copy into\n \\param pitch the pitch of the `pixels` parameter\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_RenderReadPixels(
        renderer: *mut SDL_Renderer,
        rect: *const SDL_Rect,
        format: Uint32,
        pixels: *mut libc::c_void,
        pitch: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Update the screen with any rendering performed since the previous call.\n\n SDL's rendering functions operate on a backbuffer; that is, calling a\n rendering function such as SDL_RenderLine() does not directly put a line on\n the screen, but rather updates the backbuffer. As such, you compose your\n entire scene and *present* the composed backbuffer to the screen as a\n complete picture.\n\n Therefore, when using SDL's rendering API, one does all drawing intended\n for the frame, and then calls this function once per frame to present the\n final drawing to the user.\n\n The backbuffer should be considered invalidated after each present; do not\n assume that previous contents will exist between frames. You are strongly\n encouraged to call SDL_RenderClear() to initialize the backbuffer before\n starting each new frame's drawing, even if you plan to overwrite every\n pixel.\n\n \\param renderer the rendering context\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\threadsafety You may only call this function on the main thread.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_RenderClear\n \\sa SDL_RenderLine\n \\sa SDL_RenderLines\n \\sa SDL_RenderPoint\n \\sa SDL_RenderPoints\n \\sa SDL_RenderRect\n \\sa SDL_RenderRects\n \\sa SDL_RenderFillRect\n \\sa SDL_RenderFillRects\n \\sa SDL_SetRenderDrawBlendMode\n \\sa SDL_SetRenderDrawColor"]
    pub fn SDL_RenderPresent(renderer: *mut SDL_Renderer) -> libc::c_int;
}
extern "C" {
    #[doc = " Destroy the specified texture.\n\n Passing NULL or an otherwise invalid texture will set the SDL error message\n to \"Invalid texture\".\n\n \\param texture the texture to destroy\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateTexture\n \\sa SDL_CreateTextureFromSurface"]
    pub fn SDL_DestroyTexture(texture: *mut SDL_Texture);
}
extern "C" {
    #[doc = " Destroy the rendering context for a window and free associated textures.\n\n If `renderer` is NULL, this function will return immediately after setting\n the SDL error message to \"Invalid renderer\". See SDL_GetError().\n\n \\param renderer the rendering context\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateRenderer"]
    pub fn SDL_DestroyRenderer(renderer: *mut SDL_Renderer);
}
extern "C" {
    #[doc = " Force the rendering context to flush any pending commands to the underlying\n rendering API.\n\n You do not need to (and in fact, shouldn't) call this function unless you\n are planning to call into OpenGL/Direct3D/Metal/whatever directly in\n addition to using an SDL_Renderer.\n\n This is for a very-specific case: if you are using SDL's render API, you\n asked for a specific renderer backend (OpenGL, Direct3D, etc), you set\n SDL_HINT_RENDER_BATCHING to \"1\", and you plan to make OpenGL/D3D/whatever\n calls in addition to SDL render API calls. If all of this applies, you\n should call SDL_RenderFlush() between calls to SDL's render API and the\n low-level API you're using in cooperation.\n\n In all other cases, you can ignore this function. This is only here to get\n maximum performance out of a specific situation. In all other cases, SDL\n will do the right thing, perhaps at a performance loss.\n\n This function is first available in SDL 2.0.10, and is not needed in 2.0.9\n and earlier, as earlier versions did not queue rendering commands at all,\n instead flushing them to the OS immediately.\n\n \\param renderer the rendering context\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_RenderFlush(renderer: *mut SDL_Renderer) -> libc::c_int;
}
extern "C" {
    #[doc = " Bind an OpenGL/ES/ES2 texture to the current context.\n\n This is for use with OpenGL instructions when rendering OpenGL primitives\n directly.\n\n If not NULL, `texw` and `texh` will be filled with the width and height\n values suitable for the provided texture. In most cases, both will be 1.0,\n however, on systems that support the GL_ARB_texture_rectangle extension,\n these values will actually be the pixel width and height used to create the\n texture, so this factor needs to be taken into account when providing\n texture coordinates to OpenGL.\n\n You need a renderer to create an SDL_Texture, therefore you can only use\n this function with an implicit OpenGL context from SDL_CreateRenderer(),\n not with your own OpenGL context. If you need control over your OpenGL\n context, you need to write your own texture-loading methods.\n\n Also note that SDL may upload RGB textures as BGR (or vice-versa), and\n re-order the color channels in the shaders phase, so the uploaded texture\n may have swapped color channels.\n\n \\param texture the texture to bind to the current OpenGL/ES/ES2 context\n \\param texw a pointer to a float value which will be filled with the\n             texture width or NULL if you don't need that value\n \\param texh a pointer to a float value which will be filled with the\n             texture height or NULL if you don't need that value\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GL_MakeCurrent\n \\sa SDL_GL_UnbindTexture"]
    pub fn SDL_GL_BindTexture(
        texture: *mut SDL_Texture,
        texw: *mut f32,
        texh: *mut f32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Unbind an OpenGL/ES/ES2 texture from the current context.\n\n See SDL_GL_BindTexture() for examples on how to use these functions\n\n \\param texture the texture to unbind from the current OpenGL/ES/ES2 context\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GL_BindTexture\n \\sa SDL_GL_MakeCurrent"]
    pub fn SDL_GL_UnbindTexture(texture: *mut SDL_Texture) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the CAMetalLayer associated with the given Metal renderer.\n\n This function returns `void *`, so SDL doesn't have to include Metal's\n headers, but it can be safely cast to a `CAMetalLayer *`.\n\n \\param renderer The renderer to query\n \\returns a `CAMetalLayer *` on success, or NULL if the renderer isn't a\n          Metal renderer\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetRenderMetalCommandEncoder"]
    pub fn SDL_GetRenderMetalLayer(renderer: *mut SDL_Renderer) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Get the Metal command encoder for the current frame\n\n This function returns `void *`, so SDL doesn't have to include Metal's\n headers, but it can be safely cast to an `id<MTLRenderCommandEncoder>`.\n\n Note that as of SDL 2.0.18, this will return NULL if Metal refuses to give\n SDL a drawable to render to, which might happen if the window is\n hidden/minimized/offscreen. This doesn't apply to command encoders for\n render targets, just the window's backbacker. Check your return values!\n\n \\param renderer The renderer to query\n \\returns an `id<MTLRenderCommandEncoder>` on success, or NULL if the\n          renderer isn't a Metal renderer or there was an error.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetRenderMetalLayer"]
    pub fn SDL_GetRenderMetalCommandEncoder(renderer: *mut SDL_Renderer) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Toggle VSync of the given renderer.\n\n \\param renderer The renderer to toggle\n \\param vsync 1 for on, 0 for off. All other values are reserved\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_SetRenderVSync(renderer: *mut SDL_Renderer, vsync: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Get VSync of the given renderer.\n\n \\param renderer The renderer to toggle\n \\param vsync an int filled with 1 for on, 0 for off. All other values are\n              reserved\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetRenderVSync(renderer: *mut SDL_Renderer, vsync: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Create a window that can be shaped with the specified dimensions and flags.\n\n \\param title The title of the window, in UTF-8 encoding.\n \\param w The width of the window.\n \\param h The height of the window.\n \\param flags The flags for the window, a mask of SDL_WINDOW_BORDERLESS with\n              any of the following: ::SDL_WINDOW_OPENGL,\n              ::SDL_WINDOW_MOUSE_GRABBED, ::SDL_WINDOW_HIDDEN,\n              ::SDL_WINDOW_RESIZABLE, ::SDL_WINDOW_MAXIMIZED,\n              ::SDL_WINDOW_MINIMIZED, ::SDL_WINDOW_BORDERLESS is always set,\n              and ::SDL_WINDOW_FULLSCREEN is always unset.\n \\returns the window created, or NULL if window creation failed.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_DestroyWindow"]
    pub fn SDL_CreateShapedWindow(
        title: *const libc::c_char,
        w: libc::c_int,
        h: libc::c_int,
        flags: Uint32,
    ) -> *mut SDL_Window;
}
extern "C" {
    #[doc = " Return whether the given window is a shaped window.\n\n \\param window The window to query for being shaped.\n \\returns SDL_TRUE if the window is a window that can be shaped, SDL_FALSE\n          if the window is unshaped or NULL.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_CreateShapedWindow"]
    pub fn SDL_IsShapedWindow(window: *const SDL_Window) -> SDL_bool;
}
#[repr(u32)]
#[doc = " \\brief An enum denoting the specific type of contents present in an SDL_WindowShapeParams union."]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum WindowShapeMode {
    #[doc = " \\brief The default mode, a binarized alpha cutoff of 1."]
    ShapeModeDefault = 0,
    #[doc = " \\brief A binarized alpha cutoff with a given integer value."]
    ShapeModeBinarizeAlpha = 1,
    #[doc = " \\brief A binarized alpha cutoff with a given integer value, but with the opposite comparison."]
    ShapeModeReverseBinarizeAlpha = 2,
    #[doc = " \\brief A color key is applied."]
    ShapeModeColorKey = 3,
}
#[doc = " \\brief A union containing parameters for shaped windows."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_WindowShapeParams {
    #[doc = " \\brief A cutoff alpha value for binarization of the window shape's alpha channel."]
    pub binarizationCutoff: Uint8,
    pub colorKey: SDL_Color,
}
#[test]
fn bindgen_test_layout_SDL_WindowShapeParams() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_WindowShapeParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_WindowShapeParams>(),
        4usize,
        concat!("Size of: ", stringify!(SDL_WindowShapeParams))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_WindowShapeParams>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_WindowShapeParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).binarizationCutoff) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowShapeParams),
            "::",
            stringify!(binarizationCutoff)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).colorKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowShapeParams),
            "::",
            stringify!(colorKey)
        )
    );
}
#[doc = " \\brief A struct that tags the SDL_WindowShapeParams union with an enum describing the type of its contents."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_WindowShapeMode {
    #[doc = " \\brief The mode of these window-shape parameters."]
    pub mode: WindowShapeMode,
    #[doc = " \\brief Window-shape parameters."]
    pub parameters: SDL_WindowShapeParams,
}
#[test]
fn bindgen_test_layout_SDL_WindowShapeMode() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_WindowShapeMode> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_WindowShapeMode>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_WindowShapeMode))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_WindowShapeMode>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_WindowShapeMode))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowShapeMode),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parameters) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowShapeMode),
            "::",
            stringify!(parameters)
        )
    );
}
extern "C" {
    #[doc = " Set the shape and parameters of a shaped window.\n\n \\param window The shaped window whose parameters should be set.\n \\param shape A surface encoding the desired shape for the window.\n \\param shape_mode The parameters to set for the shaped window.\n \\returns 0 on success, SDL_INVALID_SHAPE_ARGUMENT on an invalid shape\n          argument, or SDL_NONSHAPEABLE_WINDOW if the SDL_Window given does\n          not reference a valid shaped window.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_WindowShapeMode\n \\sa SDL_GetShapedWindowMode"]
    pub fn SDL_SetWindowShape(
        window: *mut SDL_Window,
        shape: *mut SDL_Surface,
        shape_mode: *mut SDL_WindowShapeMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the shape parameters of a shaped window.\n\n \\param window The shaped window whose parameters should be retrieved.\n \\param shape_mode An empty shape-mode structure to fill, or NULL to check\n                   whether the window has a shape.\n \\returns 0 if the window has a shape and, provided shape_mode was not NULL,\n          shape_mode has been filled with the mode data,\n          SDL_NONSHAPEABLE_WINDOW if the SDL_Window given is not a shaped\n          window, or SDL_WINDOW_LACKS_SHAPE if the SDL_Window given is a\n          shapeable window currently lacking a shape.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_WindowShapeMode\n \\sa SDL_SetWindowShape"]
    pub fn SDL_GetShapedWindowMode(
        window: *mut SDL_Window,
        shape_mode: *mut SDL_WindowShapeMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Sets the UNIX nice value for a thread.\n\n This uses setpriority() if possible, and RealtimeKit if available.\n\n \\param threadID the Unix thread ID to change priority of.\n \\param priority The new, Unix-specific, priority value.\n \\returns 0 on success, or -1 on error.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_LinuxSetThreadPriority(threadID: Sint64, priority: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Sets the priority (not nice level) and scheduling policy for a thread.\n\n This uses setpriority() if possible, and RealtimeKit if available.\n\n \\param threadID The Unix thread ID to change priority of.\n \\param sdlPriority The new SDL_ThreadPriority value.\n \\param schedPolicy The new scheduling policy (SCHED_FIFO, SCHED_RR,\n                    SCHED_OTHER, etc...)\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_LinuxSetThreadPriorityAndPolicy(
        threadID: Sint64,
        sdlPriority: libc::c_int,
        schedPolicy: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Query if the current device is a tablet.\n\n If SDL can't determine this, it will return SDL_FALSE.\n\n \\returns SDL_TRUE if the device is a tablet, SDL_FALSE otherwise.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_IsTablet() -> SDL_bool;
}
extern "C" {
    pub fn SDL_OnApplicationWillTerminate();
}
extern "C" {
    pub fn SDL_OnApplicationDidReceiveMemoryWarning();
}
extern "C" {
    pub fn SDL_OnApplicationWillResignActive();
}
extern "C" {
    pub fn SDL_OnApplicationDidEnterBackground();
}
extern "C" {
    pub fn SDL_OnApplicationWillEnterForeground();
}
extern "C" {
    pub fn SDL_OnApplicationDidBecomeActive();
}
extern "C" {
    #[doc = " Get the number of milliseconds since SDL library initialization.\n\n \\returns an unsigned 64-bit value representing the number of milliseconds\n          since the SDL library initialized.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetTicks() -> Uint64;
}
extern "C" {
    #[doc = " Get the number of nanoseconds since SDL library initialization.\n\n \\returns an unsigned 64-bit value representing the number of nanoseconds\n          since the SDL library initialized.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetTicksNS() -> Uint64;
}
extern "C" {
    #[doc = " Get the current value of the high resolution counter.\n\n This function is typically used for profiling.\n\n The counter values are only meaningful relative to each other. Differences\n between values can be converted to times by using\n SDL_GetPerformanceFrequency().\n\n \\returns the current counter value.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetPerformanceFrequency"]
    pub fn SDL_GetPerformanceCounter() -> Uint64;
}
extern "C" {
    #[doc = " Get the count per second of the high resolution counter.\n\n \\returns a platform-specific count per second.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetPerformanceCounter"]
    pub fn SDL_GetPerformanceFrequency() -> Uint64;
}
extern "C" {
    #[doc = " Wait a specified number of milliseconds before returning.\n\n This function waits a specified number of milliseconds before returning. It\n waits at least the specified time, but possibly longer due to OS\n scheduling.\n\n \\param ms the number of milliseconds to delay\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_Delay(ms: Uint32);
}
extern "C" {
    #[doc = " Wait a specified number of nanoseconds before returning.\n\n This function waits a specified number of nanoseconds before returning. It\n waits at least the specified time, but possibly longer due to OS\n scheduling.\n\n \\param ns the number of nanoseconds to delay\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_DelayNS(ns: Uint64);
}
#[doc = " Function prototype for the timer callback function.\n\n The callback function is passed the current timer interval and returns\n the next timer interval, in milliseconds. If the returned value is the same as the one\n passed in, the periodic alarm continues, otherwise a new alarm is\n scheduled. If the callback returns 0, the periodic alarm is cancelled."]
pub type SDL_TimerCallback = ::core::option::Option<
    unsafe extern "C" fn(interval: Uint32, param: *mut libc::c_void) -> Uint32,
>;
#[doc = " Definition of the timer ID type."]
pub type SDL_TimerID = libc::c_int;
extern "C" {
    #[doc = " Call a callback function at a future time.\n\n If you use this function, you must pass `SDL_INIT_TIMER` to SDL_Init().\n\n The callback function is passed the current timer interval and the user\n supplied parameter from the SDL_AddTimer() call and should return the next\n timer interval. If the value returned from the callback is 0, the timer is\n canceled.\n\n The callback is run on a separate thread.\n\n Timers take into account the amount of time it took to execute the\n callback. For example, if the callback took 250 ms to execute and returned\n 1000 (ms), the timer would only wait another 750 ms before its next\n iteration.\n\n Timing may be inexact due to OS scheduling. Be sure to note the current\n time with SDL_GetTicksNS() or SDL_GetPerformanceCounter() in case your\n callback needs to adjust for variances.\n\n \\param interval the timer delay, in milliseconds, passed to `callback`\n \\param callback the SDL_TimerCallback function to call when the specified\n                 `interval` elapses\n \\param param a pointer that is passed to `callback`\n \\returns a timer ID or 0 if an error occurs; call SDL_GetError() for more\n          information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_RemoveTimer"]
    pub fn SDL_AddTimer(
        interval: Uint32,
        callback: SDL_TimerCallback,
        param: *mut libc::c_void,
    ) -> SDL_TimerID;
}
extern "C" {
    #[doc = " Remove a timer created with SDL_AddTimer().\n\n \\param id the ID of the timer to remove\n \\returns SDL_TRUE if the timer is removed or SDL_FALSE if the timer wasn't\n          found.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_AddTimer"]
    pub fn SDL_RemoveTimer(id: SDL_TimerID) -> SDL_bool;
}
#[doc = " Information about the version of SDL in use.\n\n Represents the library's version as three levels: major revision\n (increments with massive changes, additions, and enhancements),\n minor revision (increments with backwards-compatible changes to the\n major revision), and patchlevel (increments with fixes to the minor\n revision).\n\n \\sa SDL_VERSION\n \\sa SDL_GetVersion"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_version {
    #[doc = "< major version"]
    pub major: Uint8,
    #[doc = "< minor version"]
    pub minor: Uint8,
    #[doc = "< update version"]
    pub patch: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_version() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_version> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_version>(),
        3usize,
        concat!("Size of: ", stringify!(SDL_version))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_version>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_version))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_version),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minor) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_version),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).patch) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_version),
            "::",
            stringify!(patch)
        )
    );
}
extern "C" {
    #[doc = " Get the version of SDL that is linked against your program.\n\n If you are linking to SDL dynamically, then it is possible that the current\n version will be different than the version you compiled against. This\n function returns the current version, while SDL_VERSION() is a macro that\n tells you what version you compiled with.\n\n This function may be called safely at any time, even before SDL_Init().\n\n \\param ver the SDL_version structure that contains the version information\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetRevision"]
    pub fn SDL_GetVersion(ver: *mut SDL_version) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the code revision of SDL that is linked against your program.\n\n This value is the revision of the code you are linked with and may be\n different from the code you are compiling with, which is found in the\n constant SDL_REVISION.\n\n The revision is arbitrary string (a hash value) uniquely identifying the\n exact revision of the SDL library in use, and is only useful in comparing\n against other revisions. It is NOT an incrementing number.\n\n If SDL wasn't built from a git repository with the appropriate tools, this\n will return an empty string.\n\n Prior to SDL 2.0.16, before development moved to GitHub, this returned a\n hash for a Mercurial repository.\n\n You shouldn't use this function for anything but logging it for debugging\n purposes. The string is not intended to be reliable in any way.\n\n \\returns an arbitrary string, uniquely identifying the exact revision of\n          the SDL library in use.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_GetVersion"]
    pub fn SDL_GetRevision() -> *const libc::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gbm_device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wl_display {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wl_egl_window {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wl_surface {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xdg_popup {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xdg_positioner {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xdg_surface {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xdg_toplevel {
    _unused: [u8; 0],
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = libc::c_ulong;
pub type ushort = libc::c_ushort;
pub type uint = libc::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = libc::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigset_t {
    pub __val: [libc::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::core::mem::MaybeUninit<__sigset_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::core::mem::MaybeUninit<timeval> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::core::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::core::mem::MaybeUninit<timespec> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = libc::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::core::mem::MaybeUninit<fd_set> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::core::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> libc::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> libc::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: libc::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: libc::c_uint,
    pub __high: libc::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::core::mem::MaybeUninit<__atomic_wide_counter> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::core::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_internal_list> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_internal_slist> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: libc::c_int,
    pub __count: libc::c_uint,
    pub __owner: libc::c_int,
    pub __nusers: libc::c_uint,
    pub __kind: libc::c_int,
    pub __spins: libc::c_short,
    pub __elision: libc::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_mutex_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: libc::c_uint,
    pub __writers: libc::c_uint,
    pub __wrphase_futex: libc::c_uint,
    pub __writers_futex: libc::c_uint,
    pub __pad3: libc::c_uint,
    pub __pad4: libc::c_uint,
    pub __cur_writer: libc::c_int,
    pub __shared: libc::c_int,
    pub __rwelision: libc::c_schar,
    pub __pad1: [libc::c_uchar; 7usize],
    pub __pad2: libc::c_ulong,
    pub __flags: libc::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [libc::c_uint; 2usize],
    pub __g_size: [libc::c_uint; 2usize],
    pub __g1_orig_size: libc::c_uint,
    pub __wrefs: libc::c_uint,
    pub __g_signals: [libc::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::core::mem::MaybeUninit<__pthread_cond_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = libc::c_uint;
pub type __thrd_t = libc::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __once_flag {
    pub __data: libc::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::core::mem::MaybeUninit<__once_flag> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::core::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = libc::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [libc::c_char; 4usize],
    pub __align: libc::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_mutexattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [libc::c_char; 4usize],
    pub __align: libc::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_condattr_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = libc::c_uint;
pub type pthread_once_t = libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [libc::c_char; 56usize],
    pub __align: libc::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_attr_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [libc::c_char; 40usize],
    pub __align: libc::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_mutex_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [libc::c_char; 48usize],
    pub __align: libc::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_cond_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [libc::c_char; 56usize],
    pub __align: libc::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_rwlock_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [libc::c_char; 8usize],
    pub __align: libc::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_rwlockattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [libc::c_char; 32usize],
    pub __align: libc::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_barrier_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [libc::c_char; 4usize],
    pub __align: libc::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_barrierattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type XID = libc::c_ulong;
pub type Mask = libc::c_ulong;
pub type Atom = libc::c_ulong;
pub type VisualID = libc::c_ulong;
pub type Time = libc::c_ulong;
pub type Window = XID;
pub type Drawable = XID;
pub type Font = XID;
pub type Pixmap = XID;
pub type Cursor = XID;
pub type Colormap = XID;
pub type GContext = XID;
pub type KeySym = XID;
pub type KeyCode = libc::c_uchar;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: libc::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::core::mem::MaybeUninit<max_align_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    pub fn _Xmblen(str_: *mut libc::c_char, len: libc::c_int) -> libc::c_int;
}
pub type XPointer = *mut libc::c_char;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XExtData {
    pub number: libc::c_int,
    pub next: *mut _XExtData,
    pub free_private:
        ::core::option::Option<unsafe extern "C" fn(extension: *mut _XExtData) -> libc::c_int>,
    pub private_data: XPointer,
}
#[test]
fn bindgen_test_layout__XExtData() {
    const UNINIT: ::core::mem::MaybeUninit<_XExtData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XExtData>(),
        32usize,
        concat!("Size of: ", stringify!(_XExtData))
    );
    assert_eq!(
        ::core::mem::align_of::<_XExtData>(),
        8usize,
        concat!("Alignment of ", stringify!(_XExtData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).number) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XExtData),
            "::",
            stringify!(number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XExtData),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free_private) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XExtData),
            "::",
            stringify!(free_private)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XExtData),
            "::",
            stringify!(private_data)
        )
    );
}
pub type XExtData = _XExtData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XExtCodes {
    pub extension: libc::c_int,
    pub major_opcode: libc::c_int,
    pub first_event: libc::c_int,
    pub first_error: libc::c_int,
}
#[test]
fn bindgen_test_layout_XExtCodes() {
    const UNINIT: ::core::mem::MaybeUninit<XExtCodes> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XExtCodes>(),
        16usize,
        concat!("Size of: ", stringify!(XExtCodes))
    );
    assert_eq!(
        ::core::mem::align_of::<XExtCodes>(),
        4usize,
        concat!("Alignment of ", stringify!(XExtCodes))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extension) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XExtCodes),
            "::",
            stringify!(extension)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).major_opcode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XExtCodes),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).first_event) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XExtCodes),
            "::",
            stringify!(first_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).first_error) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XExtCodes),
            "::",
            stringify!(first_error)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XPixmapFormatValues {
    pub depth: libc::c_int,
    pub bits_per_pixel: libc::c_int,
    pub scanline_pad: libc::c_int,
}
#[test]
fn bindgen_test_layout_XPixmapFormatValues() {
    const UNINIT: ::core::mem::MaybeUninit<XPixmapFormatValues> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XPixmapFormatValues>(),
        12usize,
        concat!("Size of: ", stringify!(XPixmapFormatValues))
    );
    assert_eq!(
        ::core::mem::align_of::<XPixmapFormatValues>(),
        4usize,
        concat!("Alignment of ", stringify!(XPixmapFormatValues))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XPixmapFormatValues),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bits_per_pixel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XPixmapFormatValues),
            "::",
            stringify!(bits_per_pixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scanline_pad) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XPixmapFormatValues),
            "::",
            stringify!(scanline_pad)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XGCValues {
    pub function: libc::c_int,
    pub plane_mask: libc::c_ulong,
    pub foreground: libc::c_ulong,
    pub background: libc::c_ulong,
    pub line_width: libc::c_int,
    pub line_style: libc::c_int,
    pub cap_style: libc::c_int,
    pub join_style: libc::c_int,
    pub fill_style: libc::c_int,
    pub fill_rule: libc::c_int,
    pub arc_mode: libc::c_int,
    pub tile: Pixmap,
    pub stipple: Pixmap,
    pub ts_x_origin: libc::c_int,
    pub ts_y_origin: libc::c_int,
    pub font: Font,
    pub subwindow_mode: libc::c_int,
    pub graphics_exposures: libc::c_int,
    pub clip_x_origin: libc::c_int,
    pub clip_y_origin: libc::c_int,
    pub clip_mask: Pixmap,
    pub dash_offset: libc::c_int,
    pub dashes: libc::c_char,
}
#[test]
fn bindgen_test_layout_XGCValues() {
    const UNINIT: ::core::mem::MaybeUninit<XGCValues> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XGCValues>(),
        128usize,
        concat!("Size of: ", stringify!(XGCValues))
    );
    assert_eq!(
        ::core::mem::align_of::<XGCValues>(),
        8usize,
        concat!("Alignment of ", stringify!(XGCValues))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).function) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).plane_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(plane_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).foreground) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(foreground)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).background) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(background)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).line_width) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(line_width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).line_style) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(line_style)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cap_style) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(cap_style)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).join_style) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(join_style)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fill_style) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(fill_style)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fill_rule) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(fill_rule)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arc_mode) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(arc_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tile) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(tile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stipple) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(stipple)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ts_x_origin) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(ts_x_origin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ts_y_origin) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(ts_y_origin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).font) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(font)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subwindow_mode) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(subwindow_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).graphics_exposures) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(graphics_exposures)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clip_x_origin) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(clip_x_origin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clip_y_origin) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(clip_y_origin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clip_mask) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(clip_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dash_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(dash_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dashes) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(XGCValues),
            "::",
            stringify!(dashes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XGC {
    _unused: [u8; 0],
}
pub type GC = *mut _XGC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Visual {
    pub ext_data: *mut XExtData,
    pub visualid: VisualID,
    pub class: libc::c_int,
    pub red_mask: libc::c_ulong,
    pub green_mask: libc::c_ulong,
    pub blue_mask: libc::c_ulong,
    pub bits_per_rgb: libc::c_int,
    pub map_entries: libc::c_int,
}
#[test]
fn bindgen_test_layout_Visual() {
    const UNINIT: ::core::mem::MaybeUninit<Visual> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Visual>(),
        56usize,
        concat!("Size of: ", stringify!(Visual))
    );
    assert_eq!(
        ::core::mem::align_of::<Visual>(),
        8usize,
        concat!("Alignment of ", stringify!(Visual))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ext_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(ext_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).visualid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(visualid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).class) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(class)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).red_mask) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(red_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).green_mask) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(green_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blue_mask) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(blue_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bits_per_rgb) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(bits_per_rgb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).map_entries) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(Visual),
            "::",
            stringify!(map_entries)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Depth {
    pub depth: libc::c_int,
    pub nvisuals: libc::c_int,
    pub visuals: *mut Visual,
}
#[test]
fn bindgen_test_layout_Depth() {
    const UNINIT: ::core::mem::MaybeUninit<Depth> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Depth>(),
        16usize,
        concat!("Size of: ", stringify!(Depth))
    );
    assert_eq!(
        ::core::mem::align_of::<Depth>(),
        8usize,
        concat!("Alignment of ", stringify!(Depth))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Depth),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvisuals) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Depth),
            "::",
            stringify!(nvisuals)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).visuals) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Depth),
            "::",
            stringify!(visuals)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XDisplay {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Screen {
    pub ext_data: *mut XExtData,
    pub display: *mut _XDisplay,
    pub root: Window,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub mwidth: libc::c_int,
    pub mheight: libc::c_int,
    pub ndepths: libc::c_int,
    pub depths: *mut Depth,
    pub root_depth: libc::c_int,
    pub root_visual: *mut Visual,
    pub default_gc: GC,
    pub cmap: Colormap,
    pub white_pixel: libc::c_ulong,
    pub black_pixel: libc::c_ulong,
    pub max_maps: libc::c_int,
    pub min_maps: libc::c_int,
    pub backing_store: libc::c_int,
    pub save_unders: libc::c_int,
    pub root_input_mask: libc::c_long,
}
#[test]
fn bindgen_test_layout_Screen() {
    const UNINIT: ::core::mem::MaybeUninit<Screen> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Screen>(),
        128usize,
        concat!("Size of: ", stringify!(Screen))
    );
    assert_eq!(
        ::core::mem::align_of::<Screen>(),
        8usize,
        concat!("Alignment of ", stringify!(Screen))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ext_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(ext_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mwidth) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(mwidth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mheight) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(mheight)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ndepths) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(ndepths)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).depths) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(depths)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).root_depth) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(root_depth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).root_visual) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(root_visual)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).default_gc) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(default_gc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cmap) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).white_pixel) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(white_pixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).black_pixel) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(black_pixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_maps) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(max_maps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).min_maps) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(min_maps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).backing_store) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(backing_store)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).save_unders) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(save_unders)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).root_input_mask) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Screen),
            "::",
            stringify!(root_input_mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ScreenFormat {
    pub ext_data: *mut XExtData,
    pub depth: libc::c_int,
    pub bits_per_pixel: libc::c_int,
    pub scanline_pad: libc::c_int,
}
#[test]
fn bindgen_test_layout_ScreenFormat() {
    const UNINIT: ::core::mem::MaybeUninit<ScreenFormat> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ScreenFormat>(),
        24usize,
        concat!("Size of: ", stringify!(ScreenFormat))
    );
    assert_eq!(
        ::core::mem::align_of::<ScreenFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(ScreenFormat))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ext_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ScreenFormat),
            "::",
            stringify!(ext_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ScreenFormat),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bits_per_pixel) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ScreenFormat),
            "::",
            stringify!(bits_per_pixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scanline_pad) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ScreenFormat),
            "::",
            stringify!(scanline_pad)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XSetWindowAttributes {
    pub background_pixmap: Pixmap,
    pub background_pixel: libc::c_ulong,
    pub border_pixmap: Pixmap,
    pub border_pixel: libc::c_ulong,
    pub bit_gravity: libc::c_int,
    pub win_gravity: libc::c_int,
    pub backing_store: libc::c_int,
    pub backing_planes: libc::c_ulong,
    pub backing_pixel: libc::c_ulong,
    pub save_under: libc::c_int,
    pub event_mask: libc::c_long,
    pub do_not_propagate_mask: libc::c_long,
    pub override_redirect: libc::c_int,
    pub colormap: Colormap,
    pub cursor: Cursor,
}
#[test]
fn bindgen_test_layout_XSetWindowAttributes() {
    const UNINIT: ::core::mem::MaybeUninit<XSetWindowAttributes> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XSetWindowAttributes>(),
        112usize,
        concat!("Size of: ", stringify!(XSetWindowAttributes))
    );
    assert_eq!(
        ::core::mem::align_of::<XSetWindowAttributes>(),
        8usize,
        concat!("Alignment of ", stringify!(XSetWindowAttributes))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).background_pixmap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(background_pixmap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).background_pixel) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(background_pixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).border_pixmap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(border_pixmap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).border_pixel) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(border_pixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit_gravity) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(bit_gravity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).win_gravity) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(win_gravity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).backing_store) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(backing_store)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).backing_planes) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(backing_planes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).backing_pixel) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(backing_pixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).save_under) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(save_under)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_mask) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).do_not_propagate_mask) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(do_not_propagate_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).override_redirect) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).colormap) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cursor) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(XSetWindowAttributes),
            "::",
            stringify!(cursor)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XWindowAttributes {
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub border_width: libc::c_int,
    pub depth: libc::c_int,
    pub visual: *mut Visual,
    pub root: Window,
    pub class: libc::c_int,
    pub bit_gravity: libc::c_int,
    pub win_gravity: libc::c_int,
    pub backing_store: libc::c_int,
    pub backing_planes: libc::c_ulong,
    pub backing_pixel: libc::c_ulong,
    pub save_under: libc::c_int,
    pub colormap: Colormap,
    pub map_installed: libc::c_int,
    pub map_state: libc::c_int,
    pub all_event_masks: libc::c_long,
    pub your_event_mask: libc::c_long,
    pub do_not_propagate_mask: libc::c_long,
    pub override_redirect: libc::c_int,
    pub screen: *mut Screen,
}
#[test]
fn bindgen_test_layout_XWindowAttributes() {
    const UNINIT: ::core::mem::MaybeUninit<XWindowAttributes> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XWindowAttributes>(),
        136usize,
        concat!("Size of: ", stringify!(XWindowAttributes))
    );
    assert_eq!(
        ::core::mem::align_of::<XWindowAttributes>(),
        8usize,
        concat!("Alignment of ", stringify!(XWindowAttributes))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).border_width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).visual) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(visual)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).class) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(class)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit_gravity) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(bit_gravity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).win_gravity) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(win_gravity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).backing_store) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(backing_store)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).backing_planes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(backing_planes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).backing_pixel) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(backing_pixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).save_under) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(save_under)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).colormap) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).map_installed) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(map_installed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).map_state) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(map_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).all_event_masks) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(all_event_masks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).your_event_mask) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(your_event_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).do_not_propagate_mask) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(do_not_propagate_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).override_redirect) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).screen) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowAttributes),
            "::",
            stringify!(screen)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XHostAddress {
    pub family: libc::c_int,
    pub length: libc::c_int,
    pub address: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_XHostAddress() {
    const UNINIT: ::core::mem::MaybeUninit<XHostAddress> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XHostAddress>(),
        16usize,
        concat!("Size of: ", stringify!(XHostAddress))
    );
    assert_eq!(
        ::core::mem::align_of::<XHostAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(XHostAddress))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XHostAddress),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XHostAddress),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XHostAddress),
            "::",
            stringify!(address)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XServerInterpretedAddress {
    pub typelength: libc::c_int,
    pub valuelength: libc::c_int,
    pub type_: *mut libc::c_char,
    pub value: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_XServerInterpretedAddress() {
    const UNINIT: ::core::mem::MaybeUninit<XServerInterpretedAddress> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XServerInterpretedAddress>(),
        24usize,
        concat!("Size of: ", stringify!(XServerInterpretedAddress))
    );
    assert_eq!(
        ::core::mem::align_of::<XServerInterpretedAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(XServerInterpretedAddress))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).typelength) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XServerInterpretedAddress),
            "::",
            stringify!(typelength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).valuelength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XServerInterpretedAddress),
            "::",
            stringify!(valuelength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XServerInterpretedAddress),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XServerInterpretedAddress),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XImage {
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub xoffset: libc::c_int,
    pub format: libc::c_int,
    pub data: *mut libc::c_char,
    pub byte_order: libc::c_int,
    pub bitmap_unit: libc::c_int,
    pub bitmap_bit_order: libc::c_int,
    pub bitmap_pad: libc::c_int,
    pub depth: libc::c_int,
    pub bytes_per_line: libc::c_int,
    pub bits_per_pixel: libc::c_int,
    pub red_mask: libc::c_ulong,
    pub green_mask: libc::c_ulong,
    pub blue_mask: libc::c_ulong,
    pub obdata: XPointer,
    pub f: _XImage_funcs,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XImage_funcs {
    pub create_image: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _XDisplay,
            arg2: *mut Visual,
            arg3: libc::c_uint,
            arg4: libc::c_int,
            arg5: libc::c_int,
            arg6: *mut libc::c_char,
            arg7: libc::c_uint,
            arg8: libc::c_uint,
            arg9: libc::c_int,
            arg10: libc::c_int,
        ) -> *mut _XImage,
    >,
    pub destroy_image:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut _XImage) -> libc::c_int>,
    pub get_pixel: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _XImage,
            arg2: libc::c_int,
            arg3: libc::c_int,
        ) -> libc::c_ulong,
    >,
    pub put_pixel: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _XImage,
            arg2: libc::c_int,
            arg3: libc::c_int,
            arg4: libc::c_ulong,
        ) -> libc::c_int,
    >,
    pub sub_image: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _XImage,
            arg2: libc::c_int,
            arg3: libc::c_int,
            arg4: libc::c_uint,
            arg5: libc::c_uint,
        ) -> *mut _XImage,
    >,
    pub add_pixel: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _XImage, arg2: libc::c_long) -> libc::c_int,
    >,
}
#[test]
fn bindgen_test_layout__XImage_funcs() {
    const UNINIT: ::core::mem::MaybeUninit<_XImage_funcs> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XImage_funcs>(),
        48usize,
        concat!("Size of: ", stringify!(_XImage_funcs))
    );
    assert_eq!(
        ::core::mem::align_of::<_XImage_funcs>(),
        8usize,
        concat!("Alignment of ", stringify!(_XImage_funcs))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).create_image) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage_funcs),
            "::",
            stringify!(create_image)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).destroy_image) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage_funcs),
            "::",
            stringify!(destroy_image)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_pixel) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage_funcs),
            "::",
            stringify!(get_pixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).put_pixel) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage_funcs),
            "::",
            stringify!(put_pixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sub_image) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage_funcs),
            "::",
            stringify!(sub_image)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).add_pixel) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage_funcs),
            "::",
            stringify!(add_pixel)
        )
    );
}
#[test]
fn bindgen_test_layout__XImage() {
    const UNINIT: ::core::mem::MaybeUninit<_XImage> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XImage>(),
        136usize,
        concat!("Size of: ", stringify!(_XImage))
    );
    assert_eq!(
        ::core::mem::align_of::<_XImage>(),
        8usize,
        concat!("Alignment of ", stringify!(_XImage))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xoffset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(xoffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).byte_order) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(byte_order)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitmap_unit) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(bitmap_unit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitmap_bit_order) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(bitmap_bit_order)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitmap_pad) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(bitmap_pad)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes_per_line) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(bytes_per_line)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bits_per_pixel) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(bits_per_pixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).red_mask) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(red_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).green_mask) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(green_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blue_mask) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(blue_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).obdata) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(obdata)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_XImage),
            "::",
            stringify!(f)
        )
    );
}
pub type XImage = _XImage;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XWindowChanges {
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub border_width: libc::c_int,
    pub sibling: Window,
    pub stack_mode: libc::c_int,
}
#[test]
fn bindgen_test_layout_XWindowChanges() {
    const UNINIT: ::core::mem::MaybeUninit<XWindowChanges> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XWindowChanges>(),
        40usize,
        concat!("Size of: ", stringify!(XWindowChanges))
    );
    assert_eq!(
        ::core::mem::align_of::<XWindowChanges>(),
        8usize,
        concat!("Alignment of ", stringify!(XWindowChanges))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowChanges),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowChanges),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowChanges),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowChanges),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).border_width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowChanges),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sibling) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowChanges),
            "::",
            stringify!(sibling)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stack_mode) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XWindowChanges),
            "::",
            stringify!(stack_mode)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XColor {
    pub pixel: libc::c_ulong,
    pub red: libc::c_ushort,
    pub green: libc::c_ushort,
    pub blue: libc::c_ushort,
    pub flags: libc::c_char,
    pub pad: libc::c_char,
}
#[test]
fn bindgen_test_layout_XColor() {
    const UNINIT: ::core::mem::MaybeUninit<XColor> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XColor>(),
        16usize,
        concat!("Size of: ", stringify!(XColor))
    );
    assert_eq!(
        ::core::mem::align_of::<XColor>(),
        8usize,
        concat!("Alignment of ", stringify!(XColor))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pixel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XColor),
            "::",
            stringify!(pixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).red) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XColor),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).green) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(XColor),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blue) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XColor),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(XColor),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(XColor),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XSegment {
    pub x1: libc::c_short,
    pub y1: libc::c_short,
    pub x2: libc::c_short,
    pub y2: libc::c_short,
}
#[test]
fn bindgen_test_layout_XSegment() {
    const UNINIT: ::core::mem::MaybeUninit<XSegment> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XSegment>(),
        8usize,
        concat!("Size of: ", stringify!(XSegment))
    );
    assert_eq!(
        ::core::mem::align_of::<XSegment>(),
        2usize,
        concat!("Alignment of ", stringify!(XSegment))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XSegment),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y1) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(XSegment),
            "::",
            stringify!(y1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XSegment),
            "::",
            stringify!(x2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y2) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(XSegment),
            "::",
            stringify!(y2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XPoint {
    pub x: libc::c_short,
    pub y: libc::c_short,
}
#[test]
fn bindgen_test_layout_XPoint() {
    const UNINIT: ::core::mem::MaybeUninit<XPoint> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XPoint>(),
        4usize,
        concat!("Size of: ", stringify!(XPoint))
    );
    assert_eq!(
        ::core::mem::align_of::<XPoint>(),
        2usize,
        concat!("Alignment of ", stringify!(XPoint))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(XPoint), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        2usize,
        concat!("Offset of field: ", stringify!(XPoint), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XRectangle {
    pub x: libc::c_short,
    pub y: libc::c_short,
    pub width: libc::c_ushort,
    pub height: libc::c_ushort,
}
#[test]
fn bindgen_test_layout_XRectangle() {
    const UNINIT: ::core::mem::MaybeUninit<XRectangle> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XRectangle>(),
        8usize,
        concat!("Size of: ", stringify!(XRectangle))
    );
    assert_eq!(
        ::core::mem::align_of::<XRectangle>(),
        2usize,
        concat!("Alignment of ", stringify!(XRectangle))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XRectangle),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(XRectangle),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XRectangle),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(XRectangle),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XArc {
    pub x: libc::c_short,
    pub y: libc::c_short,
    pub width: libc::c_ushort,
    pub height: libc::c_ushort,
    pub angle1: libc::c_short,
    pub angle2: libc::c_short,
}
#[test]
fn bindgen_test_layout_XArc() {
    const UNINIT: ::core::mem::MaybeUninit<XArc> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XArc>(),
        12usize,
        concat!("Size of: ", stringify!(XArc))
    );
    assert_eq!(
        ::core::mem::align_of::<XArc>(),
        2usize,
        concat!("Alignment of ", stringify!(XArc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(XArc), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        2usize,
        concat!("Offset of field: ", stringify!(XArc), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XArc),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(XArc),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).angle1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XArc),
            "::",
            stringify!(angle1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).angle2) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(XArc),
            "::",
            stringify!(angle2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XKeyboardControl {
    pub key_click_percent: libc::c_int,
    pub bell_percent: libc::c_int,
    pub bell_pitch: libc::c_int,
    pub bell_duration: libc::c_int,
    pub led: libc::c_int,
    pub led_mode: libc::c_int,
    pub key: libc::c_int,
    pub auto_repeat_mode: libc::c_int,
}
#[test]
fn bindgen_test_layout_XKeyboardControl() {
    const UNINIT: ::core::mem::MaybeUninit<XKeyboardControl> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XKeyboardControl>(),
        32usize,
        concat!("Size of: ", stringify!(XKeyboardControl))
    );
    assert_eq!(
        ::core::mem::align_of::<XKeyboardControl>(),
        4usize,
        concat!("Alignment of ", stringify!(XKeyboardControl))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_click_percent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardControl),
            "::",
            stringify!(key_click_percent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bell_percent) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardControl),
            "::",
            stringify!(bell_percent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bell_pitch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardControl),
            "::",
            stringify!(bell_pitch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bell_duration) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardControl),
            "::",
            stringify!(bell_duration)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).led) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardControl),
            "::",
            stringify!(led)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).led_mode) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardControl),
            "::",
            stringify!(led_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardControl),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).auto_repeat_mode) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardControl),
            "::",
            stringify!(auto_repeat_mode)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XKeyboardState {
    pub key_click_percent: libc::c_int,
    pub bell_percent: libc::c_int,
    pub bell_pitch: libc::c_uint,
    pub bell_duration: libc::c_uint,
    pub led_mask: libc::c_ulong,
    pub global_auto_repeat: libc::c_int,
    pub auto_repeats: [libc::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_XKeyboardState() {
    const UNINIT: ::core::mem::MaybeUninit<XKeyboardState> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XKeyboardState>(),
        64usize,
        concat!("Size of: ", stringify!(XKeyboardState))
    );
    assert_eq!(
        ::core::mem::align_of::<XKeyboardState>(),
        8usize,
        concat!("Alignment of ", stringify!(XKeyboardState))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_click_percent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardState),
            "::",
            stringify!(key_click_percent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bell_percent) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardState),
            "::",
            stringify!(bell_percent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bell_pitch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardState),
            "::",
            stringify!(bell_pitch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bell_duration) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardState),
            "::",
            stringify!(bell_duration)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).led_mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardState),
            "::",
            stringify!(led_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).global_auto_repeat) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardState),
            "::",
            stringify!(global_auto_repeat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).auto_repeats) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyboardState),
            "::",
            stringify!(auto_repeats)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XTimeCoord {
    pub time: Time,
    pub x: libc::c_short,
    pub y: libc::c_short,
}
#[test]
fn bindgen_test_layout_XTimeCoord() {
    const UNINIT: ::core::mem::MaybeUninit<XTimeCoord> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XTimeCoord>(),
        16usize,
        concat!("Size of: ", stringify!(XTimeCoord))
    );
    assert_eq!(
        ::core::mem::align_of::<XTimeCoord>(),
        8usize,
        concat!("Alignment of ", stringify!(XTimeCoord))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XTimeCoord),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XTimeCoord),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(XTimeCoord),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XModifierKeymap {
    pub max_keypermod: libc::c_int,
    pub modifiermap: *mut KeyCode,
}
#[test]
fn bindgen_test_layout_XModifierKeymap() {
    const UNINIT: ::core::mem::MaybeUninit<XModifierKeymap> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XModifierKeymap>(),
        16usize,
        concat!("Size of: ", stringify!(XModifierKeymap))
    );
    assert_eq!(
        ::core::mem::align_of::<XModifierKeymap>(),
        8usize,
        concat!("Alignment of ", stringify!(XModifierKeymap))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_keypermod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XModifierKeymap),
            "::",
            stringify!(max_keypermod)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).modifiermap) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XModifierKeymap),
            "::",
            stringify!(modifiermap)
        )
    );
}
pub type Display = _XDisplay;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XPrivate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XrmHashBucketRec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _bindgen_ty_1 {
    pub ext_data: *mut XExtData,
    pub private1: *mut _XPrivate,
    pub fd: libc::c_int,
    pub private2: libc::c_int,
    pub proto_major_version: libc::c_int,
    pub proto_minor_version: libc::c_int,
    pub vendor: *mut libc::c_char,
    pub private3: XID,
    pub private4: XID,
    pub private5: XID,
    pub private6: libc::c_int,
    pub resource_alloc: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _XDisplay) -> XID>,
    pub byte_order: libc::c_int,
    pub bitmap_unit: libc::c_int,
    pub bitmap_pad: libc::c_int,
    pub bitmap_bit_order: libc::c_int,
    pub nformats: libc::c_int,
    pub pixmap_format: *mut ScreenFormat,
    pub private8: libc::c_int,
    pub release: libc::c_int,
    pub private9: *mut _XPrivate,
    pub private10: *mut _XPrivate,
    pub qlen: libc::c_int,
    pub last_request_read: libc::c_ulong,
    pub request: libc::c_ulong,
    pub private11: XPointer,
    pub private12: XPointer,
    pub private13: XPointer,
    pub private14: XPointer,
    pub max_request_size: libc::c_uint,
    pub db: *mut _XrmHashBucketRec,
    pub private15:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut _XDisplay) -> libc::c_int>,
    pub display_name: *mut libc::c_char,
    pub default_screen: libc::c_int,
    pub nscreens: libc::c_int,
    pub screens: *mut Screen,
    pub motion_buffer: libc::c_ulong,
    pub private16: libc::c_ulong,
    pub min_keycode: libc::c_int,
    pub max_keycode: libc::c_int,
    pub private17: XPointer,
    pub private18: XPointer,
    pub private19: libc::c_int,
    pub xdefaults: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_bindgen_ty_1>(),
        296usize,
        concat!("Size of: ", stringify!(_bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ext_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(ext_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private2) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).proto_major_version) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(proto_major_version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).proto_minor_version) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(proto_minor_version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vendor) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(vendor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private3) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private4) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private5) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private6) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resource_alloc) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(resource_alloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).byte_order) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(byte_order)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitmap_unit) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(bitmap_unit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitmap_pad) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(bitmap_pad)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitmap_bit_order) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(bitmap_bit_order)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nformats) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(nformats)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pixmap_format) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(pixmap_format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private8) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private9) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private9)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private10) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private10)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).qlen) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(qlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last_request_read) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(last_request_read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).request) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private11) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private11)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private12) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private12)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private13) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private13)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private14) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private14)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_request_size) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(max_request_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).db) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(db)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private15) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private15)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display_name) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(display_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).default_screen) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(default_screen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nscreens) as usize - ptr as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(nscreens)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).screens) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(screens)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).motion_buffer) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(motion_buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private16) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private16)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).min_keycode) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(min_keycode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_keycode) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(max_keycode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private17) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private17)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private18) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private18)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private19) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(private19)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xdefaults) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(xdefaults)
        )
    );
}
pub type _XPrivDisplay = *mut _bindgen_ty_1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XKeyEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub root: Window,
    pub subwindow: Window,
    pub time: Time,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub x_root: libc::c_int,
    pub y_root: libc::c_int,
    pub state: libc::c_uint,
    pub keycode: libc::c_uint,
    pub same_screen: libc::c_int,
}
#[test]
fn bindgen_test_layout_XKeyEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XKeyEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XKeyEvent>(),
        96usize,
        concat!("Size of: ", stringify!(XKeyEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XKeyEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XKeyEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subwindow) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(subwindow)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x_root) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(x_root)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y_root) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(y_root)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keycode) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(keycode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).same_screen) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeyEvent),
            "::",
            stringify!(same_screen)
        )
    );
}
pub type XKeyPressedEvent = XKeyEvent;
pub type XKeyReleasedEvent = XKeyEvent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XButtonEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub root: Window,
    pub subwindow: Window,
    pub time: Time,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub x_root: libc::c_int,
    pub y_root: libc::c_int,
    pub state: libc::c_uint,
    pub button: libc::c_uint,
    pub same_screen: libc::c_int,
}
#[test]
fn bindgen_test_layout_XButtonEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XButtonEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XButtonEvent>(),
        96usize,
        concat!("Size of: ", stringify!(XButtonEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XButtonEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XButtonEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subwindow) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(subwindow)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x_root) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(x_root)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y_root) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(y_root)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).button) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).same_screen) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XButtonEvent),
            "::",
            stringify!(same_screen)
        )
    );
}
pub type XButtonPressedEvent = XButtonEvent;
pub type XButtonReleasedEvent = XButtonEvent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XMotionEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub root: Window,
    pub subwindow: Window,
    pub time: Time,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub x_root: libc::c_int,
    pub y_root: libc::c_int,
    pub state: libc::c_uint,
    pub is_hint: libc::c_char,
    pub same_screen: libc::c_int,
}
#[test]
fn bindgen_test_layout_XMotionEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XMotionEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XMotionEvent>(),
        96usize,
        concat!("Size of: ", stringify!(XMotionEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XMotionEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XMotionEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subwindow) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(subwindow)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x_root) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(x_root)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y_root) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(y_root)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_hint) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(is_hint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).same_screen) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XMotionEvent),
            "::",
            stringify!(same_screen)
        )
    );
}
pub type XPointerMovedEvent = XMotionEvent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XCrossingEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub root: Window,
    pub subwindow: Window,
    pub time: Time,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub x_root: libc::c_int,
    pub y_root: libc::c_int,
    pub mode: libc::c_int,
    pub detail: libc::c_int,
    pub same_screen: libc::c_int,
    pub focus: libc::c_int,
    pub state: libc::c_uint,
}
#[test]
fn bindgen_test_layout_XCrossingEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XCrossingEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XCrossingEvent>(),
        104usize,
        concat!("Size of: ", stringify!(XCrossingEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XCrossingEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XCrossingEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subwindow) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(subwindow)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x_root) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(x_root)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y_root) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(y_root)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).detail) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).same_screen) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(same_screen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).focus) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(focus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(XCrossingEvent),
            "::",
            stringify!(state)
        )
    );
}
pub type XEnterWindowEvent = XCrossingEvent;
pub type XLeaveWindowEvent = XCrossingEvent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XFocusChangeEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub mode: libc::c_int,
    pub detail: libc::c_int,
}
#[test]
fn bindgen_test_layout_XFocusChangeEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XFocusChangeEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XFocusChangeEvent>(),
        48usize,
        concat!("Size of: ", stringify!(XFocusChangeEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XFocusChangeEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XFocusChangeEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XFocusChangeEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XFocusChangeEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XFocusChangeEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XFocusChangeEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XFocusChangeEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XFocusChangeEvent),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).detail) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XFocusChangeEvent),
            "::",
            stringify!(detail)
        )
    );
}
pub type XFocusInEvent = XFocusChangeEvent;
pub type XFocusOutEvent = XFocusChangeEvent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XKeymapEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub key_vector: [libc::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_XKeymapEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XKeymapEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XKeymapEvent>(),
        72usize,
        concat!("Size of: ", stringify!(XKeymapEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XKeymapEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XKeymapEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeymapEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeymapEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeymapEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeymapEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeymapEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_vector) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XKeymapEvent),
            "::",
            stringify!(key_vector)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XExposeEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub count: libc::c_int,
}
#[test]
fn bindgen_test_layout_XExposeEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XExposeEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XExposeEvent>(),
        64usize,
        concat!("Size of: ", stringify!(XExposeEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XExposeEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XExposeEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XExposeEvent),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XGraphicsExposeEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub drawable: Drawable,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub count: libc::c_int,
    pub major_code: libc::c_int,
    pub minor_code: libc::c_int,
}
#[test]
fn bindgen_test_layout_XGraphicsExposeEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XGraphicsExposeEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XGraphicsExposeEvent>(),
        72usize,
        concat!("Size of: ", stringify!(XGraphicsExposeEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XGraphicsExposeEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XGraphicsExposeEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).drawable) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).major_code) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(major_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minor_code) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XGraphicsExposeEvent),
            "::",
            stringify!(minor_code)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XNoExposeEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub drawable: Drawable,
    pub major_code: libc::c_int,
    pub minor_code: libc::c_int,
}
#[test]
fn bindgen_test_layout_XNoExposeEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XNoExposeEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XNoExposeEvent>(),
        48usize,
        concat!("Size of: ", stringify!(XNoExposeEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XNoExposeEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XNoExposeEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XNoExposeEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XNoExposeEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XNoExposeEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XNoExposeEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).drawable) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XNoExposeEvent),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).major_code) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XNoExposeEvent),
            "::",
            stringify!(major_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minor_code) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XNoExposeEvent),
            "::",
            stringify!(minor_code)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XVisibilityEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub state: libc::c_int,
}
#[test]
fn bindgen_test_layout_XVisibilityEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XVisibilityEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XVisibilityEvent>(),
        48usize,
        concat!("Size of: ", stringify!(XVisibilityEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XVisibilityEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XVisibilityEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XVisibilityEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XVisibilityEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XVisibilityEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XVisibilityEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XVisibilityEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XVisibilityEvent),
            "::",
            stringify!(state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XCreateWindowEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub parent: Window,
    pub window: Window,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub border_width: libc::c_int,
    pub override_redirect: libc::c_int,
}
#[test]
fn bindgen_test_layout_XCreateWindowEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XCreateWindowEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XCreateWindowEvent>(),
        72usize,
        concat!("Size of: ", stringify!(XCreateWindowEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XCreateWindowEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XCreateWindowEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).border_width) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).override_redirect) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(XCreateWindowEvent),
            "::",
            stringify!(override_redirect)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XDestroyWindowEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
}
#[test]
fn bindgen_test_layout_XDestroyWindowEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XDestroyWindowEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XDestroyWindowEvent>(),
        48usize,
        concat!("Size of: ", stringify!(XDestroyWindowEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XDestroyWindowEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XDestroyWindowEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XDestroyWindowEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XDestroyWindowEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XDestroyWindowEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XDestroyWindowEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XDestroyWindowEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XDestroyWindowEvent),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XUnmapEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub from_configure: libc::c_int,
}
#[test]
fn bindgen_test_layout_XUnmapEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XUnmapEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XUnmapEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XUnmapEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XUnmapEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XUnmapEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XUnmapEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XUnmapEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XUnmapEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XUnmapEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XUnmapEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XUnmapEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).from_configure) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XUnmapEvent),
            "::",
            stringify!(from_configure)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XMapEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub override_redirect: libc::c_int,
}
#[test]
fn bindgen_test_layout_XMapEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XMapEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XMapEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XMapEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XMapEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XMapEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).override_redirect) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapEvent),
            "::",
            stringify!(override_redirect)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XMapRequestEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub parent: Window,
    pub window: Window,
}
#[test]
fn bindgen_test_layout_XMapRequestEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XMapRequestEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XMapRequestEvent>(),
        48usize,
        concat!("Size of: ", stringify!(XMapRequestEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XMapRequestEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XMapRequestEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapRequestEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapRequestEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapRequestEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapRequestEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapRequestEvent),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XMapRequestEvent),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XReparentEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub parent: Window,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub override_redirect: libc::c_int,
}
#[test]
fn bindgen_test_layout_XReparentEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XReparentEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XReparentEvent>(),
        72usize,
        concat!("Size of: ", stringify!(XReparentEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XReparentEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XReparentEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).override_redirect) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XReparentEvent),
            "::",
            stringify!(override_redirect)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XConfigureEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub border_width: libc::c_int,
    pub above: Window,
    pub override_redirect: libc::c_int,
}
#[test]
fn bindgen_test_layout_XConfigureEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XConfigureEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XConfigureEvent>(),
        88usize,
        concat!("Size of: ", stringify!(XConfigureEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XConfigureEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XConfigureEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).border_width) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).above) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(above)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).override_redirect) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureEvent),
            "::",
            stringify!(override_redirect)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XGravityEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub x: libc::c_int,
    pub y: libc::c_int,
}
#[test]
fn bindgen_test_layout_XGravityEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XGravityEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XGravityEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XGravityEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XGravityEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XGravityEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XGravityEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XGravityEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XGravityEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XGravityEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XGravityEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XGravityEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XGravityEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XGravityEvent),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XResizeRequestEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub width: libc::c_int,
    pub height: libc::c_int,
}
#[test]
fn bindgen_test_layout_XResizeRequestEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XResizeRequestEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XResizeRequestEvent>(),
        48usize,
        concat!("Size of: ", stringify!(XResizeRequestEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XResizeRequestEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XResizeRequestEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XResizeRequestEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XResizeRequestEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XResizeRequestEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XResizeRequestEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XResizeRequestEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XResizeRequestEvent),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XResizeRequestEvent),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XConfigureRequestEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub parent: Window,
    pub window: Window,
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub width: libc::c_int,
    pub height: libc::c_int,
    pub border_width: libc::c_int,
    pub above: Window,
    pub detail: libc::c_int,
    pub value_mask: libc::c_ulong,
}
#[test]
fn bindgen_test_layout_XConfigureRequestEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XConfigureRequestEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XConfigureRequestEvent>(),
        96usize,
        concat!("Size of: ", stringify!(XConfigureRequestEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XConfigureRequestEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XConfigureRequestEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).border_width) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).above) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(above)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).detail) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value_mask) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XConfigureRequestEvent),
            "::",
            stringify!(value_mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XCirculateEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub event: Window,
    pub window: Window,
    pub place: libc::c_int,
}
#[test]
fn bindgen_test_layout_XCirculateEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XCirculateEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XCirculateEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XCirculateEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XCirculateEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XCirculateEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).place) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateEvent),
            "::",
            stringify!(place)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XCirculateRequestEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub parent: Window,
    pub window: Window,
    pub place: libc::c_int,
}
#[test]
fn bindgen_test_layout_XCirculateRequestEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XCirculateRequestEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XCirculateRequestEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XCirculateRequestEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XCirculateRequestEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XCirculateRequestEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateRequestEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateRequestEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateRequestEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateRequestEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateRequestEvent),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateRequestEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).place) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XCirculateRequestEvent),
            "::",
            stringify!(place)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XPropertyEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub atom: Atom,
    pub time: Time,
    pub state: libc::c_int,
}
#[test]
fn bindgen_test_layout_XPropertyEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XPropertyEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XPropertyEvent>(),
        64usize,
        concat!("Size of: ", stringify!(XPropertyEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XPropertyEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XPropertyEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XPropertyEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XPropertyEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XPropertyEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XPropertyEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XPropertyEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).atom) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XPropertyEvent),
            "::",
            stringify!(atom)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XPropertyEvent),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XPropertyEvent),
            "::",
            stringify!(state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XSelectionClearEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub selection: Atom,
    pub time: Time,
}
#[test]
fn bindgen_test_layout_XSelectionClearEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XSelectionClearEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XSelectionClearEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XSelectionClearEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XSelectionClearEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XSelectionClearEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionClearEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionClearEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionClearEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionClearEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionClearEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).selection) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionClearEvent),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionClearEvent),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XSelectionRequestEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub owner: Window,
    pub requestor: Window,
    pub selection: Atom,
    pub target: Atom,
    pub property: Atom,
    pub time: Time,
}
#[test]
fn bindgen_test_layout_XSelectionRequestEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XSelectionRequestEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XSelectionRequestEvent>(),
        80usize,
        concat!("Size of: ", stringify!(XSelectionRequestEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XSelectionRequestEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XSelectionRequestEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).requestor) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(requestor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).selection) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).property) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionRequestEvent),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XSelectionEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub requestor: Window,
    pub selection: Atom,
    pub target: Atom,
    pub property: Atom,
    pub time: Time,
}
#[test]
fn bindgen_test_layout_XSelectionEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XSelectionEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XSelectionEvent>(),
        72usize,
        concat!("Size of: ", stringify!(XSelectionEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XSelectionEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XSelectionEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).requestor) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(requestor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).selection) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).property) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(XSelectionEvent),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XColormapEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub colormap: Colormap,
    pub new: libc::c_int,
    pub state: libc::c_int,
}
#[test]
fn bindgen_test_layout_XColormapEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XColormapEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XColormapEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XColormapEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XColormapEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XColormapEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XColormapEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XColormapEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XColormapEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XColormapEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XColormapEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).colormap) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XColormapEvent),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).new) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XColormapEvent),
            "::",
            stringify!(new)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(XColormapEvent),
            "::",
            stringify!(state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XClientMessageEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub message_type: Atom,
    pub format: libc::c_int,
    pub data: XClientMessageEvent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union XClientMessageEvent__bindgen_ty_1 {
    pub b: [libc::c_char; 20usize],
    pub s: [libc::c_short; 10usize],
    pub l: [libc::c_long; 5usize],
}
#[test]
fn bindgen_test_layout_XClientMessageEvent__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<XClientMessageEvent__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XClientMessageEvent__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(XClientMessageEvent__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<XClientMessageEvent__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(XClientMessageEvent__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent__bindgen_ty_1),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).l) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent__bindgen_ty_1),
            "::",
            stringify!(l)
        )
    );
}
#[test]
fn bindgen_test_layout_XClientMessageEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XClientMessageEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XClientMessageEvent>(),
        96usize,
        concat!("Size of: ", stringify!(XClientMessageEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XClientMessageEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XClientMessageEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).message_type) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent),
            "::",
            stringify!(message_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XClientMessageEvent),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XMappingEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
    pub request: libc::c_int,
    pub first_keycode: libc::c_int,
    pub count: libc::c_int,
}
#[test]
fn bindgen_test_layout_XMappingEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XMappingEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XMappingEvent>(),
        56usize,
        concat!("Size of: ", stringify!(XMappingEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XMappingEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XMappingEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XMappingEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XMappingEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XMappingEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XMappingEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XMappingEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).request) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XMappingEvent),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).first_keycode) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XMappingEvent),
            "::",
            stringify!(first_keycode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XMappingEvent),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XErrorEvent {
    pub type_: libc::c_int,
    pub display: *mut Display,
    pub resourceid: XID,
    pub serial: libc::c_ulong,
    pub error_code: libc::c_uchar,
    pub request_code: libc::c_uchar,
    pub minor_code: libc::c_uchar,
}
#[test]
fn bindgen_test_layout_XErrorEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XErrorEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XErrorEvent>(),
        40usize,
        concat!("Size of: ", stringify!(XErrorEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XErrorEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XErrorEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XErrorEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XErrorEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resourceid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XErrorEvent),
            "::",
            stringify!(resourceid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XErrorEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XErrorEvent),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).request_code) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(XErrorEvent),
            "::",
            stringify!(request_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minor_code) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(XErrorEvent),
            "::",
            stringify!(minor_code)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XAnyEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub window: Window,
}
#[test]
fn bindgen_test_layout_XAnyEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XAnyEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XAnyEvent>(),
        40usize,
        concat!("Size of: ", stringify!(XAnyEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XAnyEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XAnyEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XAnyEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XAnyEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XAnyEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XAnyEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XAnyEvent),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XGenericEvent {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub extension: libc::c_int,
    pub evtype: libc::c_int,
}
#[test]
fn bindgen_test_layout_XGenericEvent() {
    const UNINIT: ::core::mem::MaybeUninit<XGenericEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XGenericEvent>(),
        40usize,
        concat!("Size of: ", stringify!(XGenericEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<XGenericEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(XGenericEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEvent),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extension) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEvent),
            "::",
            stringify!(extension)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).evtype) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEvent),
            "::",
            stringify!(evtype)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XGenericEventCookie {
    pub type_: libc::c_int,
    pub serial: libc::c_ulong,
    pub send_event: libc::c_int,
    pub display: *mut Display,
    pub extension: libc::c_int,
    pub evtype: libc::c_int,
    pub cookie: libc::c_uint,
    pub data: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_XGenericEventCookie() {
    const UNINIT: ::core::mem::MaybeUninit<XGenericEventCookie> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XGenericEventCookie>(),
        56usize,
        concat!("Size of: ", stringify!(XGenericEventCookie))
    );
    assert_eq!(
        ::core::mem::align_of::<XGenericEventCookie>(),
        8usize,
        concat!("Alignment of ", stringify!(XGenericEventCookie))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEventCookie),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEventCookie),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEventCookie),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEventCookie),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extension) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEventCookie),
            "::",
            stringify!(extension)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).evtype) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEventCookie),
            "::",
            stringify!(evtype)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cookie) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEventCookie),
            "::",
            stringify!(cookie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XGenericEventCookie),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XEvent {
    pub type_: libc::c_int,
    pub xany: XAnyEvent,
    pub xkey: XKeyEvent,
    pub xbutton: XButtonEvent,
    pub xmotion: XMotionEvent,
    pub xcrossing: XCrossingEvent,
    pub xfocus: XFocusChangeEvent,
    pub xexpose: XExposeEvent,
    pub xgraphicsexpose: XGraphicsExposeEvent,
    pub xnoexpose: XNoExposeEvent,
    pub xvisibility: XVisibilityEvent,
    pub xcreatewindow: XCreateWindowEvent,
    pub xdestroywindow: XDestroyWindowEvent,
    pub xunmap: XUnmapEvent,
    pub xmap: XMapEvent,
    pub xmaprequest: XMapRequestEvent,
    pub xreparent: XReparentEvent,
    pub xconfigure: XConfigureEvent,
    pub xgravity: XGravityEvent,
    pub xresizerequest: XResizeRequestEvent,
    pub xconfigurerequest: XConfigureRequestEvent,
    pub xcirculate: XCirculateEvent,
    pub xcirculaterequest: XCirculateRequestEvent,
    pub xproperty: XPropertyEvent,
    pub xselectionclear: XSelectionClearEvent,
    pub xselectionrequest: XSelectionRequestEvent,
    pub xselection: XSelectionEvent,
    pub xcolormap: XColormapEvent,
    pub xclient: XClientMessageEvent,
    pub xmapping: XMappingEvent,
    pub xerror: XErrorEvent,
    pub xkeymap: XKeymapEvent,
    pub xgeneric: XGenericEvent,
    pub xcookie: XGenericEventCookie,
    pub pad: [libc::c_long; 24usize],
}
#[test]
fn bindgen_test_layout__XEvent() {
    const UNINIT: ::core::mem::MaybeUninit<_XEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XEvent>(),
        192usize,
        concat!("Size of: ", stringify!(_XEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<_XEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(_XEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xany) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xany)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xkey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xkey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xbutton) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xbutton)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xmotion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xmotion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xcrossing) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xcrossing)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xfocus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xfocus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xexpose) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xexpose)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xgraphicsexpose) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xgraphicsexpose)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xnoexpose) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xnoexpose)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xvisibility) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xvisibility)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xcreatewindow) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xcreatewindow)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xdestroywindow) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xdestroywindow)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xunmap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xunmap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xmap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xmap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xmaprequest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xmaprequest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xreparent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xreparent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xconfigure) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xconfigure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xgravity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xgravity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xresizerequest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xresizerequest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xconfigurerequest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xconfigurerequest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xcirculate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xcirculate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xcirculaterequest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xcirculaterequest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xproperty) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xproperty)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xselectionclear) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xselectionclear)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xselectionrequest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xselectionrequest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xselection) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xselection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xcolormap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xcolormap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xclient) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xclient)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xmapping) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xmapping)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xerror) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xerror)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xkeymap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xkeymap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xgeneric) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xgeneric)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xcookie) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(xcookie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XEvent),
            "::",
            stringify!(pad)
        )
    );
}
pub type XEvent = _XEvent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XCharStruct {
    pub lbearing: libc::c_short,
    pub rbearing: libc::c_short,
    pub width: libc::c_short,
    pub ascent: libc::c_short,
    pub descent: libc::c_short,
    pub attributes: libc::c_ushort,
}
#[test]
fn bindgen_test_layout_XCharStruct() {
    const UNINIT: ::core::mem::MaybeUninit<XCharStruct> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XCharStruct>(),
        12usize,
        concat!("Size of: ", stringify!(XCharStruct))
    );
    assert_eq!(
        ::core::mem::align_of::<XCharStruct>(),
        2usize,
        concat!("Alignment of ", stringify!(XCharStruct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lbearing) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XCharStruct),
            "::",
            stringify!(lbearing)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rbearing) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(XCharStruct),
            "::",
            stringify!(rbearing)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XCharStruct),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ascent) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(XCharStruct),
            "::",
            stringify!(ascent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).descent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XCharStruct),
            "::",
            stringify!(descent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attributes) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(XCharStruct),
            "::",
            stringify!(attributes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XFontProp {
    pub name: Atom,
    pub card32: libc::c_ulong,
}
#[test]
fn bindgen_test_layout_XFontProp() {
    const UNINIT: ::core::mem::MaybeUninit<XFontProp> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XFontProp>(),
        16usize,
        concat!("Size of: ", stringify!(XFontProp))
    );
    assert_eq!(
        ::core::mem::align_of::<XFontProp>(),
        8usize,
        concat!("Alignment of ", stringify!(XFontProp))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontProp),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).card32) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontProp),
            "::",
            stringify!(card32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XFontStruct {
    pub ext_data: *mut XExtData,
    pub fid: Font,
    pub direction: libc::c_uint,
    pub min_char_or_byte2: libc::c_uint,
    pub max_char_or_byte2: libc::c_uint,
    pub min_byte1: libc::c_uint,
    pub max_byte1: libc::c_uint,
    pub all_chars_exist: libc::c_int,
    pub default_char: libc::c_uint,
    pub n_properties: libc::c_int,
    pub properties: *mut XFontProp,
    pub min_bounds: XCharStruct,
    pub max_bounds: XCharStruct,
    pub per_char: *mut XCharStruct,
    pub ascent: libc::c_int,
    pub descent: libc::c_int,
}
#[test]
fn bindgen_test_layout_XFontStruct() {
    const UNINIT: ::core::mem::MaybeUninit<XFontStruct> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XFontStruct>(),
        96usize,
        concat!("Size of: ", stringify!(XFontStruct))
    );
    assert_eq!(
        ::core::mem::align_of::<XFontStruct>(),
        8usize,
        concat!("Alignment of ", stringify!(XFontStruct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ext_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(ext_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(fid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).min_char_or_byte2) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(min_char_or_byte2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_char_or_byte2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(max_char_or_byte2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).min_byte1) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(min_byte1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_byte1) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(max_byte1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).all_chars_exist) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(all_chars_exist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).default_char) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(default_char)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_properties) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(n_properties)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).properties) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(properties)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).min_bounds) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(min_bounds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_bounds) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(max_bounds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).per_char) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(per_char)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ascent) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(ascent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).descent) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontStruct),
            "::",
            stringify!(descent)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XTextItem {
    pub chars: *mut libc::c_char,
    pub nchars: libc::c_int,
    pub delta: libc::c_int,
    pub font: Font,
}
#[test]
fn bindgen_test_layout_XTextItem() {
    const UNINIT: ::core::mem::MaybeUninit<XTextItem> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XTextItem>(),
        24usize,
        concat!("Size of: ", stringify!(XTextItem))
    );
    assert_eq!(
        ::core::mem::align_of::<XTextItem>(),
        8usize,
        concat!("Alignment of ", stringify!(XTextItem))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chars) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XTextItem),
            "::",
            stringify!(chars)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nchars) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XTextItem),
            "::",
            stringify!(nchars)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delta) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XTextItem),
            "::",
            stringify!(delta)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).font) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XTextItem),
            "::",
            stringify!(font)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XChar2b {
    pub byte1: libc::c_uchar,
    pub byte2: libc::c_uchar,
}
#[test]
fn bindgen_test_layout_XChar2b() {
    const UNINIT: ::core::mem::MaybeUninit<XChar2b> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XChar2b>(),
        2usize,
        concat!("Size of: ", stringify!(XChar2b))
    );
    assert_eq!(
        ::core::mem::align_of::<XChar2b>(),
        1usize,
        concat!("Alignment of ", stringify!(XChar2b))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).byte1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XChar2b),
            "::",
            stringify!(byte1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).byte2) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(XChar2b),
            "::",
            stringify!(byte2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XTextItem16 {
    pub chars: *mut XChar2b,
    pub nchars: libc::c_int,
    pub delta: libc::c_int,
    pub font: Font,
}
#[test]
fn bindgen_test_layout_XTextItem16() {
    const UNINIT: ::core::mem::MaybeUninit<XTextItem16> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XTextItem16>(),
        24usize,
        concat!("Size of: ", stringify!(XTextItem16))
    );
    assert_eq!(
        ::core::mem::align_of::<XTextItem16>(),
        8usize,
        concat!("Alignment of ", stringify!(XTextItem16))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chars) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XTextItem16),
            "::",
            stringify!(chars)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nchars) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XTextItem16),
            "::",
            stringify!(nchars)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delta) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XTextItem16),
            "::",
            stringify!(delta)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).font) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XTextItem16),
            "::",
            stringify!(font)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union XEDataObject {
    pub display: *mut Display,
    pub gc: GC,
    pub visual: *mut Visual,
    pub screen: *mut Screen,
    pub pixmap_format: *mut ScreenFormat,
    pub font: *mut XFontStruct,
}
#[test]
fn bindgen_test_layout_XEDataObject() {
    const UNINIT: ::core::mem::MaybeUninit<XEDataObject> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XEDataObject>(),
        8usize,
        concat!("Size of: ", stringify!(XEDataObject))
    );
    assert_eq!(
        ::core::mem::align_of::<XEDataObject>(),
        8usize,
        concat!("Alignment of ", stringify!(XEDataObject))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XEDataObject),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XEDataObject),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).visual) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XEDataObject),
            "::",
            stringify!(visual)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).screen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XEDataObject),
            "::",
            stringify!(screen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pixmap_format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XEDataObject),
            "::",
            stringify!(pixmap_format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).font) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XEDataObject),
            "::",
            stringify!(font)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XFontSetExtents {
    pub max_ink_extent: XRectangle,
    pub max_logical_extent: XRectangle,
}
#[test]
fn bindgen_test_layout_XFontSetExtents() {
    const UNINIT: ::core::mem::MaybeUninit<XFontSetExtents> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XFontSetExtents>(),
        16usize,
        concat!("Size of: ", stringify!(XFontSetExtents))
    );
    assert_eq!(
        ::core::mem::align_of::<XFontSetExtents>(),
        2usize,
        concat!("Alignment of ", stringify!(XFontSetExtents))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_ink_extent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontSetExtents),
            "::",
            stringify!(max_ink_extent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_logical_extent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XFontSetExtents),
            "::",
            stringify!(max_logical_extent)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XOM {
    _unused: [u8; 0],
}
pub type XOM = *mut _XOM;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XOC {
    _unused: [u8; 0],
}
pub type XOC = *mut _XOC;
pub type XFontSet = *mut _XOC;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XmbTextItem {
    pub chars: *mut libc::c_char,
    pub nchars: libc::c_int,
    pub delta: libc::c_int,
    pub font_set: XFontSet,
}
#[test]
fn bindgen_test_layout_XmbTextItem() {
    const UNINIT: ::core::mem::MaybeUninit<XmbTextItem> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XmbTextItem>(),
        24usize,
        concat!("Size of: ", stringify!(XmbTextItem))
    );
    assert_eq!(
        ::core::mem::align_of::<XmbTextItem>(),
        8usize,
        concat!("Alignment of ", stringify!(XmbTextItem))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chars) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XmbTextItem),
            "::",
            stringify!(chars)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nchars) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XmbTextItem),
            "::",
            stringify!(nchars)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delta) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XmbTextItem),
            "::",
            stringify!(delta)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).font_set) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XmbTextItem),
            "::",
            stringify!(font_set)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XwcTextItem {
    pub chars: *mut wchar_t,
    pub nchars: libc::c_int,
    pub delta: libc::c_int,
    pub font_set: XFontSet,
}
#[test]
fn bindgen_test_layout_XwcTextItem() {
    const UNINIT: ::core::mem::MaybeUninit<XwcTextItem> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XwcTextItem>(),
        24usize,
        concat!("Size of: ", stringify!(XwcTextItem))
    );
    assert_eq!(
        ::core::mem::align_of::<XwcTextItem>(),
        8usize,
        concat!("Alignment of ", stringify!(XwcTextItem))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chars) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XwcTextItem),
            "::",
            stringify!(chars)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nchars) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XwcTextItem),
            "::",
            stringify!(nchars)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delta) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XwcTextItem),
            "::",
            stringify!(delta)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).font_set) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XwcTextItem),
            "::",
            stringify!(font_set)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XOMCharSetList {
    pub charset_count: libc::c_int,
    pub charset_list: *mut *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_XOMCharSetList() {
    const UNINIT: ::core::mem::MaybeUninit<XOMCharSetList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XOMCharSetList>(),
        16usize,
        concat!("Size of: ", stringify!(XOMCharSetList))
    );
    assert_eq!(
        ::core::mem::align_of::<XOMCharSetList>(),
        8usize,
        concat!("Alignment of ", stringify!(XOMCharSetList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).charset_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XOMCharSetList),
            "::",
            stringify!(charset_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).charset_list) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XOMCharSetList),
            "::",
            stringify!(charset_list)
        )
    );
}
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum XOrientation {
    XOMOrientation_LTR_TTB = 0,
    XOMOrientation_RTL_TTB = 1,
    XOMOrientation_TTB_LTR = 2,
    XOMOrientation_TTB_RTL = 3,
    XOMOrientation_Context = 4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XOMOrientation {
    pub num_orientation: libc::c_int,
    pub orientation: *mut XOrientation,
}
#[test]
fn bindgen_test_layout_XOMOrientation() {
    const UNINIT: ::core::mem::MaybeUninit<XOMOrientation> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XOMOrientation>(),
        16usize,
        concat!("Size of: ", stringify!(XOMOrientation))
    );
    assert_eq!(
        ::core::mem::align_of::<XOMOrientation>(),
        8usize,
        concat!("Alignment of ", stringify!(XOMOrientation))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_orientation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XOMOrientation),
            "::",
            stringify!(num_orientation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).orientation) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XOMOrientation),
            "::",
            stringify!(orientation)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XOMFontInfo {
    pub num_font: libc::c_int,
    pub font_struct_list: *mut *mut XFontStruct,
    pub font_name_list: *mut *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_XOMFontInfo() {
    const UNINIT: ::core::mem::MaybeUninit<XOMFontInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XOMFontInfo>(),
        24usize,
        concat!("Size of: ", stringify!(XOMFontInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<XOMFontInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(XOMFontInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_font) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XOMFontInfo),
            "::",
            stringify!(num_font)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).font_struct_list) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XOMFontInfo),
            "::",
            stringify!(font_struct_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).font_name_list) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XOMFontInfo),
            "::",
            stringify!(font_name_list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIM {
    _unused: [u8; 0],
}
pub type XIM = *mut _XIM;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIC {
    _unused: [u8; 0],
}
pub type XIC = *mut _XIC;
pub type XIMProc =
    ::core::option::Option<unsafe extern "C" fn(arg1: XIM, arg2: XPointer, arg3: XPointer)>;
pub type XICProc = ::core::option::Option<
    unsafe extern "C" fn(arg1: XIC, arg2: XPointer, arg3: XPointer) -> libc::c_int,
>;
pub type XIDProc = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut Display, arg2: XPointer, arg3: XPointer),
>;
pub type XIMStyle = libc::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XIMStyles {
    pub count_styles: libc::c_ushort,
    pub supported_styles: *mut XIMStyle,
}
#[test]
fn bindgen_test_layout_XIMStyles() {
    const UNINIT: ::core::mem::MaybeUninit<XIMStyles> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XIMStyles>(),
        16usize,
        concat!("Size of: ", stringify!(XIMStyles))
    );
    assert_eq!(
        ::core::mem::align_of::<XIMStyles>(),
        8usize,
        concat!("Alignment of ", stringify!(XIMStyles))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count_styles) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XIMStyles),
            "::",
            stringify!(count_styles)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supported_styles) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XIMStyles),
            "::",
            stringify!(supported_styles)
        )
    );
}
pub type XVaNestedList = *mut libc::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XIMCallback {
    pub client_data: XPointer,
    pub callback: XIMProc,
}
#[test]
fn bindgen_test_layout_XIMCallback() {
    const UNINIT: ::core::mem::MaybeUninit<XIMCallback> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XIMCallback>(),
        16usize,
        concat!("Size of: ", stringify!(XIMCallback))
    );
    assert_eq!(
        ::core::mem::align_of::<XIMCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(XIMCallback))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).client_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XIMCallback),
            "::",
            stringify!(client_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XIMCallback),
            "::",
            stringify!(callback)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XICCallback {
    pub client_data: XPointer,
    pub callback: XICProc,
}
#[test]
fn bindgen_test_layout_XICCallback() {
    const UNINIT: ::core::mem::MaybeUninit<XICCallback> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XICCallback>(),
        16usize,
        concat!("Size of: ", stringify!(XICCallback))
    );
    assert_eq!(
        ::core::mem::align_of::<XICCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(XICCallback))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).client_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XICCallback),
            "::",
            stringify!(client_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XICCallback),
            "::",
            stringify!(callback)
        )
    );
}
pub type XIMFeedback = libc::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMText {
    pub length: libc::c_ushort,
    pub feedback: *mut XIMFeedback,
    pub encoding_is_wchar: libc::c_int,
    pub string: _XIMText__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XIMText__bindgen_ty_1 {
    pub multi_byte: *mut libc::c_char,
    pub wide_char: *mut wchar_t,
}
#[test]
fn bindgen_test_layout__XIMText__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_XIMText__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XIMText__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_XIMText__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_XIMText__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMText__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).multi_byte) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMText__bindgen_ty_1),
            "::",
            stringify!(multi_byte)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wide_char) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMText__bindgen_ty_1),
            "::",
            stringify!(wide_char)
        )
    );
}
#[test]
fn bindgen_test_layout__XIMText() {
    const UNINIT: ::core::mem::MaybeUninit<_XIMText> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XIMText>(),
        32usize,
        concat!("Size of: ", stringify!(_XIMText))
    );
    assert_eq!(
        ::core::mem::align_of::<_XIMText>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMText))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMText),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).feedback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMText),
            "::",
            stringify!(feedback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encoding_is_wchar) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMText),
            "::",
            stringify!(encoding_is_wchar)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).string) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMText),
            "::",
            stringify!(string)
        )
    );
}
pub type XIMText = _XIMText;
pub type XIMPreeditState = libc::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMPreeditStateNotifyCallbackStruct {
    pub state: XIMPreeditState,
}
#[test]
fn bindgen_test_layout__XIMPreeditStateNotifyCallbackStruct() {
    const UNINIT: ::core::mem::MaybeUninit<_XIMPreeditStateNotifyCallbackStruct> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XIMPreeditStateNotifyCallbackStruct>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_XIMPreeditStateNotifyCallbackStruct)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_XIMPreeditStateNotifyCallbackStruct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_XIMPreeditStateNotifyCallbackStruct)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMPreeditStateNotifyCallbackStruct),
            "::",
            stringify!(state)
        )
    );
}
pub type XIMPreeditStateNotifyCallbackStruct = _XIMPreeditStateNotifyCallbackStruct;
pub type XIMResetState = libc::c_ulong;
pub type XIMStringConversionFeedback = libc::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMStringConversionText {
    pub length: libc::c_ushort,
    pub feedback: *mut XIMStringConversionFeedback,
    pub encoding_is_wchar: libc::c_int,
    pub string: _XIMStringConversionText__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XIMStringConversionText__bindgen_ty_1 {
    pub mbs: *mut libc::c_char,
    pub wcs: *mut wchar_t,
}
#[test]
fn bindgen_test_layout__XIMStringConversionText__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_XIMStringConversionText__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XIMStringConversionText__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_XIMStringConversionText__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_XIMStringConversionText__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_XIMStringConversionText__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mbs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionText__bindgen_ty_1),
            "::",
            stringify!(mbs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wcs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionText__bindgen_ty_1),
            "::",
            stringify!(wcs)
        )
    );
}
#[test]
fn bindgen_test_layout__XIMStringConversionText() {
    const UNINIT: ::core::mem::MaybeUninit<_XIMStringConversionText> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XIMStringConversionText>(),
        32usize,
        concat!("Size of: ", stringify!(_XIMStringConversionText))
    );
    assert_eq!(
        ::core::mem::align_of::<_XIMStringConversionText>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMStringConversionText))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionText),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).feedback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionText),
            "::",
            stringify!(feedback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encoding_is_wchar) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionText),
            "::",
            stringify!(encoding_is_wchar)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).string) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionText),
            "::",
            stringify!(string)
        )
    );
}
pub type XIMStringConversionText = _XIMStringConversionText;
pub type XIMStringConversionPosition = libc::c_ushort;
pub type XIMStringConversionType = libc::c_ushort;
pub type XIMStringConversionOperation = libc::c_ushort;
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum XIMCaretDirection {
    XIMForwardChar = 0,
    XIMBackwardChar = 1,
    XIMForwardWord = 2,
    XIMBackwardWord = 3,
    XIMCaretUp = 4,
    XIMCaretDown = 5,
    XIMNextLine = 6,
    XIMPreviousLine = 7,
    XIMLineStart = 8,
    XIMLineEnd = 9,
    XIMAbsolutePosition = 10,
    XIMDontChange = 11,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMStringConversionCallbackStruct {
    pub position: XIMStringConversionPosition,
    pub direction: XIMCaretDirection,
    pub operation: XIMStringConversionOperation,
    pub factor: libc::c_ushort,
    pub text: *mut XIMStringConversionText,
}
#[test]
fn bindgen_test_layout__XIMStringConversionCallbackStruct() {
    const UNINIT: ::core::mem::MaybeUninit<_XIMStringConversionCallbackStruct> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XIMStringConversionCallbackStruct>(),
        24usize,
        concat!("Size of: ", stringify!(_XIMStringConversionCallbackStruct))
    );
    assert_eq!(
        ::core::mem::align_of::<_XIMStringConversionCallbackStruct>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_XIMStringConversionCallbackStruct)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionCallbackStruct),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionCallbackStruct),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionCallbackStruct),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).factor) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionCallbackStruct),
            "::",
            stringify!(factor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStringConversionCallbackStruct),
            "::",
            stringify!(text)
        )
    );
}
pub type XIMStringConversionCallbackStruct = _XIMStringConversionCallbackStruct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMPreeditDrawCallbackStruct {
    pub caret: libc::c_int,
    pub chg_first: libc::c_int,
    pub chg_length: libc::c_int,
    pub text: *mut XIMText,
}
#[test]
fn bindgen_test_layout__XIMPreeditDrawCallbackStruct() {
    const UNINIT: ::core::mem::MaybeUninit<_XIMPreeditDrawCallbackStruct> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XIMPreeditDrawCallbackStruct>(),
        24usize,
        concat!("Size of: ", stringify!(_XIMPreeditDrawCallbackStruct))
    );
    assert_eq!(
        ::core::mem::align_of::<_XIMPreeditDrawCallbackStruct>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMPreeditDrawCallbackStruct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).caret) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMPreeditDrawCallbackStruct),
            "::",
            stringify!(caret)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chg_first) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMPreeditDrawCallbackStruct),
            "::",
            stringify!(chg_first)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chg_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMPreeditDrawCallbackStruct),
            "::",
            stringify!(chg_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMPreeditDrawCallbackStruct),
            "::",
            stringify!(text)
        )
    );
}
pub type XIMPreeditDrawCallbackStruct = _XIMPreeditDrawCallbackStruct;
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum XIMCaretStyle {
    XIMIsInvisible = 0,
    XIMIsPrimary = 1,
    XIMIsSecondary = 2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMPreeditCaretCallbackStruct {
    pub position: libc::c_int,
    pub direction: XIMCaretDirection,
    pub style: XIMCaretStyle,
}
#[test]
fn bindgen_test_layout__XIMPreeditCaretCallbackStruct() {
    const UNINIT: ::core::mem::MaybeUninit<_XIMPreeditCaretCallbackStruct> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XIMPreeditCaretCallbackStruct>(),
        12usize,
        concat!("Size of: ", stringify!(_XIMPreeditCaretCallbackStruct))
    );
    assert_eq!(
        ::core::mem::align_of::<_XIMPreeditCaretCallbackStruct>(),
        4usize,
        concat!("Alignment of ", stringify!(_XIMPreeditCaretCallbackStruct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMPreeditCaretCallbackStruct),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMPreeditCaretCallbackStruct),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).style) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMPreeditCaretCallbackStruct),
            "::",
            stringify!(style)
        )
    );
}
pub type XIMPreeditCaretCallbackStruct = _XIMPreeditCaretCallbackStruct;
#[repr(u32)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum XIMStatusDataType {
    XIMTextType = 0,
    XIMBitmapType = 1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMStatusDrawCallbackStruct {
    pub type_: XIMStatusDataType,
    pub data: _XIMStatusDrawCallbackStruct__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XIMStatusDrawCallbackStruct__bindgen_ty_1 {
    pub text: *mut XIMText,
    pub bitmap: Pixmap,
}
#[test]
fn bindgen_test_layout__XIMStatusDrawCallbackStruct__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_XIMStatusDrawCallbackStruct__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XIMStatusDrawCallbackStruct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_XIMStatusDrawCallbackStruct__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_XIMStatusDrawCallbackStruct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_XIMStatusDrawCallbackStruct__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStatusDrawCallbackStruct__bindgen_ty_1),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitmap) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStatusDrawCallbackStruct__bindgen_ty_1),
            "::",
            stringify!(bitmap)
        )
    );
}
#[test]
fn bindgen_test_layout__XIMStatusDrawCallbackStruct() {
    const UNINIT: ::core::mem::MaybeUninit<_XIMStatusDrawCallbackStruct> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XIMStatusDrawCallbackStruct>(),
        16usize,
        concat!("Size of: ", stringify!(_XIMStatusDrawCallbackStruct))
    );
    assert_eq!(
        ::core::mem::align_of::<_XIMStatusDrawCallbackStruct>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMStatusDrawCallbackStruct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStatusDrawCallbackStruct),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMStatusDrawCallbackStruct),
            "::",
            stringify!(data)
        )
    );
}
pub type XIMStatusDrawCallbackStruct = _XIMStatusDrawCallbackStruct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMHotKeyTrigger {
    pub keysym: KeySym,
    pub modifier: libc::c_int,
    pub modifier_mask: libc::c_int,
}
#[test]
fn bindgen_test_layout__XIMHotKeyTrigger() {
    const UNINIT: ::core::mem::MaybeUninit<_XIMHotKeyTrigger> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XIMHotKeyTrigger>(),
        16usize,
        concat!("Size of: ", stringify!(_XIMHotKeyTrigger))
    );
    assert_eq!(
        ::core::mem::align_of::<_XIMHotKeyTrigger>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMHotKeyTrigger))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keysym) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMHotKeyTrigger),
            "::",
            stringify!(keysym)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).modifier) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMHotKeyTrigger),
            "::",
            stringify!(modifier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).modifier_mask) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMHotKeyTrigger),
            "::",
            stringify!(modifier_mask)
        )
    );
}
pub type XIMHotKeyTrigger = _XIMHotKeyTrigger;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XIMHotKeyTriggers {
    pub num_hot_key: libc::c_int,
    pub key: *mut XIMHotKeyTrigger,
}
#[test]
fn bindgen_test_layout__XIMHotKeyTriggers() {
    const UNINIT: ::core::mem::MaybeUninit<_XIMHotKeyTriggers> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XIMHotKeyTriggers>(),
        16usize,
        concat!("Size of: ", stringify!(_XIMHotKeyTriggers))
    );
    assert_eq!(
        ::core::mem::align_of::<_XIMHotKeyTriggers>(),
        8usize,
        concat!("Alignment of ", stringify!(_XIMHotKeyTriggers))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_hot_key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMHotKeyTriggers),
            "::",
            stringify!(num_hot_key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XIMHotKeyTriggers),
            "::",
            stringify!(key)
        )
    );
}
pub type XIMHotKeyTriggers = _XIMHotKeyTriggers;
pub type XIMHotKeyState = libc::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XIMValuesList {
    pub count_values: libc::c_ushort,
    pub supported_values: *mut *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_XIMValuesList() {
    const UNINIT: ::core::mem::MaybeUninit<XIMValuesList> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XIMValuesList>(),
        16usize,
        concat!("Size of: ", stringify!(XIMValuesList))
    );
    assert_eq!(
        ::core::mem::align_of::<XIMValuesList>(),
        8usize,
        concat!("Alignment of ", stringify!(XIMValuesList))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count_values) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XIMValuesList),
            "::",
            stringify!(count_values)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supported_values) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XIMValuesList),
            "::",
            stringify!(supported_values)
        )
    );
}
extern "C" {
    pub static mut _Xdebug: libc::c_int;
}
extern "C" {
    pub fn XLoadQueryFont(arg1: *mut Display, arg2: *const libc::c_char) -> *mut XFontStruct;
}
extern "C" {
    pub fn XQueryFont(arg1: *mut Display, arg2: XID) -> *mut XFontStruct;
}
extern "C" {
    pub fn XGetMotionEvents(
        arg1: *mut Display,
        arg2: Window,
        arg3: Time,
        arg4: Time,
        arg5: *mut libc::c_int,
    ) -> *mut XTimeCoord;
}
extern "C" {
    pub fn XDeleteModifiermapEntry(
        arg1: *mut XModifierKeymap,
        arg2: KeyCode,
        arg3: libc::c_int,
    ) -> *mut XModifierKeymap;
}
extern "C" {
    pub fn XGetModifierMapping(arg1: *mut Display) -> *mut XModifierKeymap;
}
extern "C" {
    pub fn XInsertModifiermapEntry(
        arg1: *mut XModifierKeymap,
        arg2: KeyCode,
        arg3: libc::c_int,
    ) -> *mut XModifierKeymap;
}
extern "C" {
    pub fn XNewModifiermap(arg1: libc::c_int) -> *mut XModifierKeymap;
}
extern "C" {
    pub fn XCreateImage(
        arg1: *mut Display,
        arg2: *mut Visual,
        arg3: libc::c_uint,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *mut libc::c_char,
        arg7: libc::c_uint,
        arg8: libc::c_uint,
        arg9: libc::c_int,
        arg10: libc::c_int,
    ) -> *mut XImage;
}
extern "C" {
    pub fn XInitImage(arg1: *mut XImage) -> libc::c_int;
}
extern "C" {
    pub fn XGetImage(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_uint,
        arg6: libc::c_uint,
        arg7: libc::c_ulong,
        arg8: libc::c_int,
    ) -> *mut XImage;
}
extern "C" {
    pub fn XGetSubImage(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_uint,
        arg6: libc::c_uint,
        arg7: libc::c_ulong,
        arg8: libc::c_int,
        arg9: *mut XImage,
        arg10: libc::c_int,
        arg11: libc::c_int,
    ) -> *mut XImage;
}
extern "C" {
    pub fn XOpenDisplay(arg1: *const libc::c_char) -> *mut Display;
}
extern "C" {
    pub fn XrmInitialize();
}
extern "C" {
    pub fn XFetchBytes(arg1: *mut Display, arg2: *mut libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn XFetchBuffer(
        arg1: *mut Display,
        arg2: *mut libc::c_int,
        arg3: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn XGetAtomName(arg1: *mut Display, arg2: Atom) -> *mut libc::c_char;
}
extern "C" {
    pub fn XGetAtomNames(
        arg1: *mut Display,
        arg2: *mut Atom,
        arg3: libc::c_int,
        arg4: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetDefault(
        arg1: *mut Display,
        arg2: *const libc::c_char,
        arg3: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn XDisplayName(arg1: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn XKeysymToString(arg1: KeySym) -> *mut libc::c_char;
}
extern "C" {
    pub fn XSynchronize(
        arg1: *mut Display,
        arg2: libc::c_int,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int,
    >;
}
extern "C" {
    pub fn XSetAfterFunction(
        arg1: *mut Display,
        arg2: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Display) -> libc::c_int>,
    ) -> ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Display,
            arg2: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Display) -> libc::c_int>,
        ) -> libc::c_int,
    >;
}
extern "C" {
    pub fn XInternAtom(arg1: *mut Display, arg2: *const libc::c_char, arg3: libc::c_int) -> Atom;
}
extern "C" {
    pub fn XInternAtoms(
        arg1: *mut Display,
        arg2: *mut *mut libc::c_char,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: *mut Atom,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XCopyColormapAndFree(arg1: *mut Display, arg2: Colormap) -> Colormap;
}
extern "C" {
    pub fn XCreateColormap(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Visual,
        arg4: libc::c_int,
    ) -> Colormap;
}
extern "C" {
    pub fn XCreatePixmapCursor(
        arg1: *mut Display,
        arg2: Pixmap,
        arg3: Pixmap,
        arg4: *mut XColor,
        arg5: *mut XColor,
        arg6: libc::c_uint,
        arg7: libc::c_uint,
    ) -> Cursor;
}
extern "C" {
    pub fn XCreateGlyphCursor(
        arg1: *mut Display,
        arg2: Font,
        arg3: Font,
        arg4: libc::c_uint,
        arg5: libc::c_uint,
        arg6: *const XColor,
        arg7: *const XColor,
    ) -> Cursor;
}
extern "C" {
    pub fn XCreateFontCursor(arg1: *mut Display, arg2: libc::c_uint) -> Cursor;
}
extern "C" {
    pub fn XLoadFont(arg1: *mut Display, arg2: *const libc::c_char) -> Font;
}
extern "C" {
    pub fn XCreateGC(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: libc::c_ulong,
        arg4: *mut XGCValues,
    ) -> GC;
}
extern "C" {
    pub fn XGContextFromGC(arg1: GC) -> GContext;
}
extern "C" {
    pub fn XFlushGC(arg1: *mut Display, arg2: GC);
}
extern "C" {
    pub fn XCreatePixmap(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: libc::c_uint,
        arg4: libc::c_uint,
        arg5: libc::c_uint,
    ) -> Pixmap;
}
extern "C" {
    pub fn XCreateBitmapFromData(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: *const libc::c_char,
        arg4: libc::c_uint,
        arg5: libc::c_uint,
    ) -> Pixmap;
}
extern "C" {
    pub fn XCreatePixmapFromBitmapData(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: *mut libc::c_char,
        arg4: libc::c_uint,
        arg5: libc::c_uint,
        arg6: libc::c_ulong,
        arg7: libc::c_ulong,
        arg8: libc::c_uint,
    ) -> Pixmap;
}
extern "C" {
    pub fn XCreateSimpleWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_uint,
        arg6: libc::c_uint,
        arg7: libc::c_uint,
        arg8: libc::c_ulong,
        arg9: libc::c_ulong,
    ) -> Window;
}
extern "C" {
    pub fn XGetSelectionOwner(arg1: *mut Display, arg2: Atom) -> Window;
}
extern "C" {
    pub fn XCreateWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_uint,
        arg6: libc::c_uint,
        arg7: libc::c_uint,
        arg8: libc::c_int,
        arg9: libc::c_uint,
        arg10: *mut Visual,
        arg11: libc::c_ulong,
        arg12: *mut XSetWindowAttributes,
    ) -> Window;
}
extern "C" {
    pub fn XListInstalledColormaps(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut libc::c_int,
    ) -> *mut Colormap;
}
extern "C" {
    pub fn XListFonts(
        arg1: *mut Display,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: *mut libc::c_int,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn XListFontsWithInfo(
        arg1: *mut Display,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: *mut libc::c_int,
        arg5: *mut *mut XFontStruct,
    ) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn XGetFontPath(arg1: *mut Display, arg2: *mut libc::c_int) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn XListExtensions(arg1: *mut Display, arg2: *mut libc::c_int) -> *mut *mut libc::c_char;
}
extern "C" {
    pub fn XListProperties(arg1: *mut Display, arg2: Window, arg3: *mut libc::c_int) -> *mut Atom;
}
extern "C" {
    pub fn XListHosts(
        arg1: *mut Display,
        arg2: *mut libc::c_int,
        arg3: *mut libc::c_int,
    ) -> *mut XHostAddress;
}
extern "C" {
    pub fn XKeycodeToKeysym(arg1: *mut Display, arg2: KeyCode, arg3: libc::c_int) -> KeySym;
}
extern "C" {
    pub fn XLookupKeysym(arg1: *mut XKeyEvent, arg2: libc::c_int) -> KeySym;
}
extern "C" {
    pub fn XGetKeyboardMapping(
        arg1: *mut Display,
        arg2: KeyCode,
        arg3: libc::c_int,
        arg4: *mut libc::c_int,
    ) -> *mut KeySym;
}
extern "C" {
    pub fn XStringToKeysym(arg1: *const libc::c_char) -> KeySym;
}
extern "C" {
    pub fn XMaxRequestSize(arg1: *mut Display) -> libc::c_long;
}
extern "C" {
    pub fn XExtendedMaxRequestSize(arg1: *mut Display) -> libc::c_long;
}
extern "C" {
    pub fn XResourceManagerString(arg1: *mut Display) -> *mut libc::c_char;
}
extern "C" {
    pub fn XScreenResourceString(arg1: *mut Screen) -> *mut libc::c_char;
}
extern "C" {
    pub fn XDisplayMotionBufferSize(arg1: *mut Display) -> libc::c_ulong;
}
extern "C" {
    pub fn XVisualIDFromVisual(arg1: *mut Visual) -> VisualID;
}
extern "C" {
    pub fn XInitThreads() -> libc::c_int;
}
extern "C" {
    pub fn XFreeThreads() -> libc::c_int;
}
extern "C" {
    pub fn XLockDisplay(arg1: *mut Display);
}
extern "C" {
    pub fn XUnlockDisplay(arg1: *mut Display);
}
extern "C" {
    pub fn XInitExtension(arg1: *mut Display, arg2: *const libc::c_char) -> *mut XExtCodes;
}
extern "C" {
    pub fn XAddExtension(arg1: *mut Display) -> *mut XExtCodes;
}
extern "C" {
    pub fn XFindOnExtensionList(arg1: *mut *mut XExtData, arg2: libc::c_int) -> *mut XExtData;
}
extern "C" {
    pub fn XEHeadOfExtensionList(arg1: XEDataObject) -> *mut *mut XExtData;
}
extern "C" {
    pub fn XRootWindow(arg1: *mut Display, arg2: libc::c_int) -> Window;
}
extern "C" {
    pub fn XDefaultRootWindow(arg1: *mut Display) -> Window;
}
extern "C" {
    pub fn XRootWindowOfScreen(arg1: *mut Screen) -> Window;
}
extern "C" {
    pub fn XDefaultVisual(arg1: *mut Display, arg2: libc::c_int) -> *mut Visual;
}
extern "C" {
    pub fn XDefaultVisualOfScreen(arg1: *mut Screen) -> *mut Visual;
}
extern "C" {
    pub fn XDefaultGC(arg1: *mut Display, arg2: libc::c_int) -> GC;
}
extern "C" {
    pub fn XDefaultGCOfScreen(arg1: *mut Screen) -> GC;
}
extern "C" {
    pub fn XBlackPixel(arg1: *mut Display, arg2: libc::c_int) -> libc::c_ulong;
}
extern "C" {
    pub fn XWhitePixel(arg1: *mut Display, arg2: libc::c_int) -> libc::c_ulong;
}
extern "C" {
    pub fn XAllPlanes() -> libc::c_ulong;
}
extern "C" {
    pub fn XBlackPixelOfScreen(arg1: *mut Screen) -> libc::c_ulong;
}
extern "C" {
    pub fn XWhitePixelOfScreen(arg1: *mut Screen) -> libc::c_ulong;
}
extern "C" {
    pub fn XNextRequest(arg1: *mut Display) -> libc::c_ulong;
}
extern "C" {
    pub fn XLastKnownRequestProcessed(arg1: *mut Display) -> libc::c_ulong;
}
extern "C" {
    pub fn XServerVendor(arg1: *mut Display) -> *mut libc::c_char;
}
extern "C" {
    pub fn XDisplayString(arg1: *mut Display) -> *mut libc::c_char;
}
extern "C" {
    pub fn XDefaultColormap(arg1: *mut Display, arg2: libc::c_int) -> Colormap;
}
extern "C" {
    pub fn XDefaultColormapOfScreen(arg1: *mut Screen) -> Colormap;
}
extern "C" {
    pub fn XDisplayOfScreen(arg1: *mut Screen) -> *mut Display;
}
extern "C" {
    pub fn XScreenOfDisplay(arg1: *mut Display, arg2: libc::c_int) -> *mut Screen;
}
extern "C" {
    pub fn XDefaultScreenOfDisplay(arg1: *mut Display) -> *mut Screen;
}
extern "C" {
    pub fn XEventMaskOfScreen(arg1: *mut Screen) -> libc::c_long;
}
extern "C" {
    pub fn XScreenNumberOfScreen(arg1: *mut Screen) -> libc::c_int;
}
pub type XErrorHandler = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut Display, arg2: *mut XErrorEvent) -> libc::c_int,
>;
extern "C" {
    pub fn XSetErrorHandler(arg1: XErrorHandler) -> XErrorHandler;
}
pub type XIOErrorHandler =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut Display) -> libc::c_int>;
extern "C" {
    pub fn XSetIOErrorHandler(arg1: XIOErrorHandler) -> XIOErrorHandler;
}
pub type XIOErrorExitHandler =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut Display, arg2: *mut libc::c_void)>;
extern "C" {
    pub fn XSetIOErrorExitHandler(
        arg1: *mut Display,
        arg2: XIOErrorExitHandler,
        arg3: *mut libc::c_void,
    );
}
extern "C" {
    pub fn XListPixmapFormats(
        arg1: *mut Display,
        arg2: *mut libc::c_int,
    ) -> *mut XPixmapFormatValues;
}
extern "C" {
    pub fn XListDepths(
        arg1: *mut Display,
        arg2: libc::c_int,
        arg3: *mut libc::c_int,
    ) -> *mut libc::c_int;
}
extern "C" {
    pub fn XReconfigureWMWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_int,
        arg4: libc::c_uint,
        arg5: *mut XWindowChanges,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetWMProtocols(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut *mut Atom,
        arg4: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetWMProtocols(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Atom,
        arg4: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XIconifyWindow(arg1: *mut Display, arg2: Window, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XWithdrawWindow(arg1: *mut Display, arg2: Window, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XGetCommand(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut *mut *mut libc::c_char,
        arg4: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetWMColormapWindows(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut *mut Window,
        arg4: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetWMColormapWindows(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Window,
        arg4: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XFreeStringList(arg1: *mut *mut libc::c_char);
}
extern "C" {
    pub fn XSetTransientForHint(arg1: *mut Display, arg2: Window, arg3: Window) -> libc::c_int;
}
extern "C" {
    pub fn XActivateScreenSaver(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XAddHost(arg1: *mut Display, arg2: *mut XHostAddress) -> libc::c_int;
}
extern "C" {
    pub fn XAddHosts(arg1: *mut Display, arg2: *mut XHostAddress, arg3: libc::c_int)
        -> libc::c_int;
}
extern "C" {
    pub fn XAddToExtensionList(arg1: *mut *mut _XExtData, arg2: *mut XExtData) -> libc::c_int;
}
extern "C" {
    pub fn XAddToSaveSet(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XAllocColor(arg1: *mut Display, arg2: Colormap, arg3: *mut XColor) -> libc::c_int;
}
extern "C" {
    pub fn XAllocColorCells(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: libc::c_int,
        arg4: *mut libc::c_ulong,
        arg5: libc::c_uint,
        arg6: *mut libc::c_ulong,
        arg7: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XAllocColorPlanes(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: libc::c_int,
        arg4: *mut libc::c_ulong,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: libc::c_int,
        arg8: libc::c_int,
        arg9: *mut libc::c_ulong,
        arg10: *mut libc::c_ulong,
        arg11: *mut libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XAllocNamedColor(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *const libc::c_char,
        arg4: *mut XColor,
        arg5: *mut XColor,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XAllowEvents(arg1: *mut Display, arg2: libc::c_int, arg3: Time) -> libc::c_int;
}
extern "C" {
    pub fn XAutoRepeatOff(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XAutoRepeatOn(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XBell(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XBitmapBitOrder(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XBitmapPad(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XBitmapUnit(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XCellsOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XChangeActivePointerGrab(
        arg1: *mut Display,
        arg2: libc::c_uint,
        arg3: Cursor,
        arg4: Time,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XChangeGC(
        arg1: *mut Display,
        arg2: GC,
        arg3: libc::c_ulong,
        arg4: *mut XGCValues,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XChangeKeyboardControl(
        arg1: *mut Display,
        arg2: libc::c_ulong,
        arg3: *mut XKeyboardControl,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XChangeKeyboardMapping(
        arg1: *mut Display,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: *mut KeySym,
        arg5: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XChangePointerControl(
        arg1: *mut Display,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XChangeProperty(
        arg1: *mut Display,
        arg2: Window,
        arg3: Atom,
        arg4: Atom,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: *const libc::c_uchar,
        arg8: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XChangeSaveSet(arg1: *mut Display, arg2: Window, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XChangeWindowAttributes(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_ulong,
        arg4: *mut XSetWindowAttributes,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XCheckIfEvent(
        arg1: *mut Display,
        arg2: *mut XEvent,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Display,
                arg2: *mut XEvent,
                arg3: XPointer,
            ) -> libc::c_int,
        >,
        arg4: XPointer,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XCheckMaskEvent(
        arg1: *mut Display,
        arg2: libc::c_long,
        arg3: *mut XEvent,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XCheckTypedEvent(
        arg1: *mut Display,
        arg2: libc::c_int,
        arg3: *mut XEvent,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XCheckTypedWindowEvent(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_int,
        arg4: *mut XEvent,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XCheckWindowEvent(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_long,
        arg4: *mut XEvent,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XCirculateSubwindows(arg1: *mut Display, arg2: Window, arg3: libc::c_int)
        -> libc::c_int;
}
extern "C" {
    pub fn XCirculateSubwindowsDown(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XCirculateSubwindowsUp(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XClearArea(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_uint,
        arg6: libc::c_uint,
        arg7: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XClearWindow(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XCloseDisplay(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XConfigureWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_uint,
        arg4: *mut XWindowChanges,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XConnectionNumber(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XConvertSelection(
        arg1: *mut Display,
        arg2: Atom,
        arg3: Atom,
        arg4: Atom,
        arg5: Window,
        arg6: Time,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XCopyArea(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: Drawable,
        arg4: GC,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: libc::c_uint,
        arg8: libc::c_uint,
        arg9: libc::c_int,
        arg10: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XCopyGC(arg1: *mut Display, arg2: GC, arg3: libc::c_ulong, arg4: GC) -> libc::c_int;
}
extern "C" {
    pub fn XCopyPlane(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: Drawable,
        arg4: GC,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: libc::c_uint,
        arg8: libc::c_uint,
        arg9: libc::c_int,
        arg10: libc::c_int,
        arg11: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDefaultDepth(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XDefaultDepthOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XDefaultScreen(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XDefineCursor(arg1: *mut Display, arg2: Window, arg3: Cursor) -> libc::c_int;
}
extern "C" {
    pub fn XDeleteProperty(arg1: *mut Display, arg2: Window, arg3: Atom) -> libc::c_int;
}
extern "C" {
    pub fn XDestroyWindow(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XDestroySubwindows(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XDoesBackingStore(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XDoesSaveUnders(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XDisableAccessControl(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XDisplayCells(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XDisplayHeight(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XDisplayHeightMM(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XDisplayKeycodes(
        arg1: *mut Display,
        arg2: *mut libc::c_int,
        arg3: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDisplayPlanes(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XDisplayWidth(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XDisplayWidthMM(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XDrawArc(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_uint,
        arg7: libc::c_uint,
        arg8: libc::c_int,
        arg9: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawArcs(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XArc,
        arg5: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawImageString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *const libc::c_char,
        arg7: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawImageString16(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *const XChar2b,
        arg7: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawLine(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawLines(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XPoint,
        arg5: libc::c_int,
        arg6: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawPoint(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawPoints(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XPoint,
        arg5: libc::c_int,
        arg6: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawRectangle(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_uint,
        arg7: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawRectangles(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XRectangle,
        arg5: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawSegments(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XSegment,
        arg5: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *const libc::c_char,
        arg7: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawString16(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *const XChar2b,
        arg7: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawText(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *mut XTextItem,
        arg7: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XDrawText16(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *mut XTextItem16,
        arg7: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XEnableAccessControl(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XEventsQueued(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XFetchName(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XFillArc(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_uint,
        arg7: libc::c_uint,
        arg8: libc::c_int,
        arg9: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XFillArcs(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XArc,
        arg5: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XFillPolygon(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XPoint,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XFillRectangle(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_uint,
        arg7: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XFillRectangles(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XRectangle,
        arg5: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XFlush(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XForceScreenSaver(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XFree(arg1: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn XFreeColormap(arg1: *mut Display, arg2: Colormap) -> libc::c_int;
}
extern "C" {
    pub fn XFreeColors(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *mut libc::c_ulong,
        arg4: libc::c_int,
        arg5: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XFreeCursor(arg1: *mut Display, arg2: Cursor) -> libc::c_int;
}
extern "C" {
    pub fn XFreeExtensionList(arg1: *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn XFreeFont(arg1: *mut Display, arg2: *mut XFontStruct) -> libc::c_int;
}
extern "C" {
    pub fn XFreeFontInfo(
        arg1: *mut *mut libc::c_char,
        arg2: *mut XFontStruct,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XFreeFontNames(arg1: *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn XFreeFontPath(arg1: *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn XFreeGC(arg1: *mut Display, arg2: GC) -> libc::c_int;
}
extern "C" {
    pub fn XFreeModifiermap(arg1: *mut XModifierKeymap) -> libc::c_int;
}
extern "C" {
    pub fn XFreePixmap(arg1: *mut Display, arg2: Pixmap) -> libc::c_int;
}
extern "C" {
    pub fn XGeometry(
        arg1: *mut Display,
        arg2: libc::c_int,
        arg3: *const libc::c_char,
        arg4: *const libc::c_char,
        arg5: libc::c_uint,
        arg6: libc::c_uint,
        arg7: libc::c_uint,
        arg8: libc::c_int,
        arg9: libc::c_int,
        arg10: *mut libc::c_int,
        arg11: *mut libc::c_int,
        arg12: *mut libc::c_int,
        arg13: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetErrorDatabaseText(
        arg1: *mut Display,
        arg2: *const libc::c_char,
        arg3: *const libc::c_char,
        arg4: *const libc::c_char,
        arg5: *mut libc::c_char,
        arg6: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetErrorText(
        arg1: *mut Display,
        arg2: libc::c_int,
        arg3: *mut libc::c_char,
        arg4: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetFontProperty(
        arg1: *mut XFontStruct,
        arg2: Atom,
        arg3: *mut libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetGCValues(
        arg1: *mut Display,
        arg2: GC,
        arg3: libc::c_ulong,
        arg4: *mut XGCValues,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetGeometry(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: *mut Window,
        arg4: *mut libc::c_int,
        arg5: *mut libc::c_int,
        arg6: *mut libc::c_uint,
        arg7: *mut libc::c_uint,
        arg8: *mut libc::c_uint,
        arg9: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetIconName(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetInputFocus(
        arg1: *mut Display,
        arg2: *mut Window,
        arg3: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetKeyboardControl(arg1: *mut Display, arg2: *mut XKeyboardState) -> libc::c_int;
}
extern "C" {
    pub fn XGetPointerControl(
        arg1: *mut Display,
        arg2: *mut libc::c_int,
        arg3: *mut libc::c_int,
        arg4: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetPointerMapping(
        arg1: *mut Display,
        arg2: *mut libc::c_uchar,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetScreenSaver(
        arg1: *mut Display,
        arg2: *mut libc::c_int,
        arg3: *mut libc::c_int,
        arg4: *mut libc::c_int,
        arg5: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetTransientForHint(arg1: *mut Display, arg2: Window, arg3: *mut Window)
        -> libc::c_int;
}
extern "C" {
    pub fn XGetWindowProperty(
        arg1: *mut Display,
        arg2: Window,
        arg3: Atom,
        arg4: libc::c_long,
        arg5: libc::c_long,
        arg6: libc::c_int,
        arg7: Atom,
        arg8: *mut Atom,
        arg9: *mut libc::c_int,
        arg10: *mut libc::c_ulong,
        arg11: *mut libc::c_ulong,
        arg12: *mut *mut libc::c_uchar,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGetWindowAttributes(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut XWindowAttributes,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGrabButton(
        arg1: *mut Display,
        arg2: libc::c_uint,
        arg3: libc::c_uint,
        arg4: Window,
        arg5: libc::c_int,
        arg6: libc::c_uint,
        arg7: libc::c_int,
        arg8: libc::c_int,
        arg9: Window,
        arg10: Cursor,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGrabKey(
        arg1: *mut Display,
        arg2: libc::c_int,
        arg3: libc::c_uint,
        arg4: Window,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGrabKeyboard(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: Time,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGrabPointer(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_int,
        arg4: libc::c_uint,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: Window,
        arg8: Cursor,
        arg9: Time,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XGrabServer(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XHeightMMOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XHeightOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XIfEvent(
        arg1: *mut Display,
        arg2: *mut XEvent,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Display,
                arg2: *mut XEvent,
                arg3: XPointer,
            ) -> libc::c_int,
        >,
        arg4: XPointer,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XImageByteOrder(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XInstallColormap(arg1: *mut Display, arg2: Colormap) -> libc::c_int;
}
extern "C" {
    pub fn XKeysymToKeycode(arg1: *mut Display, arg2: KeySym) -> KeyCode;
}
extern "C" {
    pub fn XKillClient(arg1: *mut Display, arg2: XID) -> libc::c_int;
}
extern "C" {
    pub fn XLookupColor(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *const libc::c_char,
        arg4: *mut XColor,
        arg5: *mut XColor,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XLowerWindow(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XMapRaised(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XMapSubwindows(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XMapWindow(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XMaskEvent(arg1: *mut Display, arg2: libc::c_long, arg3: *mut XEvent) -> libc::c_int;
}
extern "C" {
    pub fn XMaxCmapsOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XMinCmapsOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XMoveResizeWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_uint,
        arg6: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XMoveWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_int,
        arg4: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XNextEvent(arg1: *mut Display, arg2: *mut XEvent) -> libc::c_int;
}
extern "C" {
    pub fn XNoOp(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XParseColor(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *const libc::c_char,
        arg4: *mut XColor,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XParseGeometry(
        arg1: *const libc::c_char,
        arg2: *mut libc::c_int,
        arg3: *mut libc::c_int,
        arg4: *mut libc::c_uint,
        arg5: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XPeekEvent(arg1: *mut Display, arg2: *mut XEvent) -> libc::c_int;
}
extern "C" {
    pub fn XPeekIfEvent(
        arg1: *mut Display,
        arg2: *mut XEvent,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut Display,
                arg2: *mut XEvent,
                arg3: XPointer,
            ) -> libc::c_int,
        >,
        arg4: XPointer,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XPending(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XPlanesOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XProtocolRevision(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XProtocolVersion(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XPutBackEvent(arg1: *mut Display, arg2: *mut XEvent) -> libc::c_int;
}
extern "C" {
    pub fn XPutImage(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: *mut XImage,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: libc::c_int,
        arg8: libc::c_int,
        arg9: libc::c_uint,
        arg10: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XQLength(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XQueryBestCursor(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: libc::c_uint,
        arg4: libc::c_uint,
        arg5: *mut libc::c_uint,
        arg6: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XQueryBestSize(
        arg1: *mut Display,
        arg2: libc::c_int,
        arg3: Drawable,
        arg4: libc::c_uint,
        arg5: libc::c_uint,
        arg6: *mut libc::c_uint,
        arg7: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XQueryBestStipple(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: libc::c_uint,
        arg4: libc::c_uint,
        arg5: *mut libc::c_uint,
        arg6: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XQueryBestTile(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: libc::c_uint,
        arg4: libc::c_uint,
        arg5: *mut libc::c_uint,
        arg6: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XQueryColor(arg1: *mut Display, arg2: Colormap, arg3: *mut XColor) -> libc::c_int;
}
extern "C" {
    pub fn XQueryColors(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *mut XColor,
        arg4: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XQueryExtension(
        arg1: *mut Display,
        arg2: *const libc::c_char,
        arg3: *mut libc::c_int,
        arg4: *mut libc::c_int,
        arg5: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XQueryKeymap(arg1: *mut Display, arg2: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn XQueryPointer(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Window,
        arg4: *mut Window,
        arg5: *mut libc::c_int,
        arg6: *mut libc::c_int,
        arg7: *mut libc::c_int,
        arg8: *mut libc::c_int,
        arg9: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XQueryTextExtents(
        arg1: *mut Display,
        arg2: XID,
        arg3: *const libc::c_char,
        arg4: libc::c_int,
        arg5: *mut libc::c_int,
        arg6: *mut libc::c_int,
        arg7: *mut libc::c_int,
        arg8: *mut XCharStruct,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XQueryTextExtents16(
        arg1: *mut Display,
        arg2: XID,
        arg3: *const XChar2b,
        arg4: libc::c_int,
        arg5: *mut libc::c_int,
        arg6: *mut libc::c_int,
        arg7: *mut libc::c_int,
        arg8: *mut XCharStruct,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XQueryTree(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Window,
        arg4: *mut Window,
        arg5: *mut *mut Window,
        arg6: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XRaiseWindow(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XReadBitmapFile(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: *const libc::c_char,
        arg4: *mut libc::c_uint,
        arg5: *mut libc::c_uint,
        arg6: *mut Pixmap,
        arg7: *mut libc::c_int,
        arg8: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XReadBitmapFileData(
        arg1: *const libc::c_char,
        arg2: *mut libc::c_uint,
        arg3: *mut libc::c_uint,
        arg4: *mut *mut libc::c_uchar,
        arg5: *mut libc::c_int,
        arg6: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XRebindKeysym(
        arg1: *mut Display,
        arg2: KeySym,
        arg3: *mut KeySym,
        arg4: libc::c_int,
        arg5: *const libc::c_uchar,
        arg6: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XRecolorCursor(
        arg1: *mut Display,
        arg2: Cursor,
        arg3: *mut XColor,
        arg4: *mut XColor,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XRefreshKeyboardMapping(arg1: *mut XMappingEvent) -> libc::c_int;
}
extern "C" {
    pub fn XRemoveFromSaveSet(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XRemoveHost(arg1: *mut Display, arg2: *mut XHostAddress) -> libc::c_int;
}
extern "C" {
    pub fn XRemoveHosts(
        arg1: *mut Display,
        arg2: *mut XHostAddress,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XReparentWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: Window,
        arg4: libc::c_int,
        arg5: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XResetScreenSaver(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XResizeWindow(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_uint,
        arg4: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XRestackWindows(arg1: *mut Display, arg2: *mut Window, arg3: libc::c_int)
        -> libc::c_int;
}
extern "C" {
    pub fn XRotateBuffers(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XRotateWindowProperties(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut Atom,
        arg4: libc::c_int,
        arg5: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XScreenCount(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XSelectInput(arg1: *mut Display, arg2: Window, arg3: libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn XSendEvent(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_int,
        arg4: libc::c_long,
        arg5: *mut XEvent,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetAccessControl(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSetArcMode(arg1: *mut Display, arg2: GC, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSetBackground(arg1: *mut Display, arg2: GC, arg3: libc::c_ulong) -> libc::c_int;
}
extern "C" {
    pub fn XSetClipMask(arg1: *mut Display, arg2: GC, arg3: Pixmap) -> libc::c_int;
}
extern "C" {
    pub fn XSetClipOrigin(
        arg1: *mut Display,
        arg2: GC,
        arg3: libc::c_int,
        arg4: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetClipRectangles(
        arg1: *mut Display,
        arg2: GC,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: *mut XRectangle,
        arg6: libc::c_int,
        arg7: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetCloseDownMode(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSetCommand(
        arg1: *mut Display,
        arg2: Window,
        arg3: *mut *mut libc::c_char,
        arg4: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetDashes(
        arg1: *mut Display,
        arg2: GC,
        arg3: libc::c_int,
        arg4: *const libc::c_char,
        arg5: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetFillRule(arg1: *mut Display, arg2: GC, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSetFillStyle(arg1: *mut Display, arg2: GC, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSetFont(arg1: *mut Display, arg2: GC, arg3: Font) -> libc::c_int;
}
extern "C" {
    pub fn XSetFontPath(
        arg1: *mut Display,
        arg2: *mut *mut libc::c_char,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetForeground(arg1: *mut Display, arg2: GC, arg3: libc::c_ulong) -> libc::c_int;
}
extern "C" {
    pub fn XSetFunction(arg1: *mut Display, arg2: GC, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSetGraphicsExposures(arg1: *mut Display, arg2: GC, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSetIconName(arg1: *mut Display, arg2: Window, arg3: *const libc::c_char)
        -> libc::c_int;
}
extern "C" {
    pub fn XSetInputFocus(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_int,
        arg4: Time,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetLineAttributes(
        arg1: *mut Display,
        arg2: GC,
        arg3: libc::c_uint,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetModifierMapping(arg1: *mut Display, arg2: *mut XModifierKeymap) -> libc::c_int;
}
extern "C" {
    pub fn XSetPlaneMask(arg1: *mut Display, arg2: GC, arg3: libc::c_ulong) -> libc::c_int;
}
extern "C" {
    pub fn XSetPointerMapping(
        arg1: *mut Display,
        arg2: *const libc::c_uchar,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetScreenSaver(
        arg1: *mut Display,
        arg2: libc::c_int,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetSelectionOwner(
        arg1: *mut Display,
        arg2: Atom,
        arg3: Window,
        arg4: Time,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetState(
        arg1: *mut Display,
        arg2: GC,
        arg3: libc::c_ulong,
        arg4: libc::c_ulong,
        arg5: libc::c_int,
        arg6: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetStipple(arg1: *mut Display, arg2: GC, arg3: Pixmap) -> libc::c_int;
}
extern "C" {
    pub fn XSetSubwindowMode(arg1: *mut Display, arg2: GC, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XSetTSOrigin(
        arg1: *mut Display,
        arg2: GC,
        arg3: libc::c_int,
        arg4: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetTile(arg1: *mut Display, arg2: GC, arg3: Pixmap) -> libc::c_int;
}
extern "C" {
    pub fn XSetWindowBackground(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetWindowBackgroundPixmap(
        arg1: *mut Display,
        arg2: Window,
        arg3: Pixmap,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetWindowBorder(arg1: *mut Display, arg2: Window, arg3: libc::c_ulong) -> libc::c_int;
}
extern "C" {
    pub fn XSetWindowBorderPixmap(arg1: *mut Display, arg2: Window, arg3: Pixmap) -> libc::c_int;
}
extern "C" {
    pub fn XSetWindowBorderWidth(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSetWindowColormap(arg1: *mut Display, arg2: Window, arg3: Colormap) -> libc::c_int;
}
extern "C" {
    pub fn XStoreBuffer(
        arg1: *mut Display,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XStoreBytes(
        arg1: *mut Display,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XStoreColor(arg1: *mut Display, arg2: Colormap, arg3: *mut XColor) -> libc::c_int;
}
extern "C" {
    pub fn XStoreColors(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *mut XColor,
        arg4: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XStoreName(arg1: *mut Display, arg2: Window, arg3: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn XStoreNamedColor(
        arg1: *mut Display,
        arg2: Colormap,
        arg3: *const libc::c_char,
        arg4: libc::c_ulong,
        arg5: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSync(arg1: *mut Display, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn XTextExtents(
        arg1: *mut XFontStruct,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: *mut libc::c_int,
        arg5: *mut libc::c_int,
        arg6: *mut libc::c_int,
        arg7: *mut XCharStruct,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XTextExtents16(
        arg1: *mut XFontStruct,
        arg2: *const XChar2b,
        arg3: libc::c_int,
        arg4: *mut libc::c_int,
        arg5: *mut libc::c_int,
        arg6: *mut libc::c_int,
        arg7: *mut XCharStruct,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XTextWidth(
        arg1: *mut XFontStruct,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XTextWidth16(
        arg1: *mut XFontStruct,
        arg2: *const XChar2b,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XTranslateCoordinates(
        arg1: *mut Display,
        arg2: Window,
        arg3: Window,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *mut libc::c_int,
        arg7: *mut libc::c_int,
        arg8: *mut Window,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XUndefineCursor(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XUngrabButton(
        arg1: *mut Display,
        arg2: libc::c_uint,
        arg3: libc::c_uint,
        arg4: Window,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XUngrabKey(
        arg1: *mut Display,
        arg2: libc::c_int,
        arg3: libc::c_uint,
        arg4: Window,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XUngrabKeyboard(arg1: *mut Display, arg2: Time) -> libc::c_int;
}
extern "C" {
    pub fn XUngrabPointer(arg1: *mut Display, arg2: Time) -> libc::c_int;
}
extern "C" {
    pub fn XUngrabServer(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XUninstallColormap(arg1: *mut Display, arg2: Colormap) -> libc::c_int;
}
extern "C" {
    pub fn XUnloadFont(arg1: *mut Display, arg2: Font) -> libc::c_int;
}
extern "C" {
    pub fn XUnmapSubwindows(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XUnmapWindow(arg1: *mut Display, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XVendorRelease(arg1: *mut Display) -> libc::c_int;
}
extern "C" {
    pub fn XWarpPointer(
        arg1: *mut Display,
        arg2: Window,
        arg3: Window,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: libc::c_uint,
        arg7: libc::c_uint,
        arg8: libc::c_int,
        arg9: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XWidthMMOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XWidthOfScreen(arg1: *mut Screen) -> libc::c_int;
}
extern "C" {
    pub fn XWindowEvent(
        arg1: *mut Display,
        arg2: Window,
        arg3: libc::c_long,
        arg4: *mut XEvent,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XWriteBitmapFile(
        arg1: *mut Display,
        arg2: *const libc::c_char,
        arg3: Pixmap,
        arg4: libc::c_uint,
        arg5: libc::c_uint,
        arg6: libc::c_int,
        arg7: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XSupportsLocale() -> libc::c_int;
}
extern "C" {
    pub fn XSetLocaleModifiers(arg1: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn XOpenOM(
        arg1: *mut Display,
        arg2: *mut _XrmHashBucketRec,
        arg3: *const libc::c_char,
        arg4: *const libc::c_char,
    ) -> XOM;
}
extern "C" {
    pub fn XCloseOM(arg1: XOM) -> libc::c_int;
}
extern "C" {
    pub fn XSetOMValues(arg1: XOM, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn XGetOMValues(arg1: XOM, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn XDisplayOfOM(arg1: XOM) -> *mut Display;
}
extern "C" {
    pub fn XLocaleOfOM(arg1: XOM) -> *mut libc::c_char;
}
extern "C" {
    pub fn XCreateOC(arg1: XOM, ...) -> XOC;
}
extern "C" {
    pub fn XDestroyOC(arg1: XOC);
}
extern "C" {
    pub fn XOMOfOC(arg1: XOC) -> XOM;
}
extern "C" {
    pub fn XSetOCValues(arg1: XOC, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn XGetOCValues(arg1: XOC, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn XCreateFontSet(
        arg1: *mut Display,
        arg2: *const libc::c_char,
        arg3: *mut *mut *mut libc::c_char,
        arg4: *mut libc::c_int,
        arg5: *mut *mut libc::c_char,
    ) -> XFontSet;
}
extern "C" {
    pub fn XFreeFontSet(arg1: *mut Display, arg2: XFontSet);
}
extern "C" {
    pub fn XFontsOfFontSet(
        arg1: XFontSet,
        arg2: *mut *mut *mut XFontStruct,
        arg3: *mut *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XBaseFontNameListOfFontSet(arg1: XFontSet) -> *mut libc::c_char;
}
extern "C" {
    pub fn XLocaleOfFontSet(arg1: XFontSet) -> *mut libc::c_char;
}
extern "C" {
    pub fn XContextDependentDrawing(arg1: XFontSet) -> libc::c_int;
}
extern "C" {
    pub fn XDirectionalDependentDrawing(arg1: XFontSet) -> libc::c_int;
}
extern "C" {
    pub fn XContextualDrawing(arg1: XFontSet) -> libc::c_int;
}
extern "C" {
    pub fn XExtentsOfFontSet(arg1: XFontSet) -> *mut XFontSetExtents;
}
extern "C" {
    pub fn XmbTextEscapement(
        arg1: XFontSet,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XwcTextEscapement(
        arg1: XFontSet,
        arg2: *const wchar_t,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Xutf8TextEscapement(
        arg1: XFontSet,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XmbTextExtents(
        arg1: XFontSet,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: *mut XRectangle,
        arg5: *mut XRectangle,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XwcTextExtents(
        arg1: XFontSet,
        arg2: *const wchar_t,
        arg3: libc::c_int,
        arg4: *mut XRectangle,
        arg5: *mut XRectangle,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Xutf8TextExtents(
        arg1: XFontSet,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: *mut XRectangle,
        arg5: *mut XRectangle,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XmbTextPerCharExtents(
        arg1: XFontSet,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: *mut XRectangle,
        arg5: *mut XRectangle,
        arg6: libc::c_int,
        arg7: *mut libc::c_int,
        arg8: *mut XRectangle,
        arg9: *mut XRectangle,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XwcTextPerCharExtents(
        arg1: XFontSet,
        arg2: *const wchar_t,
        arg3: libc::c_int,
        arg4: *mut XRectangle,
        arg5: *mut XRectangle,
        arg6: libc::c_int,
        arg7: *mut libc::c_int,
        arg8: *mut XRectangle,
        arg9: *mut XRectangle,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Xutf8TextPerCharExtents(
        arg1: XFontSet,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: *mut XRectangle,
        arg5: *mut XRectangle,
        arg6: libc::c_int,
        arg7: *mut libc::c_int,
        arg8: *mut XRectangle,
        arg9: *mut XRectangle,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XmbDrawText(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *mut XmbTextItem,
        arg7: libc::c_int,
    );
}
extern "C" {
    pub fn XwcDrawText(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *mut XwcTextItem,
        arg7: libc::c_int,
    );
}
extern "C" {
    pub fn Xutf8DrawText(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: GC,
        arg4: libc::c_int,
        arg5: libc::c_int,
        arg6: *mut XmbTextItem,
        arg7: libc::c_int,
    );
}
extern "C" {
    pub fn XmbDrawString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: XFontSet,
        arg4: GC,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: *const libc::c_char,
        arg8: libc::c_int,
    );
}
extern "C" {
    pub fn XwcDrawString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: XFontSet,
        arg4: GC,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: *const wchar_t,
        arg8: libc::c_int,
    );
}
extern "C" {
    pub fn Xutf8DrawString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: XFontSet,
        arg4: GC,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: *const libc::c_char,
        arg8: libc::c_int,
    );
}
extern "C" {
    pub fn XmbDrawImageString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: XFontSet,
        arg4: GC,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: *const libc::c_char,
        arg8: libc::c_int,
    );
}
extern "C" {
    pub fn XwcDrawImageString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: XFontSet,
        arg4: GC,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: *const wchar_t,
        arg8: libc::c_int,
    );
}
extern "C" {
    pub fn Xutf8DrawImageString(
        arg1: *mut Display,
        arg2: Drawable,
        arg3: XFontSet,
        arg4: GC,
        arg5: libc::c_int,
        arg6: libc::c_int,
        arg7: *const libc::c_char,
        arg8: libc::c_int,
    );
}
extern "C" {
    pub fn XOpenIM(
        arg1: *mut Display,
        arg2: *mut _XrmHashBucketRec,
        arg3: *mut libc::c_char,
        arg4: *mut libc::c_char,
    ) -> XIM;
}
extern "C" {
    pub fn XCloseIM(arg1: XIM) -> libc::c_int;
}
extern "C" {
    pub fn XGetIMValues(arg1: XIM, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn XSetIMValues(arg1: XIM, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn XDisplayOfIM(arg1: XIM) -> *mut Display;
}
extern "C" {
    pub fn XLocaleOfIM(arg1: XIM) -> *mut libc::c_char;
}
extern "C" {
    pub fn XCreateIC(arg1: XIM, ...) -> XIC;
}
extern "C" {
    pub fn XDestroyIC(arg1: XIC);
}
extern "C" {
    pub fn XSetICFocus(arg1: XIC);
}
extern "C" {
    pub fn XUnsetICFocus(arg1: XIC);
}
extern "C" {
    pub fn XwcResetIC(arg1: XIC) -> *mut wchar_t;
}
extern "C" {
    pub fn XmbResetIC(arg1: XIC) -> *mut libc::c_char;
}
extern "C" {
    pub fn Xutf8ResetIC(arg1: XIC) -> *mut libc::c_char;
}
extern "C" {
    pub fn XSetICValues(arg1: XIC, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn XGetICValues(arg1: XIC, ...) -> *mut libc::c_char;
}
extern "C" {
    pub fn XIMOfIC(arg1: XIC) -> XIM;
}
extern "C" {
    pub fn XFilterEvent(arg1: *mut XEvent, arg2: Window) -> libc::c_int;
}
extern "C" {
    pub fn XmbLookupString(
        arg1: XIC,
        arg2: *mut XKeyPressedEvent,
        arg3: *mut libc::c_char,
        arg4: libc::c_int,
        arg5: *mut KeySym,
        arg6: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XwcLookupString(
        arg1: XIC,
        arg2: *mut XKeyPressedEvent,
        arg3: *mut wchar_t,
        arg4: libc::c_int,
        arg5: *mut KeySym,
        arg6: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn Xutf8LookupString(
        arg1: XIC,
        arg2: *mut XKeyPressedEvent,
        arg3: *mut libc::c_char,
        arg4: libc::c_int,
        arg5: *mut KeySym,
        arg6: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XVaCreateNestedList(arg1: libc::c_int, ...) -> XVaNestedList;
}
extern "C" {
    pub fn XRegisterIMInstantiateCallback(
        arg1: *mut Display,
        arg2: *mut _XrmHashBucketRec,
        arg3: *mut libc::c_char,
        arg4: *mut libc::c_char,
        arg5: XIDProc,
        arg6: XPointer,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XUnregisterIMInstantiateCallback(
        arg1: *mut Display,
        arg2: *mut _XrmHashBucketRec,
        arg3: *mut libc::c_char,
        arg4: *mut libc::c_char,
        arg5: XIDProc,
        arg6: XPointer,
    ) -> libc::c_int;
}
pub type XConnectionWatchProc = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut Display,
        arg2: XPointer,
        arg3: libc::c_int,
        arg4: libc::c_int,
        arg5: *mut XPointer,
    ),
>;
extern "C" {
    pub fn XInternalConnectionNumbers(
        arg1: *mut Display,
        arg2: *mut *mut libc::c_int,
        arg3: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XProcessInternalConnection(arg1: *mut Display, arg2: libc::c_int);
}
extern "C" {
    pub fn XAddConnectionWatch(
        arg1: *mut Display,
        arg2: XConnectionWatchProc,
        arg3: XPointer,
    ) -> libc::c_int;
}
extern "C" {
    pub fn XRemoveConnectionWatch(arg1: *mut Display, arg2: XConnectionWatchProc, arg3: XPointer);
}
extern "C" {
    pub fn XSetAuthorization(
        arg1: *mut libc::c_char,
        arg2: libc::c_int,
        arg3: *mut libc::c_char,
        arg4: libc::c_int,
    );
}
extern "C" {
    pub fn _Xmbtowc(arg1: *mut wchar_t, arg2: *mut libc::c_char, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _Xwctomb(arg1: *mut libc::c_char, arg2: wchar_t) -> libc::c_int;
}
extern "C" {
    pub fn XGetEventData(arg1: *mut Display, arg2: *mut XGenericEventCookie) -> libc::c_int;
}
extern "C" {
    pub fn XFreeEventData(arg1: *mut Display, arg2: *mut XGenericEventCookie);
}
#[repr(u32)]
#[doc = "  These are the various supported windowing subsystems"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub enum SDL_SYSWM_TYPE {
    SDL_SYSWM_UNKNOWN = 0,
    SDL_SYSWM_ANDROID = 1,
    SDL_SYSWM_COCOA = 2,
    SDL_SYSWM_HAIKU = 3,
    SDL_SYSWM_KMSDRM = 4,
    SDL_SYSWM_RISCOS = 5,
    SDL_SYSWM_UIKIT = 6,
    SDL_SYSWM_VIVANTE = 7,
    SDL_SYSWM_WAYLAND = 8,
    SDL_SYSWM_WINDOWS = 9,
    SDL_SYSWM_WINRT = 10,
    SDL_SYSWM_X11 = 11,
}
#[doc = "  The custom event structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SysWMmsg {
    pub version: Uint32,
    #[doc = "< SDL_SYSWM_TYPE"]
    pub subsystem: Uint32,
    pub padding: [Uint32; 2usize],
    pub msg: SDL_SysWMmsg__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_SysWMmsg__bindgen_ty_1 {
    pub x11: SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1,
    pub dummy: libc::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1 {
    pub event: XEvent,
}
#[test]
fn bindgen_test_layout_SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1>(),
        192usize,
        concat!(
            "Size of: ",
            stringify!(SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMmsg__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(event)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_SysWMmsg__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_SysWMmsg__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_SysWMmsg__bindgen_ty_1>(),
        192usize,
        concat!("Size of: ", stringify!(SDL_SysWMmsg__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_SysWMmsg__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_SysWMmsg__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x11) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMmsg__bindgen_ty_1),
            "::",
            stringify!(x11)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMmsg__bindgen_ty_1),
            "::",
            stringify!(dummy)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_SysWMmsg() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_SysWMmsg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_SysWMmsg>(),
        208usize,
        concat!("Size of: ", stringify!(SDL_SysWMmsg))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_SysWMmsg>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_SysWMmsg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMmsg),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subsystem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMmsg),
            "::",
            stringify!(subsystem)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMmsg),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMmsg),
            "::",
            stringify!(msg)
        )
    );
}
#[doc = "  The custom window manager information structure.\n\n  When this structure is returned, it holds information about which\n  low level system it is using, and will be one of SDL_SYSWM_TYPE."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SysWMinfo {
    pub version: Uint32,
    #[doc = "< SDL_SYSWM_TYPE"]
    pub subsystem: Uint32,
    pub padding: [Uint32; 2usize],
    pub info: SDL_SysWMinfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_SysWMinfo__bindgen_ty_1 {
    pub x11: SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1,
    pub wl: SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2,
    pub kmsdrm: SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_3,
    pub dummy_ptrs: [*mut libc::c_void; 14usize],
    pub dummy_ints: [Uint64; 14usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< The X11 display"]
    pub display: *mut Display,
    #[doc = "< The X11 screen"]
    pub screen: libc::c_int,
    #[doc = "< The X11 window"]
    pub window: Window,
}
#[test]
fn bindgen_test_layout_SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).screen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(screen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< Wayland display"]
    pub display: *mut wl_display,
    #[doc = "< Wayland surface"]
    pub surface: *mut wl_surface,
    #[doc = "< Wayland EGL window (native window)"]
    pub egl_window: *mut wl_egl_window,
    #[doc = "< Wayland xdg surface (window manager handle)"]
    pub xdg_surface: *mut xdg_surface,
    #[doc = "< Wayland xdg toplevel role"]
    pub xdg_toplevel: *mut xdg_toplevel,
    #[doc = "< Wayland xdg popup role"]
    pub xdg_popup: *mut xdg_popup,
    #[doc = "< Wayland xdg positioner, for popup"]
    pub xdg_positioner: *mut xdg_positioner,
}
#[test]
fn bindgen_test_layout_SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).surface) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(surface)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).egl_window) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(egl_window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xdg_surface) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(xdg_surface)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xdg_toplevel) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(xdg_toplevel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xdg_popup) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(xdg_popup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xdg_positioner) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(xdg_positioner)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_3 {
    #[doc = "< Device index (ex: the X in /dev/dri/cardX)"]
    pub dev_index: libc::c_int,
    #[doc = "< DRM FD (unavailable on Vulkan windows)"]
    pub drm_fd: libc::c_int,
    #[doc = "< GBM device (unavailable on Vulkan windows)"]
    pub gbm_dev: *mut gbm_device,
}
#[test]
fn bindgen_test_layout_SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_3> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(dev_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).drm_fd) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(drm_fd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gbm_dev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(gbm_dev)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_SysWMinfo__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_SysWMinfo__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_SysWMinfo__bindgen_ty_1>(),
        112usize,
        concat!("Size of: ", stringify!(SDL_SysWMinfo__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_SysWMinfo__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_SysWMinfo__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x11) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1),
            "::",
            stringify!(x11)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1),
            "::",
            stringify!(wl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).kmsdrm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1),
            "::",
            stringify!(kmsdrm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dummy_ptrs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1),
            "::",
            stringify!(dummy_ptrs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dummy_ints) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo__bindgen_ty_1),
            "::",
            stringify!(dummy_ints)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_SysWMinfo() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_SysWMinfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_SysWMinfo>(),
        128usize,
        concat!("Size of: ", stringify!(SDL_SysWMinfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_SysWMinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SDL_SysWMinfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subsystem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo),
            "::",
            stringify!(subsystem)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMinfo),
            "::",
            stringify!(info)
        )
    );
}
extern "C" {
    #[doc = " Get driver-specific information about a window.\n\n You must include SDL_syswm.h for the declaration of SDL_SysWMinfo.\n\n \\param window the window about which information is being requested\n \\param info an SDL_SysWMinfo structure filled in with window information\n \\param version the version of info being requested, should be\n                SDL_SYSWM_CURRENT_VERSION\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_GetWindowWMInfo(
        window: *mut SDL_Window,
        info: *mut SDL_SysWMinfo,
        version: Uint32,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkInstance_T {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VkSurfaceKHR_T {
    _unused: [u8; 0],
}
pub type SDL_vulkanInstance = VkInstance;
pub type SDL_vulkanSurface = VkSurfaceKHR;
extern "C" {
    #[doc = " Dynamically load the Vulkan loader library.\n\n This should be called after initializing the video driver, but before\n creating any Vulkan windows. If no Vulkan loader library is loaded, the\n default library will be loaded upon creation of the first Vulkan window.\n\n It is fairly common for Vulkan applications to link with libvulkan instead\n of explicitly loading it at run time. This will work with SDL provided the\n application links to a dynamic library and both it and SDL use the same\n search path.\n\n If you specify a non-NULL `path`, an application should retrieve all of the\n Vulkan functions it uses from the dynamic library using\n SDL_Vulkan_GetVkGetInstanceProcAddr unless you can guarantee `path` points\n to the same vulkan loader library the application linked to.\n\n On Apple devices, if `path` is NULL, SDL will attempt to find the\n `vkGetInstanceProcAddr` address within all the Mach-O images of the current\n process. This is because it is fairly common for Vulkan applications to\n link with libvulkan (and historically MoltenVK was provided as a static\n library). If it is not found, on macOS, SDL will attempt to load\n `vulkan.framework/vulkan`, `libvulkan.1.dylib`,\n `MoltenVK.framework/MoltenVK`, and `libMoltenVK.dylib`, in that order. On\n iOS, SDL will attempt to load `libMoltenVK.dylib`. Applications using a\n dynamic framework or .dylib must ensure it is included in its application\n bundle.\n\n On non-Apple devices, application linking with a static libvulkan is not\n supported. Either do not link to the Vulkan loader or link to a dynamic\n library version.\n\n \\param path The platform dependent Vulkan loader library name or NULL\n \\returns 0 on success or a negative error code on failure; call\n          SDL_GetError() for more information.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_Vulkan_GetVkInstanceProcAddr\n \\sa SDL_Vulkan_UnloadLibrary"]
    pub fn SDL_Vulkan_LoadLibrary(path: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the address of the `vkGetInstanceProcAddr` function.\n\n This should be called after either calling SDL_Vulkan_LoadLibrary() or\n creating an SDL_Window with the `SDL_WINDOW_VULKAN` flag.\n\n The actual type of the returned function pointer is\n PFN_vkGetInstanceProcAddr, but that isn't available because the Vulkan\n headers are not included here. You should cast the return value of this\n function to that type, e.g.\n\n `vkGetInstanceProcAddr =\n (PFN_vkGetInstanceProcAddr)SDL_Vulkan_GetVkGetInstanceProcAddr();`\n\n \\returns the function pointer for `vkGetInstanceProcAddr` or NULL on error.\n\n \\since This function is available since SDL 3.0.0."]
    pub fn SDL_Vulkan_GetVkGetInstanceProcAddr() -> SDL_FunctionPointer;
}
extern "C" {
    #[doc = " Unload the Vulkan library previously loaded by SDL_Vulkan_LoadLibrary()\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_Vulkan_LoadLibrary"]
    pub fn SDL_Vulkan_UnloadLibrary();
}
extern "C" {
    #[doc = " Get the names of the Vulkan instance extensions needed to create a surface\n with SDL_Vulkan_CreateSurface.\n\n This should be called after either calling SDL_Vulkan_LoadLibrary() or\n creating an SDL_Window with the `SDL_WINDOW_VULKAN` flag.\n\n If `pNames` is NULL, then the number of required Vulkan instance extensions\n is returned in `pCount`. Otherwise, `pCount` must point to a variable set\n to the number of elements in the `pNames` array, and on return the variable\n is overwritten with the number of names actually written to `pNames`. If\n `pCount` is less than the number of required extensions, at most `pCount`\n structures will be written. If `pCount` is smaller than the number of\n required extensions, SDL_FALSE will be returned instead of SDL_TRUE, to\n indicate that not all the required extensions were returned.\n\n \\param pCount A pointer to an unsigned int corresponding to the number of\n               extensions to be returned\n \\param pNames NULL or a pointer to an array to be filled with required\n               Vulkan instance extensions\n \\returns SDL_TRUE on success, SDL_FALSE on error.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_Vulkan_CreateSurface"]
    pub fn SDL_Vulkan_GetInstanceExtensions(
        pCount: *mut libc::c_uint,
        pNames: *mut *const libc::c_char,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " Create a Vulkan rendering surface for a window.\n\n The `window` must have been created with the `SDL_WINDOW_VULKAN` flag and\n `instance` must have been created with extensions returned by\n SDL_Vulkan_GetInstanceExtensions() enabled.\n\n \\param window The window to which to attach the Vulkan surface\n \\param instance The Vulkan instance handle\n \\param surface A pointer to a VkSurfaceKHR handle to output the newly\n                created surface\n \\returns SDL_TRUE on success, SDL_FALSE on error.\n\n \\since This function is available since SDL 3.0.0.\n\n \\sa SDL_Vulkan_GetInstanceExtensions"]
    pub fn SDL_Vulkan_CreateSurface(
        window: *mut SDL_Window,
        instance: VkInstance,
        surface: *mut VkSurfaceKHR,
    ) -> SDL_bool;
}
#[doc = " <div rustbindgen replaces=\"VkInstance\"></div>"]
pub type VkInstance = usize;
#[doc = " <div rustbindgen replaces=\"VkSurfaceKHR\"></div>"]
pub type VkSurfaceKHR = u64;
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::core::mem::MaybeUninit<__va_list_tag> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
